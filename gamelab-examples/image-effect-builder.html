<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Effect Builder</title>
    <script src="../dist/gamelab/gamelab.js"></script>
    <script src="./../res/libraries/dat.gui.js"></script>
    <script src="./../res/libraries/jsmanipulate.js"></script>
    <script src="./res/html/gui-helpers.js"></script>
    <!-- spritebox-example.css style -->
    <link rel="stylesheet" href="../res/styles/gamelab-example.css">

    <style>

      span.dgc-title {
        position: absolute;
        z-index: 9999;
        width: 241px;
        height: 20px;
        font-size: 12px;
        top: 0;
        overflow: visible;
        background: #111;
        color: lightgrey;
        padding-left: 4px;
        border-bottom: 1px solid #444;
      }


      canvas.gamewindow,   canvas.gameWindow,   canvas.game-window{
          margin-top:-20px;
      }

    </style>

  </head>
  <body>
    <header>
      <img src="../res/images/gamelab-logo.png" alt="" id="logo">
      <span class="title">Image Effect Builder</span>
    </header>


    <img id="spritesheet-preview" src="" alt="" class="preview">

    <script>

      var sprite = new Gamelab.Sprite('./res/images/shapes/black-rect.png').Scale(1.0),

        args = false;

      function ImageFilter(name) {
        this.name = name;
        this.instance = new JSManipulate[name].constructor();
        this.filterFunction = this.instance.filter;

        this.defaultValues = this.instance.defaultValues || false;
        this.valueRanges = this.instance.valueRanges || false;

      };

      function ImageFilterStepEffect(name, curve) {
        this.name = name;
        this.instance = new JSManipulate[name].constructor();
        this.filterFunction = this.instance.filter;

        this.defaultValues = this.instance.defaultValues || false;
        this.valueRanges = this.instance.valueRanges || false;

        this.values = JSON.parse(JSON.stringify(this.defaultValues));
        this.timer = 0;
        this.duration = 2000;
        this.stepValue = (this.duration / 1000) * 60; //60 frames second
        this.stepFunction = Gamelab.Curves[curve];

        this.min = function () {

          var obj = {};

          for (var x in this.valueRanges) {
            obj[x] = this.valueRanges[x].min;
          }

          return obj;

        };

        this.next = function (data) {

          for (var x in this.values) {

            if (this.valueRanges[x] && this.valueRanges[x].hasOwnProperty('min') && this.valueRanges[x].hasOwnProperty('max')) {
              var min = this.valueRanges[x].min,
                max = this.valueRanges[x].max;

              var diff = Math.abs(min - max);

              if (min > max) {
                var c = min;
                min = max;
                max = c;
              }

              var portion = this.timer / this.duration;
              console.log('portion:' + portion);
              this.values[x] = min + (this.stepFunction(portion) * diff);

              this.instance.filter(data, this.values);
            }

          }

        };

        this.prepare = function (sprite) {

          this.timer = 0;
          this.values = this.min();
          while (this.timer < this.duration) {
            sprite.addFilterFrame(this, function () {
              console.log('filter frame added');
            });

            this.timer += this.stepValue;
          }

        };

      };


      function createController(title) {

        var main = document.querySelector('.dg.main');

        if (main)
          main.remove();

        var controller = new dat.GUI();

        var domTitle = document.createElement('span');
        domTitle.classList.add('dgc-title');

        domTitle.innerHTML = title;

        controller.domElement.appendChild(domTitle);
        controller.domElement.style.marginTop = '20px';
        return controller;
      };

      /***************
      * Call gameWindow.start()
      * *************/

      var particle,
        gameWindow;

      var FilterDemo = {
        isInit: false,

        render: function (args, folders) {

          Object.keys(args).forEach(function (key) {

            args[key].sprite.resetEffectFrames();

            args[key].filter.prepare(args[key].sprite);

            if (args[key].seesaw_mode) {
              args[key].sprite.DoubleBackFilterFrames();
            }

            args[key].sprite.Position(200, 200);

          });

        }

      };

      var filterInstances = [];

      var filters = [],
        filterNames = Object.keys(JSManipulate);

      Object.keys(JSManipulate).forEach(function (key) {
        filters.push({name: key, create: JSManipulate[key].constructor});
      });

      function refreshEffectController(args) {

        var controller = createController('effects');

        if (!FilterDemo.isInit) {

          sprite.onLoad(function () {

            this.doCanvasEffects();

          });

          gameWindow.add(sprite);
          gameWindow.onBeforeDraw(function () {

            Object.keys(args).forEach(function (key) {

              console.info(args[key].sprite.position);
              console.info(args[key].sprite.size);

              console.info(args[key].sprite.anime);

              args[key].sprite.animate();

            });

          });

          FilterDemo.isInit = true;
        }

        args = args || {

          effect_01: {
            name: 'blur',
            transition_curve: 'linearNone',
            filter: new ImageFilterStepEffect('blur', 'linearNone'),
            sprite: sprite,
            seesaw_mode: false
          }
        };

        var folders = {
          effect_01: controller.addFolder('effect a1')
        };

        ['effect_01'].forEach(function (key) {

          var selectFilter = folders[key].add(args[key], 'name', filterNames),
            selectCurve = folders[key].add(args[key], 'transition_curve', Object.keys(Gamelab.Curves));

          folders[key].object = args[key];
          folders[key].object.name = key;

          selectCurve.object = folders[key].object;

          selectCurve.onChange(function (value) {

            args[key].transition_curve = value;

            refreshEffectController(args);

          });

          selectFilter.key = key;

          selectFilter.onChange(function (value) {

            args[key] = {
              name: value,
              filter: new ImageFilterStepEffect(value, args[this.key].transition_curve),
              transition_curve: args[this.key].transition_curve,
              sprite: sprite,
              seesaw_mode: false
            };
            refreshEffectController(args);
          });
        });

        

        ['effect_01'].forEach(function (key) {

          if (args[key] && args[key].filter.valueRanges) {

            var $arg = args[key].filter.valueRanges;

            for (var x in $arg) {

              var folder = folders[key].addFolder(x + '_range');

              if(x == 'centerX' || x == 'centerY')
              {
                $arg[x].min = 0.5;
                $arg[x].max = 0.5;
              }

              folder.add($arg[x], 'min');
              folder.add($arg[x], 'max');

            }

          }

          folders[key].add(args[key], 'seesaw_mode');

        });

        controller.addButton = function (text, onUpdate) {

          var main_li = document.createElement('li'),
            div1 = document.createElement('div'),

            div2 = document.createElement('div');
          div2.classList.add('c');

          var button = document.createElement('button');

          button.innerText = text;
          button.onclick = onUpdate || function () {};

          div2.appendChild(button);
          div1.appendChild(div2);
          main_li.appendChild(div1);
          var ul = this.domElement.querySelectorAll('ul')[0];
          ul.appendChild(main_li);
          return this;
        };

        controller.addSourceImage = function (object, key, id) {
          var main_li = document.createElement('li'),
            div1 = document.createElement('div');

          var div2 = document.createElement('div');
          div2.classList.add('c');

          var file_input = document.createElement('input');
          file_input.type = 'file';
          file_input.multiple = 'multi';

          div2.appendChild(file_input);
          div1.appendChild(div2);
          main_li.appendChild(div1);
          var ul = this.domElement.querySelectorAll('ul')[0];
          ul.appendChild(main_li);
          return this;
        };

        controller.addButton('Render', function () {

          FilterDemo.render(args, folders);

        });

        //call fxn .addSourceImageMulti()
        controller.addSourceImage([], 'a');

        var fileInput = controller.domElement.querySelector('input[type=file]');

        fileInput.addEventListener('change', function (evt) {

          var files = evt.target.files;

          // FileReader support
          if (FileReader && files && files.length) {
            var fr = new FileReader();
            fr.onload = function () {

              alert('resetting');

              gameWindow.remove(sprite);

              sprite = new Gamelab.Sprite(fr.result);

              sprite.onLoad(function () {

                this.doCanvasEffects();

              });

              gameWindow.add(sprite);

              refreshEffectController(args);

            }
            fr.readAsDataURL(files[0]);
          }

        });

      };

      function ready() {

        var ctrls = document.querySelectorAll('.dg.main');

        if (ctrls.length) {
          ctrls.forEach(function (item) {

            if (item)
              item.remove();

            }
          );
        }

        //Create the game-window

        gameWindow = gameWindow || new Gamelab.GameWindow().Background('black');

        gameWindow.reset_draw();

        refreshEffectController();

        setTimeout(function () {

          gameWindow.onBeforeDraw(function () {});

        }, 1000);

        //start gameWindow
        if (!BEGIN) {
          gameWindow.start();
          BEGIN = true;
        }


        var spritesheetCanvas = document.createElement('CANVAS');

        var container = document.createElement('DIV');

        container.style.position = 'absolute';

        spritesheetCanvas.style.position = 'absolute';

        spritesheetCanvas.style.width = '300px';
        spritesheetCanvas.style.height = '200px';
        spritesheetCanvas.style.border = '1px solid grey';

        spritesheetCanvas.style.background = '#222';

        spritesheetCanvas.style.cursor = 'pointer';

        container.style.left = '50px';
        container.style.top = '110px';

        container.appendChild(spritesheetCanvas);

        document.body.appendChild(container);

      };

      var BEGIN = false;

      Gamelab.ready(function () {

        ready();


      });
    </script>

  </body>
</html>
