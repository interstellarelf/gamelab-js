<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">

    <title>Shape-Stacker-Puzzle-Game</title>

    <script src="../dist/gamestack/gamestack.js"></script>
    <script src="../dist/domfx/domfx.js"></script>
    <!-- spritebox-example.css style -->
    <link rel="stylesheet" href="../res/styles/spritebox-example.css">

    <!--#How to run: be sure that gamestack/server.js is running on node. Then go to http://localhost:3137/main.html, then click the name/link of this document -->

</head>
<body style="background-color:black;">
  <header>
    <img src="../res/images/gamestack-logo.png" alt="" id="logo">
    <span class="title">Game-Sprites-01</span>
  </header>


<script>

    /************************
     *
     * Shape-Stacker
     *  Similar to 'tetris'
     * *************************/

    /************************
     *
     * Known Errors
     *   1. xCollision does not stop vertical bar, possibly other shapes from fitting over-top one-another
     *   2. shapes will rarely have touchingGround == true when they are still one empty square up from the 'ground-level' (the shape beneath selectedShape).
     * *************************/


    var $g = Gamestack, gameWindow = new Gamestack.GameWindow(); //instantiate GameWindow

    console.log('gameWindow created.');

    var Settings = {

        gridChunkSize:20
    };


    var INPUT = {
      Controller:{
          stick_left:{x:0, y:0}
      }
    };

    new Gamestack.GamepadEvent()
        .Keys('stick_left')
        .Call(function(x, y){
            INPUT.Controller.stick_left.x = x;
            INPUT.Controller.stick_left.y = y;
        });

    new Gamestack.GamepadEvent()
        .Keys('button_0')
        .Call(function(pressed){

            if(pressed)
            {
                Game.selectedShape.floorIt();

            }

        });


    new Gamestack.GamepadEvent()
        .Keys('button_6')
        .Call(function(pressed){

          if(pressed && !Game.selectedShape.__rLocked){

                Game.selectedShape.rotation.x += 90;

                Game.selectedShape.swapComputedSize();

                Game.selectedShape.colorCoords.next(Game.selectedShape);

                Game.selectedShape.lockRotation();

            }

        });


    var keys = new $g.InputEvent({

        keys: ["S", "DOWN", "A", "LEFT", "D", "RIGHT"],

        callback: function (key) {

            //always runs

            key = key.toLowerCase();

            if (Game.selectedShape.touchingGround)
                return;

            if (key == 'down' || key == 's')
                Game.selectedShape.position.y += 2;

            if ((!Game.selectedShape.__xLocked) && (key == 'left' || key == 'a')) {
                Game.selectedShape.position.x -= Settings.gridChunkSize;
                Game.selectedShape.lockX();
            }

            else if ((!Game.selectedShape.__xLocked) &&  (key == 'right' || key == 'd')) {
                Game.selectedShape.position.x += Settings.gridChunkSize;
                Game.selectedShape.lockX();
            }

        }

    });

    function ColorCoords(stateOne, stateTwo, stateThree, stateFour) {

        this.arrayStates = [stateOne, stateTwo, stateThree, stateFour];

        var vectorStates = [[]];

        this.respawn = function(){

            return new ColorCoords(this.arrayStates[0], this.arrayStates[1],this.arrayStates[2], this.arrayStates[3]);

        };

        function numbersToVectors(arr)
        {

            var vectors = [];

            for(var y = 0; y <  arr.length; y+=2)
            {

               vectors.push(new $g.Vector(arr[y], arr[y + 1]).mult(Settings.gridChunkSize).sub(new $g.Vector(Settings.gridChunkSize, Settings.gridChunkSize)))

            }

            return vectors;

        };


        function VectorStateArray(arr)
        {

            for(var x in arr)
            {

                arr[x] = new Gamestack.Vector(arr[x]);

            }

            return arr;
        }

        for(var x = 0; x < this.arrayStates.length; x++)
        {
            if(this.arrayStates[x] instanceof Array && this.arrayStates[x])
            vectorStates[x] = numbersToVectors(this.arrayStates[x]);
        }

        this.vectorStates = vectorStates;

        this.selectedVectors = this.vectorStates[0];

        this.first = function(){ this.selectedVectors = this.vectorStates[0]; return this.selectedVectors; };

        this.reset = function(){

          this.first();

        };

        this.next = function(sprite)
        {
            var index = 0;

            for(var x = 0; x < this.vectorStates.length; x++)
            {
                if(this.selectedVectors == this.vectorStates[x])
                {
                    index = x;
                }
            }

            index += 1;

            index = index  % this.vectorStates.length;

            this.selectedVectors = this.vectorStates[index];

            if(this.vectorStates.length == 1)
            {
                return this.selectedVectors;
            }

                if (index % 2 == 0) {
                    sprite.position.x += 10;
                    sprite.position.y += 10;

                }
                else {
                    sprite.position.x -= 10;
                    sprite.position.y -= 10;
                }

            return this.selectedVectors;
        };

    };


    function fillColumn(x)
    {

        var columnSquares = [];

        while (x % Settings.gridChunkSize !== 0)
        {
            x += 1;
        }

        for (var y = 100; y < Gamestack.HEIGHT; y += Settings.gridChunkSize) {

            if (x % Settings.gridChunkSize == 0 && y % Settings.gridChunkSize == 0) {

                var square = new Gamestack.Sprite('res/images/shape-stacker/test-square.png').Scale(0.5);

                square.position = new $g.Vector(x, y);

                columnSquares.push(square);

                square.onLoad(function(err, spr){

                    console.log(spr);



                    // alert('loaded square with pos:' + jstr(spr.position));


                });

                square.onUpdate(function(spr){

                    //console.log(spr);

                    this.selected_animation.run();

                    // alert('loaded square with pos:' + jstr(spr.position));


                });


                gameWindow.add(square);


            }

        }

        return columnSquares;

    }

    function TetraShape(name, srcPath, stateCoords1, stateCoords2, stateCoords3, stateCoords4) {

        var sprite = new Gamestack.Sprite(srcPath);

        sprite.colorCoords = new ColorCoords(stateCoords1, stateCoords2, stateCoords3, stateCoords4);

        sprite.lockX = function () {
            this.__xLocked = true;

            var __inst = this;

            window.setTimeout(function () {

                __inst.__xLocked = false;

            }, 50);

        };

        sprite.lockRotation = function()
        {
            this.__rLocked = true;

            var __inst = this;

            window.setTimeout(function () {

                __inst.__rLocked = false;

            }, 200);

        };


        sprite.getMainVectors = function (x, y) {
            var myVector = false;

            $g.each(this.colorCoords.selectedVectors, function (ix, item) {

                if (item.x == x && item.y == y) {
                    myVector = item;
                }
            });

            return myVector;

        };

        return sprite;
    };

    gameWindow.onUpdate(function () {

        if (Game.selectedShape) {
         //   Game.selectedShape.decelX(0.4)
        }
        ;

        gameWindow.removeDeadObjects();

    });


    var shapeSourceSprites = {

        bar: new TetraShape('bar', 'res/images/shape-stacker/tetra-bar.png', [1, 1, 2, 1, 3, 1, 4, 1], [1, 1, 1, 2, 1, 3, 1, 4], [1, 1, 2, 1, 3, 1, 4, 1], [1, 1, 1, 2, 1, 3, 1, 4]),
        square: new TetraShape('square','res/images/shape-stacker/tetra-square.png', [1, 1, 2, 1, 1, 2, 2, 2]),
        t: new TetraShape('t','res/images/shape-stacker/tetra-t.png', [1, 1, 2, 1, 3, 1, 2, 2], [2, 1, 1, 2, 2, 2, 2, 3],  [2, 1, 1, 2, 2, 2, 3, 2], [1, 1, 1, 2, 2, 2, 1, 3]),
        l: new TetraShape('l','res/images/shape-stacker/tetra-l.png', [1, 1, 1, 2, 1, 3, 2, 3], [1, 1, 1, 2, 2, 1, 3, 1], [1, 1, 2, 1, 2, 2, 2, 3], [1, 2, 2, 2, 3, 2, 3, 1]),
        bolt: new TetraShape('bolt','res/images/shape-stacker/tetra-bolt.png', [1, 1, 1, 2, 2, 2, 2, 3], [1, 2, 2, 2, 2, 1, 3, 1], [1, 1, 1, 2, 2, 2, 2, 3], [1, 2, 2, 2, 2, 1, 3, 1])

    };


    var RealTetraShapes = [];

    var Game = {

        movementTracker:"NONE", // 'left' || 'right' || 'up' || 'down' : stores last movement

        selectedShape: false,

        shape_frequency: 0.1,

        maxTimePerShape: 4000,

        floorLevelY:$g.HEIGHT - 50,

        gridSize:{x:700, y:Gamestack.HEIGHT  / 2},

        borderColumnLeft:[],

        borderColumnRight:[],

        __bounds:{},

        hasBegun:false,

        SIZE:{},

        POS:{},

        gravity:2,

        Bounds:function(width, height) { //Game.Bounds: returns a 'Bounds' object, arguments of width and height

            return {
                min: new Gamestack.Vector(Gamestack.WIDTH / 2 - width / 2, Gamestack.HEIGHT / 2 - height / 2),
                max: new Gamestack.Vector(Gamestack.WIDTH / 2 + width / 2, Gamestack.HEIGHT / 2 + height / 2)
            }

        },

        xMovementCheck(spr) //Game.movementCheck() : check for x-movement
        {
            var moved = false;

            var override = false;

            if(spr == Game.selectedShape && !spr.touchingGround)
            {
                if(INPUT.Controller.stick_left.x >= 0.5 && (!spr.__xLocked || override))
                {
                    spr.position.x += Settings.gridChunkSize;

                    spr.collisionX();

                    spr.borderColCollisionX();

                    spr.lockX();

                    moved = true;
                }
                if(INPUT.Controller.stick_left.x <= -0.5 && (!spr.__xLocked || override))
                {

                    spr.position.x -= Settings.gridChunkSize;

                    spr.collisionX();

                    spr.borderColCollisionX();

                    spr.lockX();

                    moved = true;

                }

            }

            return moved;

        },


        createShape: function (spriteToCopy, x, y) {

            console.log(spriteToCopy);

            var shape = new Gamestack.Sprite(spriteToCopy).Scale(0.5);

            shape.colorCoords = shape.colorCoords.respawn();

            x = Math.round(x);

            while(x % Settings.gridChunkSize !== 0)
            {
                x+= 1;
            }

           // console.log('creatingShape');

            shape.position = new $g.Vector(x, y);

            shape.highlighters = [

                new Gamestack.Sprite(Game.squareHighlighters[0]),

                new Gamestack.Sprite(Game.squareHighlighters[0]),

                new Gamestack.Sprite(Game.squareHighlighters[0]),

                new Gamestack.Sprite(Game.squareHighlighters[0]),
                new Gamestack.Sprite(Game.squareHighlighters[0]),

                new Gamestack.Sprite(Game.squareHighlighters[0]),
                new Gamestack.Sprite(Game.squareHighlighters[0]),

                new Gamestack.Sprite(Game.squareHighlighters[0])

            ];



            for(var x in shape.highlighters)
            {
                gameWindow.add(shape.highlighters[x]);

            }

            shape.onUpdate(function (spr) {

                this.selected_animation.run();

                //console.log('shape update');

                if (spr.realPositionVector().y + spr.__computedSize.y > Game.floorLevelY) {

                    Game.xMovementCheck(spr);

                    spr.position.y = Game.floorLevelY - spr.size.y / 2 - spr.__computedSize.y / 2;

                    shape.touchingGround = true;

                   // shape.speed = new $g.Vector(0, 0, 0);

                    spr.update = function(){ /*do nothing*/ };

                }
                else {
                    if (!spr.touchingGround)
                        spr.position.y += Game.gravity;

                }


                var moved = Game.xMovementCheck(spr);

                if(!spr.touchingGround)
                {
                    spr.collisionProcess();

                }

            });

            shape.__computedSize = new Gamestack.Vector(shape.size);

            shape.swapComputedSize = function(){

                var w = this.__computedSize.x;

                this.__computedSize.x = this.__computedSize.y;

                this.__computedSize.y = w;

            };

            shape.realPositionVector = function()
            {

                var realPos = this.position.add(this.size.div(2)).sub(this.__computedSize.div(2));

                for(var x in this.colorCoords.selectedVectors)
                {
                    var v = this.colorCoords.selectedVectors[x];

                   this.highlighters[x].position = realPos.add(v);

                }

                return realPos;

            };


            //ensure new shape is inside game.__bounds
            while(shape.realPositionVector().x < Game.__bounds.min.x)
            {

                shape.position.x += 1;

            }


            //ensure new shape is inside game.__bounds
            while(shape.realPositionVector().x > Game.__bounds.max.x - shape.__computedSize.x)
            {

                shape.position.x -= 1;

            }

            //get the maximum of specific color property, by argument 'key'
                shape.maxColorProp=function(key)
            {

                var max = 0;

                for(var x in this.colorCoords.selectedVectors)
                {

                    if(this.colorCoords.selectedVectors[x][key] > max)
                    {

                        max = this.colorCoords.selectedVectors[x][key];
                    }
                }

                return max;

            };


            //invert on the x-axis
            shape.invertX=function()
            {

               var maxX = this.maxColorProp('x'),
                    maxY = this.maxColorProp('y');

                for(var x in this.colorCoords.selectedVectors)
                {

                    var v = this.colorCoords.selectedVectors[x];

                    v.x = maxX - v.x;

                }

            };


            //flipOnX
            shape.flipOnX = function(){

                if(this.__flipXLocked)
                    return false;

                this.flipX = !this.flipX;

                var __inst = this;

                this.invertX();

                this.__flipXLocked = true;


                window.setTimeout(function(){

                    __inst.__flipXLocked = false;

                }, 100);

            };


            //collision detection / border columns
            shape.borderColCollisionX = function(){

                var __instShape = this;

                $g.each(Game.borderColumnLeft, function(ix, s) {

                    if(__instShape == Game.selectedShape && __instShape.borderColIntersection(s))
                    $g.each(__instShape.colorCoords.selectedVectors, function(iz, vy){

                        var pos2 = s.position,

                            pos1 = __instShape.realPositionVector().add(vy);

                        if(pos1.y + Settings.gridChunkSize > pos2.y && pos1.y < pos2.y + Settings.gridChunkSize &&  pos1.x > pos2.x - Settings.gridChunkSize &&  pos1.x  < pos2.x + Settings.gridChunkSize )
                        {
                            __instShape.position.x = pos2.add(__instShape.__computedSize.div(2)).sub(__instShape.size.div(2)).sub(vy).x + Settings.gridChunkSize;
                        }

                    });


                });

                $g.each(Game.borderColumnRight, function(ix, s) {

                    if(__instShape == Game.selectedShape && __instShape.borderColIntersection(s))
                    $g.each(__instShape.colorCoords.selectedVectors, function(iy, vy){

                     //   console.log('PROCESSING...');

                        var pos2 = s.position,

                            pos1 = __instShape.realPositionVector().add(vy);

                        if(pos1.y + Settings.gridChunkSize > pos2.y && pos1.y < pos2.y + Settings.gridChunkSize &&  pos1.x > pos2.x - Settings.gridChunkSize &&  pos1.x  < pos2.x + Settings.gridChunkSize )
                        {
                            __instShape.position.x = pos2.add(__instShape.__computedSize.div(2)).sub(__instShape.size.div(2)).sub(vy).x - Settings.gridChunkSize;

                        }

                    });


                });



            };

            //rough shape intersection (does not account for whitespace)
            shape.basicSizeIntersection = function(spr)
            {

              return  this.realPositionVector().x > spr.realPositionVector().x - this.__computedSize.x &&
                      this.realPositionVector().x < spr.realPositionVector().x + spr.__computedSize.x &&
                  this.realPositionVector().y > spr.realPositionVector().y - this.__computedSize.y &&
                  this.realPositionVector().y < spr.realPositionVector().y + spr.__computedSize.y;

            };

            //rough border-col intersection (does not account for whitespace --of shape)
            shape.borderColIntersection = function(spr)
            {

                return  this.realPositionVector().x > spr.position.x - this.__computedSize.x &&
                    this.realPositionVector().x < spr.position.x + spr.size.x &&
                    this.realPositionVector().y > spr.position.y - this.__computedSize.y &&
                    this.realPositionVector().y < spr.position.y + spr.size.y;

            };

            //return all shapes that intersect with the current position[key] by either of two sizes:
            shape.allCrossingAxis = function(key)
            {
                key = key.toLowerCase();

                if(['x', 'y'].indexOf(key) == -1)
                    return [];

                var __instShape = this;

                var crossers = [];

                $g.each(RealTetraShapes, function(ix, shape){

                    if(shape !== __instShape)
                    {
                        var diff = shape.realPositionVector().sub(__instShape.realPositionVector());

                        if(Math.abs(diff[key]) <= shape.__computedSize[key] || Math.abs(diff[key]) <= __instShape.__computedSize[key])
                        {

                            crossers.push(shape);

                        }

                    }


                });


                return crossers;

            };

            //push shape toward the floor
            shape.floorIt = function()
            {

                if(!this.touchingGround) {

                    this.position.y += 10;

                    this.collisionProcess();

                }
            };


            //collision detection for shape (x-axis only)
            shape.collisionX = function(){

                var __instShape = this;

                var yCrossers = this.allCrossingAxis('y');

                $g.each(yCrossers, function(ix, shape){

                    if(shape !== __instShape && __instShape.basicSizeIntersection(shape))
                        $g.each(shape.colorCoords.selectedVectors, function(iy, vx){

                            $g.each(__instShape.colorCoords.selectedVectors, function(iz, vy){

                                var pos2 = shape.realPositionVector().add(vx),

                                    pos1 = __instShape.realPositionVector().add(vy);


                                if(pos1.y + Settings.gridChunkSize > pos2.y && pos1.y < pos2.y + Settings.gridChunkSize &&  pos1.x + Settings.gridChunkSize > pos2.x && pos1.x < pos2.x + Settings.gridChunkSize )
                                {
                                    if(__instShape.center().x < shape.center().x)
                                    {
                                         __instShape.position.x = pos2.add(__instShape.__computedSize.div(2)).sub(__instShape.size.div(2)).sub(vy).x - Settings.gridChunkSize;
                                    }

                                    if(__instShape.center().x > shape.center().x)
                                    {
                                        __instShape.position.x = pos2.add(__instShape.__computedSize.div(2)).sub(__instShape.size.div(2)).sub(vy).x + Settings.gridChunkSize;
                                    }

                                }

                            });

                        });

                });

            };

            //main collision detection for shape (x-and-y-axis)
            shape.collisionProcess = function () {

                var __instShape = this;

                var terminate = false;

                var xCrossers = this.allCrossingAxis('x');

                if(this == Game.selectedShape)
                $g.each(xCrossers, function(ix, shape) {

                    if (!terminate && shape !== __instShape && __instShape.basicSizeIntersection(shape))
                        $g.each(__instShape.colorCoords.selectedVectors, function (iy, vectorY) {

                                var pos1 = __instShape.realPositionVector().add(vectorY);

                                if(!terminate)
                                $g.each(shape.colorCoords.selectedVectors, function (iz, vectorZ) {

                                    var pos2 = shape.realPositionVector().add(vectorZ);

                                    if (!terminate && !__instShape.touchingGround && pos1.x == pos2.x && pos1.y >= pos2.y - Settings.gridChunkSize && pos1.y < pos2.y + Settings.gridChunkSize) {

                                        __instShape.position.y = pos2.sub(__instShape.size.div(2))
                                            .sub(__instShape.__computedSize.div(2))
                                            .add(__instShape.__computedSize.sub(vectorY)).y - Settings.gridChunkSize;

                                        __instShape.touchingGround = true;

                                        __instShape.update = function () { /*do nothing*/
                                        };

                                        terminate = true;

                                    }


                                });

                            });

                });

                if(this == Game.selectedShape)
                this.borderColCollisionX();


            };


            shape.Life(30000); //only lasts x updates, then destroyed

            return shape;
        },

        start() {

            this.__bounds = Game.Bounds(200, Gamestack.HEIGHT / 2);

            this.SIZE = this.__bounds.max.sub(this.__bounds.min);


            Game.squareSelection = new Gamestack.Sprite('res/images/shape-stacker/test-square.png');


            Game.squareSelection.onLoad(function(sprite){

                Game.squareSelection.size.x = Settings.gridChunkSize;

                Game.squareSelection.size.y = Settings.gridChunkSize;

                Game.squareHighlighters = [];

                Game.destSquareHighlighters = [];

                for (var x = 0; x <= 6; x++) {

                    Game.squareHighlighters.push(new $g.Sprite(Game.squareSelection));

                    Game.destSquareHighlighters.push(new $g.Sprite(Game.squareSelection));

                    var l = Game.squareHighlighters.length;

                    gameWindow.add(Game.squareHighlighters[l - 1]);

                    gameWindow.add(Game.destSquareHighlighters[l - 1]);

                }

                var xLeft = Game.__bounds.min.x - Settings.gridChunkSize;

                xLeft = xLeft - (xLeft % Settings.gridChunkSize);


                Game.borderColumnLeft = fillColumn(xLeft);

                var xRight = Game.__bounds.max.x;

                xRight = xRight - (xRight % Settings.gridChunkSize);

                Game.borderColumnRight = fillColumn(xRight);

                var shape_index = 0;

                var timePerCheck = 200;

                window.setInterval(function () {

                    var shapeKeys = ['bar', 'square', 't', 'l', 'bolt'];

                    shape_index = Math.floor(Math.random() * shapeKeys.length);

                    if(Game.hasBegun && !Game.selectedShape.touchingGround )
                    {

                        return;
                    }

                    var x = Math.round(Math.random() * 100);

                    x = x % 2 == 0 ? Gamestack.WIDTH / 2 + x : Gamestack.WIDTH / 2 - x;

                    var shape = Game.createShape(shapeSourceSprites[shapeKeys[shape_index % shapeKeys.length]],
                        x, 100);

                    Game.hasBegun = true;

                    Game.selectedShape = shape;

                    RealTetraShapes.push(shape);

                    gameWindow.add(shape);

                    //  console.log(shape);

                    shape_index += 1;

                }, timePerCheck);



            });



        }

    };

    console.log('Gamestack is running');

    gameWindow.start();

    console.log('ran: gameWindow.start();');

    window.setTimeout(function(){

        Game.start();

    }, 5000);

    console.log('ran: Game.start();');

</script>


</body>
</html>
