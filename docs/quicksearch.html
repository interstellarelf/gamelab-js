<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/jquery.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"spritebox.js.html":{"id":"spritebox.js.html","title":"spritebox.js","body":" spritebox.js - Documentation GamestackJs Documentation ClassesCameraGameWindowgetCanvascenterGridStyleonUpdateupdateonBeforeDrawonAfterDrawSizeaddBackgroundremoveanimatestartWebGL#getCanvasWebGL#centerWebGL#GridStyleWebGL#onUpdateWebGL#updateWebGL#onBeforeDrawWebGL#onAfterDrawWebGL#SizeWebGL#addWebGL#BackgroundWebGL#removeWebGL#animateWebGL#startRectangleVectorFrameBoundsRenderableGameImageVectorsubaddmultabsdivroundfloorceilnegequalstrig_distance_xyrandomizerotationalSpeedPointangleBetweenWebGLInputEventKeyboardEventGamepadEventBoolEventOnCallFrameSoundAnimationFrame#createColorMapinit_singleFrameonRunonCompleteReverseFramesSingleFramegetCurrentPixelMapsetFramerunanimateengageSpriteonLoadCloneAddLifeinitaddInitializerget_idcreate_idgetSizeByMaxSingleFrameLifeSpanLifeisDeaddieonScreenupdatedef_updateonUpdatetravelLineOnLoophasPixelCollisionhasBoxCollisionshootsubspriteanimateonAnimationCompleteaccelYaccelXdecelYdecelXacceldecelSmoothMotionSmoothRotatecenteroverlap_xoverlap_ycollide_stop_xcollide_stopcollide_stop_toprestoreFromSpriteArray#onLoadSpritesShotProjectileonComplete spritebox.js /**@author Jordan Blake * */ /**@copyright Copyright 2018 **/ /** * Main module-object; references all Gamestack classes. * */ console.dev = function(tag, object) { var psuedoType = \"--unknown\"; switch (typeof object) { case \"string\": case \"number\": case \"boolean\": case \"null\": psuedoType = typeof object; default: { if (typeof object == 'object') psuedoType = object.constructor.name; } } if (Gamestack.DEV) console.info('gamestack::', tag, { data_type: psuedoType, object: object }); }; let delay = function(f, duration) { setTimeout(f, duration); } let repeat = function(f, duration) { setInterval(f, duration); } //Gamestack: the main module object: let Gamestack_Module = function() { var module = { settings: { DEBUG: false, gui_mode: true, recursionCount: 0, errorLimit: 20 }, errors: 0, stopDraw:false, defSize() { if (this.WIDTH == 0) { this.WIDTH = document.body.clientWidth; } if (this.HEIGHT == 0) { this.HEIGHT = document.body.clientHeight; } }, getGameWindow(ix = 0) { return this.game_windows[0] }, WIDTH: 0, HEIGHT: 0, game_windows: [], gs_renderables: [], gs_events: [], spriteTypes: [], systemSpriteTypes: ['player', 'enemy', 'background', 'interactive', 'terrain', 'weapon', 'subsprite'], __gameWindowList: [], all: function() { var all_objects = []; this.game_windows.forEach(function(item) { all_objects = all_objects.concat(item.drawables); }); console.info('Gamestack.all():', all_objects); return all_objects; }, init: function() { this.testSquare = new Gamestack.Sprite(); }, objectDestroyed(obj) { var dead = true; for (var x in this.game_windows) { let gw = this.game_windows[x]; for (var y in gw.objects) { if (gw.objects[y] === obj) dead = false; } } return dead; }, getObjectById(id) { for (var x = 0; x &lt; this.all_objects.length; x++) { if (this.all_objects[x].id == id) { return this.all_objects[x]; } } }, interlog: function(message, div) //recursive safe :: won't go crazy with recursive logs :: log message every x times this is called { this.recursionCount++; if (!isNaN(div) &amp;&amp; this.settings.recursionCount % div == 0) { // console.log('Interval Log:'+ message); } }, create_id: function() { var S4 = function() { return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1); }; return (S4() + S4() + \"-\" + S4() + \"-\" + S4() + \"-\" + S4() + \"-\" + S4() + S4() + S4()); }, error: function(quit, message) { if (quit) { throw new Error(message); } else { console.error('E!' + message); } }, info: function(m) { if (Gamestack.DEBUG) { console.info('Info:' + m); } }, log: function(m) { if (Gamestack.DEBUG) { console.log('Gamestack:' + m); } }, initializers: [], addInitializer: function(i) { this.initializers.push(i); }, Collision: { boxesCollide(pos1, size1, pos2, size2) { return pos1.x &gt;= pos2.x - size1.x &amp;&amp; pos1.x &lt;= pos2.x + size2.x &amp;&amp; pos1.y &gt;= pos2.y - size1.y &amp;&amp; pos1.y &lt;= pos2.y + size2.y; }, spriteBoxesCollide(obj1, obj2, gw) { gw = gw || Gamestack.game_windows[0]; var camPos = new Gamestack.Vector(0, 0, 0); obj1.padding = obj1.padding || new Gamestack.Vector(0, 0, 0); var paddingX = Math.round(obj1.padding.x * obj1.size.x), paddingY = Math.round(obj1.padding.y * obj1.size.y), left = obj1.position.x + paddingX + camPos.x, right = obj1.position.x + obj1.size.x - paddingX + camPos.x, top = obj1.position.y + camPos.y + paddingY, bottom = obj1.position.y + obj1.size.y - paddingY + camPos.y; if (right &gt; obj2.position.x &amp;&amp; left &lt; obj2.position.x + obj2.size.x &amp;&amp; bottom &gt; obj2.position.y &amp;&amp; top &lt; obj2.position.y + obj2.size.y) { return true; } }, spriteBoxesCollideTop(obj1, obj2, gw) { gw = gw || Gamestack.game_windows[0]; var camPos = new Gamestack.Vector(0, 0, 0); obj1.padding = obj1.padding || new Gamestack.Vector(0, 0, 0); var paddingX = Math.round(obj1.padding.x * obj1.size.x), paddingY = Math.round(obj1.padding.y * obj1.size.y), left = obj1.position.x + paddingX + camPos.x, right = obj1.position.x + obj1.size.x - paddingX + camPos.x, top = obj1.position.y + camPos.y + paddingY, bottom = obj1.position.y + obj1.size.y - paddingY + camPos.y; if (right &gt; obj2.position.x &amp;&amp; left &lt; obj2.position.x + obj2.size.x &amp;&amp; bottom &gt; obj2.position.y &amp;&amp; top &lt; obj2.position.y + obj2.size.y ) { return true; } }, /* * * ##Not known to be working --&gt;&gt; Below function * * */ pixelsCollide(sourceSprite, targetSprite, gw) { gw = gw || Gamestack.game_windows[0]; var camPos = new Gamestack.Vector(0, 0, 0); /* Box model detection, return true on collision */ function hitBox(source, target) { /* Source and target objects contain x, y and width, height */ return !( ((source.y + source.height) &lt; (target.y)) || (source.y &gt; (target.y + target.height)) || ((source.x + source.width) &lt; target.x) || (source.x &gt; (target.x + target.width)) ); } var source = { position: sourceSprite.position, pixelMap: sourceSprite.selected_animation.pixelMap }, target = { position: targetSprite.position, pixelMap: targetSprite.selected_animation.pixelMap }; // Loop through all the pixels in the source image for (var s = 0; s &lt; source.pixelMap.length; s++) { var sourcePixel = source.pixelMap[s]; // Add positioning offset var sourceArea = { x: sourcePixel.x + sourceSprite.position.x, y: sourcePixel.y + sourceSprite.position.y, width: 1, height: 1 }; var relatedPixel; // Loop through all the pixels in the target image for (var t = 0; t &lt; target.pixelMap.length; t++) { var targetPixel = target.pixelMap[t]; // Add positioning offset var targetArea = { x: targetPixel.x + targetSprite.position.x, y: targetPixel.y + targetSprite.position.y, width: 1, height: 1 }; /* Use the earlier aforementioned hitbox function */ if (hitBox(sourceArea, targetArea)) { return true; } } } } }, _gameWindow: {}, setGameWindow: function(gameWindow) { this._gameWindow = gameWindow; }, ExtendEvents: function(extendedObject, extendedKey, extendor, extendorKey) { var evtLink = new GSEventLink(extendedObject, extendedKey, extendor, extendorKey); this.all_objects.push(new GSEventLink(extendedObject, extendedKey, extendor, extendorKey)); var parent = extendedObject; // console.log(parent); if (parent) { console.log('Gamestack:EXTENDING EVENTS:' + extendedKey + \":\" + extendorKey); if (parent.onRun) //Any extendable object has an onRun ... OR { parent.onRun(extendor, extendorKey); } if (parent.onComplete) //object has an onComplete { parent.onComplete(extendor, extendorKey); } } }, removeOffscreenObjects: function(gw) { gw = gw || Gamestack.game_windows[0]; Gamestack.each(Gamestack.all_objects, function(ix, item) { if (item instanceof Gamestack.Sprite &amp;&amp; item.onScreen() == false &amp;&amp; !item.__keepAlive &amp;&amp; !item.keepAlive) { gw.remove(item); } }); }, removeDeadObjects: function(gw) { gw = gw || Gamestack.game_windows[0]; Gamestack.each(Gamestack.all_objects, function(ix, item) { if (item instanceof Gamestack.Sprite &amp;&amp; item.isDead()) { // console.log('removing:' + item.image.domElement.src); gw.remove(item); } }); }, getGameWindow: function() { return this._gameWindow; }, assignAll: function(object, args, keys) { __gamestackInstance.each(keys, function(ix, item) { object[ix] = args[ix]; }); }, each: function(list, onResult, onComplete) { for (var i in list) { onResult(i, list[i]); } if (typeof(onComplete) === 'function') { onComplete(false, list) }; }, ready_callstack: [], ready: function(callback) { this.ready_callstack.push(callback); }, reload: function() { this.callReady(); }, callReady: function() { var funx = this.ready_callstack; var gameWindow = this.game_windows[0], module = this; //call every function in the ready_callstack this.each(funx, function(ix, call) { call(module, gameWindow); }); this.InputSystem.init(); this.__running = true; }, getArg: function(args, keys, fallback) { if (typeof(keys) == 'string') { keys = [keys]; //always array } for (var x = 0; x &lt; keys.length; x++) { var k = keys[x]; if (args &amp;&amp; args.hasOwnProperty(k)) { return args[k]; //return first argument match } } return fallback; }, normalArgs: function(args) { var a = {}; function normal(str) { return str.toLowerCase().replace('-', '').replace(' ', '').replace('_', '') }; for (var x in args) { a[normal(x)] = args[x]; } return a; }, isNormalStringMatch: function(str1, str2) { return str1.toLowerCase().replace(' ', '') == str2.toLowerCase().replace(' ', ''); }, instance_type_pairs: function() { //get an array of all instance/type pairs added to the library //example : [ {constructor_name:Sprite, type:enemy_basic}, {constructor_name:Animation, type:enemy_attack} ]; var objectList = []; this.each(this.all_objects, function(ix, item) { objectList.push({ constructor_name: item.constructor.name, type: item.type }); }); return objectList; }, getById: function(id) { for (var x in this.all_objects) { if (this.all_objects[x].id == id) { return this.all_objects[x]; } } }, select: function(constructor_name, name, group /*ignoring spaces and CAPS/CASE on type match*/ ) { var query = []; var __inst = this; this.each(Gamestack.all(), function(ix, item) { if (constructor_name == '*' || item.constructor.name == constructor_name) { if (group == '*' || __inst.isNormalStringMatch(group, item.group)) { if (name == '*' || __inst.isNormalStringMatch(name, item.name)) { query.push(item); } } } }); return query; } } return module; }; let GamestackApi = { get: function() { }, post: function(object) { //TODO decycle the object before saving if (!object.id) { object.id = Gamestack.create_id(); } var name = object.name, type = object.constructor.name, contents = jstr(object), id = object.id; } }; class GSO //Gamestack-Overrideable { constructor(args = {}) { this.run_ext = args.run_ext || []; this.complete_ext = args.complete_ext || []; } /***** * Overridable / Extendable functions * -allows stacking of external object-function calls ******/ onRun(caller, callkey) { this.run_ext = this.run_ext || []; if (this.run_ext.indexOf(caller[callkey]) == -1) { this.run_ext.push({ caller: caller, callkey: callkey }); } } onComplete(caller, callkey) { this.complete_ext = this.complete_ext || []; if (this.complete_ext.indexOf(caller[callkey]) == -1) { this.complete_ext.push({ caller: caller, callkey: callkey }); } } call_on_run() { //call any function extension that is present for (var x = 0; x &lt; this.run_ext.length; x++) { this.run_ext[x].caller[this.run_ext[x].callkey](); } } call_on_complete() { //call any function extension that is present for (var x = 0; x &lt; this.complete_ext.length; x++) { this.complete_ext[x].caller[this.complete_ext[x].callkey](); } } } let Gamestack = Gamestack_Module(); Gamestack.DEV = true; if (typeof module !== 'undefined' &amp;&amp; module.exports) { //This library is being instaniated via require() aka node.js require or similar library loader module.exports = Gamestack; } else { } /*************** * TODO : fix the above duplicate references, which exist now for backward compatibility with previouslyh authored code * -apply find and replace accross the codebase * ****************/ /******** * jstr() : public function for stringifying objects and arrays (uses pretty print style) * *********/ function jstr(obj) { return JSON.stringify(obj); }; Gamestack.jstr = jstr; /********** * $Q : Selector Function * -allows string-based-selection of game-objects. * **********/ function $Q(selector) { //declare events: console.log(selector); var query = []; //handle selector / selection of objects: if (typeof selector !== 'string') { if (selector instanceof Array) { } else { } } else { if (selector &amp;&amp; selector !== '*') { var s = selector || ''; console.info('selector:' + s); var mainSelector = $Q.before('[', s).trim(), msfChar = mainSelector.substring(0, 1); var __targetClassName = \"*\"; var output = []; var cleanSelectorString = function(str) { return str.replace(\",\", \"\"); }; switch (msfChar.toLowerCase()) { case \".\": console.info('Selecting by \".\" or class'); __targetClassName = cleanSelectorString($Q.after('.', mainSelector)); console.info('Target class is:' + __targetClassName); break; case \"*\": console.info('Selecting by \"*\" or ANY object in the library instance'); __targetClassName = \"*\"; break; } var criterion = $Q.between('[', ']', s), cparts = criterion.split('='); var __targetGroup = \"*\", __targetName = \"*\"; var getParts = function() { if (cparts.length &gt;= 2) { switch (cparts[0].toLowerCase()) { case \"name\": //get all objects according to name=name console.log('Q():Detected parts in selector:' + jstr(cparts)); __targetName = cleanSelectorString(cparts[1]); break; case \"group\": console.log('Q():Detected parts in selector:' + jstr(cparts)); __targetGroup = cleanSelectorString(cparts[1]); break; } } if (cparts.length &gt;= 4) { cparts[2] = cparts[2].replace(\",\", \"\"); switch (cparts[2].toLowerCase()) { case \"name\": //get all objects according to name=name console.log('Q():Detected parts in selector:' + jstr(cparts)); __targetName = cleanSelectorString(cparts[3]); break; case \"group\": console.log('Q():Detected parts in selector:' + jstr(cparts)); __targetGroup = cleanSelectorString(cparts[3]); break; } } }; getParts(cparts); query = Gamestack.select(__targetClassName, __targetName, __targetGroup); } else if (selector == '*') { query = Gamestack.all(); } } query.each = function(callback) { var objects = []; for (var x = 0; x &lt; this.length; x++) { if (typeof x == 'number') { callback(x, this[x]); } } }; query.on = function(evt_key, selectorObject, controller_ix, callback) //handle each event such as on('collide') OR on('stick_left_0') &lt;&lt; first controller stick_left { if (typeof evt_key == 'function' &amp;&amp; typeof selectorObject == 'function') { //this is a special pattern of if(f() == true){ runFunction(); }; var boolTrigger = evt_key, boolCall = selectorObject, boolEvent = new Gamestack.BoolEvent().On(boolTrigger).Call(boolCall); } var criterion = $Q.between('[', ']', evt_key); if (criterion.indexOf('===') &gt;= 0) { criterion = criterion.replace('===', '='); } if (criterion.indexOf('==') &gt;= 0) { criterion = criterion.replace('==', '=').replace('==', 0); } var cparts = criterion.split('='); var __targetGroup = \"*\", __targetName = \"*\"; if (evt_key.indexOf('[') &gt;= 0) { evt_key = $Q.before('[', evt_key).trim(); } var padding = 0; //if controller_ix is function, and callback not present, then controller_ix is the callback aka optional argument if (controller_ix &amp;&amp; typeof controller_ix == 'function' &amp;&amp; !callback) { callback = controller_ix; controller_ix = 0; } //optional argument: if controller_ix is function, and callback not present, then callback is selectorObject if (selectorObject &amp;&amp; typeof selectorObject == 'function' &amp;&amp; !callback) { callback = selectorObject; selectorObject = $Q('*'); controller_ix = 0; }; var evt_profile = {}; //which controller? evt_profile.cix = controller_ix; //Need the control key: 'left_stick', 'button_0', etc.. evt_profile.evt_key = evt_key; if ($Q.contains_any(['stick', 'button', 'click', 'key'], evt_profile.evt_key)) { var button_mode = evt_profile.evt_key.indexOf('button') &gt;= 0; Gamestack.GamepadAdapter.on(evt_profile.evt_key, 0, function(x, y) { callback(x, y); }); console.info('detected input event key in:' + evt_profile.evt_key); console.info('TODO: rig events'); } //TODO: test collision events: else if ($Q.contains_any(['collide', 'collision', 'hit', 'touch'], evt_profile.evt_key)) { // console.info('Rigging a collision event'); // console.info('detected collision event key in:' + evt_profile.evt_key); // console.info('TODO: rig collision events'); this.each(function(ix, item1) { // console.info('Collision Processing 1:' + item1.name); // console.info('Collision Processing 1:' + item1.type); selectorObject.each(function(iy, item2) { // console.info('Collision Processing 2:' + item2.name); // console.info('Collision Processing 2:' + item2.type); if (typeof(item1.onUpdate) == 'function') { var update = function(sprite) { if (this.hasBoxCollision(item2, padding)) { callback(this, item2); }; }; item1.onUpdate(update); } }); }); } else { console.info('Rigging a property event'); //TODO: test property-watch events: console.info('detected property threshhold event key in:' + evt_profile.evt_key); console.info('TODO: rig property events'); var condition = \"_\", key = criterion || evt_profile.evt_key; if (key.indexOf('[') &gt;= 0 || key.indexOf(']') &gt;= 0) { key = $Q.between('[', ']', key); } var evt_parts = []; var run = function() { console.error('Sprite property check was not set correctly'); }; if (key.indexOf('&gt;=') &gt;= 0) { condition = \"&gt;=\"; } else if (key.indexOf('&lt;=') &gt;= 0) { condition = \"&lt;=\"; } else if (key.indexOf('&gt;') &gt;= 0) { condition = \"&gt;\"; } else if (key.indexOf('&lt;') &gt;= 0) { condition = \"&lt;\"; } else if (key.indexOf('=') &gt;= 0) { condition = \"=\"; } evt_parts = key.split(condition); for (var x = 0; x &lt; evt_parts.length; x++) { evt_parts[x] = evt_parts[x].replace('=', '').replace('=', '').trim(); //remove any trailing equals and trim() } var mykey, number; // alert(evt_parts[0]); try { mykey = evt_parts[0]; number = parseFloat(evt_parts[1]); } catch (e) { console.log(e); } console.info('Gamestack:Processing condition with:' + condition); switch (condition) { case \"&gt;=\": run = function(obj, key) { if (obj[key] &gt;= number) { callback(); } }; break; case \"&lt;=\": run = function(obj, key) { if (obj[key] &lt;= number) { callback(); } }; break; case \"&gt;\": run = function(obj, key) { if (obj[key] &gt; number) { callback(); } }; break; case \"&lt;\": run = function(obj, key) { if (obj[key] &lt; number) { callback(); } }; break; case \"=\": run = function(obj, key) { if (obj[key] == number) { callback(); } }; break; } /************ * Attach update to each member * * **************/ var keys = mykey.split('.'), propkey = \"\"; this.each(function(ix, item) { var object = {}; if (keys.length == 1) { object = item; propkey = mykey; } else if (keys.length == 2) { object = item[keys[0]]; propkey = keys[1]; } else if (keys.length == 3) { object = item[keys[0]][keys[1]]; propkey = keys[2]; } else { console.error(\":length of '.' notation out of range. We use max length of 3 or prop.prop.key.\"); } if (typeof item.onUpdate == 'function') { var spr = item; item.onUpdate(function(sprite) { run(object, propkey); }); } }); } }; return query; } $Q.each = function(obj, callback, complete) { for (var x in obj) { callback(obj); } if (typeof(complete) == 'function') { complete(obj); } }; $Q.before = function(c1, test_str) { var start_pos = 0; var end_pos = test_str.indexOf(c1, start_pos); return test_str.substring(start_pos, end_pos); }; $Q.contains = function(c1, test_str) { return test_str.indexOf(c1) &gt;= 0; }; $Q.contains_all = function(cList, test_str) { for (var x = 0; x &lt; cList.length; x++) { if (test_str.indexOf(cList[x]) &lt; 0) { return false; } } return true; }; $Q.contains_any = function(cList, test_str) { for (var x = 0; x &lt; cList.length; x++) { if (test_str.indexOf(cList[x]) &gt;= 0) { return true; } } return false; }; $Q.after = function(c1, test_str) { var start_pos = test_str.indexOf(c1) + 1; var end_pos = test_str.length; return test_str.substring(start_pos, end_pos); }; $Q.between = function(c1, c2, test_str) { var start_pos = test_str.indexOf(c1) + 1; var end_pos = test_str.indexOf(c2, start_pos); return test_str.substring(start_pos, end_pos) }; /**************************************** * Developer's own test-function: * -Q.test_selector_method(): * ***************************************/ $Q.test_selector_method = function() { //leftover method of hand-testing var Q_TestStrings = ['*', '.Sprite', '*[group=\"enemy_type_0\"]', '.Sprite[group=\"enemy_type_0\"]']; for (var x = 0; x &lt; Q_TestStrings.length; x++) { var test = Q_TestStrings[x]; console.info('testing:' + test); $Q(test); } console.log('Testing stick left'); this.on('stick_left_0'); console.log('Testing button'); this.on('button_0'); console.log('Testing collide'); this.on('collide'); console.log('Testing button'); this.on('collide'); console.log('Testing prop'); this.on('health&gt;=0'); }; Gamestack.$Q = $Q; Gamestack.query = $Q; /******************** * Gamestack.InputSystem * Various Keyboard + mouse Input Events ********************/ Gamestack.InputSystem = { //PC input events Mouse: { Position: { x: 0, y: 0 }, Speed: { x: 0, y: 0 }, setPosition(x, y) { this.Speed.x = x - this.Position.x; this.Speed.y = y - this.Position.y; this.Position.x = x; this.Position.y = y; }, isIdle: function() { return this.speed.x == 0 &amp;&amp; this.speed.y == 0; } }, events: { mousemove: [], mousepos: [], leftclick: [], rightclick: [], middleclick: [], wheelup: [], wheelDown: [] }, keymap: {}, keyReplace: function(str) { return str.toLowerCase().replace('space', ' ').replace('left', String.fromCharCode(37)).replace('left', String.fromCharCode(37)).replace('up', String.fromCharCode(38)).replace('right', String.fromCharCode(39)).replace('down', String.fromCharCode(40)); }, extendKey: function(evt_key, callback, onFinish) { evt_key = this.keyReplace(evt_key); Gamestack.InputSystem.keymap[evt_key] = { down: false, callback: function() { callback(evt_key); } }; return Gamestack.InputSystem.keymap[evt_key]; }, extend: function(evt_key, downCall, upCall, onFinish) { evt_key = evt_key.toLowerCase(); //each event-group has object-type Gamestack.InputSystem.events[evt_key] = Gamestack.InputSystem.events[evt_key] || []; Gamestack.InputSystem.events[evt_key].push({ down: downCall, up: upCall }); }, init: function() { var MOUSE = this.Mouse; window.setInterval(function() { Gamestack.each(Gamestack.InputSystem.keymap, function(im, kmapItem) { if (kmapItem.down == true) { kmapItem.callback(); } }); }, 10); document.onkeydown = document.onkeyup = function(e) { e = e || event; // to deal with IE var gs_key_string = 'key_' + String.fromCharCode(e.keyCode), evt_object = Gamestack.InputSystem['keymap'][gs_key_string] || Gamestack.InputSystem['keymap'][gs_key_string.toLowerCase()]; if (evt_object) { evt_object.down = e.type == 'keydown'; } } var canvases = document.querySelectorAll('canvas.gamewindow'); function getMousePos(e, c) { var x; var y; if (e.pageX || e.pageY) { x = e.pageX; y = e.pageY; } else { x = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft; y = e.clientY + document.body.scrollTop + document.documentElement.scrollTop; } x -= c.offsetLeft; y -= c.style.top; return { x: x, y: y }; } let InputSystem = Gamestack.InputSystem; function mouseMoving(event, c) { var pos = getMousePos(event, c); MOUSE.setPosition(pos.x, pos.y); if (InputSystem.events['mousemove']) { Gamestack.each(InputSystem.events['mousemove'], function(ix, el) { el.down(pos.x, pos.y); }); } }; //Interval for mouse-idle time : run mouse move again with same position, no difference setInterval(function() { if (InputSystem.events['mousepos']) { var pos = MOUSE.Position; Gamestack.each(InputSystem.events['mousepos'], function(ix, el) { el.down(pos.x, pos.y); }); } }, 10); for (var x = 0; x &lt; canvases.length; x++) { var c = canvases[x]; function applyMouseMove(e) { mouseMoving(e, c); } console.info('Gamestack-lib-code:main.js: InputSystem applying mousemove'); document.addEventListener(\"mousemove\", applyMouseMove); c.onmousedown = function(e) { // alert(JSON.stringify(Gamestack.InputSystem, true, 2)); var value = e.which; var pos = getMousePos(e, c); var InputSystem = Gamestack.InputSystem; e.preventDefault(); switch (e.which) { case 1: for (var x in InputSystem.events) { if (InputSystem.events[x] instanceof Array &amp;&amp; x == 'leftclick') { Gamestack.each(InputSystem.events[x], function(ix, el) { el.down(pos.x, pos.y); }); } } break; case 2: // alert('Middle Mouse button pressed.'); for (var x in Gamestack.InputSystem.events) { if (InputSystem.events[x] instanceof Array &amp;&amp; x == 'middleclick') { Gamestack.each(InputSystem.events[x], function(ix, el) { el.down(pos.x, pos.y); }); } } break; case 3: // alert('Right Mouse button pressed.'); for (var x in Gamestack.InputSystem.events) { if (InputSystem.events[x] instanceof Array &amp;&amp; x == 'rightclick') { Gamestack.each(InputSystem.events[x], function(ix, el) { el.down(pos.x, pos.y); }); return false; } } break; default: return 0; //alert('You have a strange Mouse!'); } e.preventDefault(); return 0; }; c.onmouseup = function(e) { // alert(JSON.stringify(Gamestack.InputSystem, true, 2)); var value = e.which; var pos = getMousePos(e, c); var InputSystem = Gamestack.InputSystem; e.preventDefault(); switch (e.which) { case 1: for (var x in InputSystem.events) { if (InputSystem.events[x] instanceof Array &amp;&amp; x == 'leftclick') { Gamestack.each(InputSystem.events[x], function(ix, el) { el.up(pos.x, pos.y); }); } } break; case 2: // alert('Middle Mouse button pressed.'); for (var x in Gamestack.InputSystem.events) { if (InputSystem.events[x] instanceof Array &amp;&amp; x == 'middleclick') { Gamestack.each(InputSystem.events[x], function(ix, el) { el.up(pos.x, pos.y); }); } } break; case 3: // alert('Right Mouse button pressed.'); for (var x in Gamestack.InputSystem.events) { if (InputSystem.events[x] instanceof Array &amp;&amp; x == 'rightclick') { Gamestack.each(InputSystem.events[x], function(ix, el) { el.up(pos.x, pos.y); }); return false; } } break; default: return 0; //alert('You have a strange Mouse!'); } }; } } }; //Override the existing window.onload function document.addEventListener('DOMContentLoaded', function() { Gamestack.callReady(); }); Gamestack.file_system = { localizedSource: function(src, hostUrl) { hostUrl = hostUrl || \"../\"; var gs_folder_ix = src.indexOf('assets/game'); return hostUrl + src.substring(gs_folder_ix, src.length); }, loadJSON: function(filepath, callback) { function readTextFile(file, callback) { var rawFile = new XMLHttpRequest(); rawFile.open(\"GET\", file, false); rawFile.onreadystatechange = function() { if (rawFile.readyState === 4) { if (rawFile.status === 200 || rawFile.status == 0) { var allText = rawFile.responseText; callback(JSON.stringify(allText)); } } } rawFile.send(null); }; readTextFile('file:///' + filepath, callback); }, loadLevel: function(jsonText, gw, callback) { var data = JSON.parse(jsonText); if (typeof(gw) == 'function' || !gw) { callback = gw || callback || function() {}; gw = Gamestack.game_windows[0]; } $.each(data.sprites, function(ix, xitem) { if (typeof(xitem.src) == 'string') { xitem.src = Gamestack.file_system.localizedSource(xitem.src); } __gamestackInstance.each(xitem, function(iy, yitem) { if (yitem.src) { yitem.src = Gamestack.file_system.localizedSource(yitem.src); } __gamestackInstance.each(yitem, function(iz, zitem) { if (zitem.src) { zitem.src = Gamestack.file_system.localizedSource(zitem.src); } }); }); xitem = new Gamestack.Sprite(xitem); gw.add(xitem); //sprite.image = sprite.selected_animation.image; if (ix &gt;= data.sprites.length - 1) { //last sprite is loaded //WHY DOESN't this work? callback(false, data); } }); }, loadJSONLevel: function(filepath, gw, callback) { if (typeof(gw) == 'function' || !gw) { callback = gw || callback || function() {}; gw = Gamestack.game_windows[0]; } this.loadJSON(filepath, function(data) { //localize .src up to three levels of recursion (.src must be altered to refer locally) $.each(data.sprites, function(ix, xitem) { if (typeof(xitem.src) == 'string') { xitem.src = Gamestack.file_system.localizedSource(xitem.src); } __gamestackInstance.each(xitem, function(iy, yitem) { if (yitem.src) { yitem.src = Gamestack.file_system.localizedSource(yitem.src); } __gamestackInstance.each(yitem, function(iz, zitem) { if (zitem.src) { zitem.src = Gamestack.file_system.localizedSource(zitem.src); } }); }); xitem = new Gamestack.Sprite(xitem); gw.add(xitem); //sprite.image = sprite.selected_animation.image; if (ix &gt;= data.sprites.length - 1) { //last sprite is loaded //WHY DOESN't this work? callback(false, data); } }); }); } }; Gamestack.ready(function(lib) { Gamestack.log('Gamestack: library is ready'); }); /* Screen */ let Screen = { size: function() { return new Gamestack.Vector(Gamestack.WIDTH, Gamestack.HEIGHT); }, center: function() { return new Gamestack.Vector(Gamestack.WIDTH / 2, Gamestack.HEIGHT / 2).round(); } }; ; /************************** EventInterfaceMap: StringKeys: * (must implement without option) @ (may implement optional) *****************************/ let EventInterfaceMap = { //className / must have named functions whyen carrying Symbol of className Sprite: ['@onUpdate', '@onDestroy'], Animation: ['@onRun', '@onComplete', '*onCollide'], Motion: ['@onCommit', '@onComplete', '*onCollide'], Shot: ['@onShoot', '*onCollide', '*onCollide'], Terrain: ['@onCollide'], Interactive: ['@onCollide'], Global: ['@onUpdate'], check: function(instance) { for (var x in this) { if (x == 'check') continue; else { if (this[x] instanceof Array) { this[x].forEach(function(f) { var fkey = f.replace('@', ''); if (!instance.getOwnPropertyNames.indexOf(fkey) &gt;= 0) throw new Error('Object must implement function by name of:' + fkey); }); } } }; } } /************************** ObjectFeatureInterfaceMap: Indicates classNames, and what they must carry as functions *****************************/ let ObjectFeatureMap = { //className / must have named function properties when carrying Symbol of className Sprite: ['@spatial', '@data'], Elipse:['@spatial'], Background: ['@spatial', '@data'], Animation: ['@framedriven', '@effectdriven','@posable', '@data'], Line2d:['@spatial', '@pointarrayflippable', '@selftransposable', '@data'], Text:['@spatial', '@text', '@colored'] }; Gamestack.ObjectFeatureMap = ObjectFeatureMap; let InputIFM = { GamepadButtons: ['@onButton'], GamepadSticks: ['@onStick'], Keyboard: ['@onKey'], MouseMove: ['@onMouseMove'], MouseButton: ['@onMouseButton'], MouseWheel: ['@onMouseWheel'], LeapMotion: ['@onLeapMotion'] }; let UIEditables = { Sprite: ['size', 'position', 'rotation'], Animation: ['frameBounds', 'etc'] }; let UIOption = function(name, hint, script) { return { name, hint, script } }; let UIPrefab = { MainSelect: { Interactive: { name: 'FourwayClasticRect', hint: 'Object is collideable on four rectangular sides', script: '#MY-SCRIPT-PATH' } }, FormEditables: { Interactive: [] } }; let UIPrefabMainSelect = { Background: ['Bound'] }; let getCustomPrefabMeta = function() { //get name and file/data resources for each custom prefab }; /********************************** UIObjectSelectMap: -Just the system default options *********************************/ let UIObjectPrefabs = { Sprite: ['Side-Scroll-Player', 'Collider', 'Spaceship', 'Robot'], }; ; class SymbolSlicer { constructor() { if (new.target === SymbolSlicer) { throw new TypeError(\"Cannot construct SymbolSlicer instance directly. Use a subclass instead.\"); } } on(object, symbol, callback) { var syms = Object.getOwnPropertySymbols(object); syms.forEach(function(s){ if(Symbol.keyFor(symbol) == s) callback(); }); } } ; (function(){ console.log('Camera class... creating'); /** * Creates an instance of 2d-camera to be applied as the viewing-point for a GameWindow. * @param {number} x an optional position-x * @param {number} y an optional position-y * @param {number} z an optional position-z * @returns {Camera} * */ class Camera { constructor(x, y, z) { if(isNaN(x)) { x = 0; } if(isNaN(y)) { y = 0; } if(isNaN(z)) { z = 0; } this.position = new Gamestack.Vector(x, y, z); } } Gamestack.Camera = Camera; })(); ; (function(){ console.log('Line() class... creating'); var Curves = { //ALL HAVE INPUT AND OUTPUT OF: 0-1.0 // no easing, no acceleration linearNone: function (t) { return t }, // accelerating from zero velocity easeInQuadratic: function (t) { return t*t }, // decelerating to zero velocity easeOutQuadratic: function (t) { return t*(2-t) }, // acceleration until halfway, then deceleration easeInOutQuadratic: function (t) { return t&lt;.5 ? 2*t*t : -1+(4-2*t)*t }, // accelerating from zero velocity easeInCubic: function (t) { return t*t*t }, // decelerating to zero velocity easeOutCubic: function (t) { return (--t)*t*t+1 }, // acceleration until halfway, then deceleration easeInOutCubic: function (t) { return t&lt;.5 ? 4*t*t*t : (t-1)*(2*t-2)*(2*t-2)+1 }, // accelerating from zero velocity easeInQuartic: function (t) { return t*t*t*t }, // decelerating to zero velocity easeOutQuartic: function (t) { return 1-(--t)*t*t*t }, // acceleration until halfway, then deceleration easeInOutQuartic: function (t) { return t&lt;.5 ? 8*t*t*t*t : 1-8*(--t)*t*t*t }, // accelerating from zero velocity easeInQuintic: function (t) { return t*t*t*t*t }, // decelerating to zero velocity easeOutQuintic: function (t) { return 1+(--t)*t*t*t*t }, // acceleration until halfway, then deceleration easeInOutQuintic: function (t) { return t&lt;.5 ? 16*t*t*t*t*t : 1+16*(--t)*t*t*t*t } } Gamestack.Curves = Curves; var inOutCurves = { quadratic: function (t) { return t&lt;.5 ? 2*t*t : -1+(4-2*t)*t }, cubic: function (t) { return t&lt;.5 ? 4*t*t*t : (t-1)*(2*t-2)*(2*t-2)+1 }, quartic: function (t) { return t&lt;.5 ? 8*t*t*t*t : 1-8*(--t)*t*t*t }, quintic: function (t) { return t&lt;.5 ? 16*t*t*t*t*t : 1+16*(--t)*t*t*t*t }, linear: function (t) { return t; } //provided for consistency / in case 'linear' is needed }; Gamestack.Curves.Smooth = inOutCurves; Gamestack.Curves.InOut = inOutCurves; })(); ; class Game { constructor(srcFile) { } } Gamestack.Game = Game; ; /** * Creates a GameWindow object. * * &lt;iframe style='width:400px; height:450px; overflow:hidden;' src='../client/examples/js-class/GameWindow.html'&gt; &lt;/iframe&gt; * @param {Object} canvas the canvas element for this gameWindow. --GameWindow's if not supplied, the constructor will create a full-screen canvas, if a canvas. * @param {Object} drawables the drawable objects to be drawn. --Drawables can also be added after constructor call. * @returns {GameWindow} a Gamestack.GameWindow object * */ class GameWindow { constructor(canvas = false, drawables = []) { this.drawables = drawables; this.bool_events = Gamestack.bool_events || []; this.canvas = canvas || false; if (!canvas) { console.info('GameWindow() had no {canvas:canvas} argument. Creating a new canvas in document.body...'); this.canvas = document.createElement('CANVAS'); this.canvas.setAttribute('class', 'gamewindow'); document.body.append(this.canvas); } this.context = this.canvas.getContext('2d'); document.body.style.position = \"absolute\"; document.body.style.width = \"100%\"; document.body.style.height = \"100%\"; this.camera = new Gamestack.Camera(); this.camera.target = false; Gamestack.camera = this.camera; var __inst = this; this.Size(); this.update_ext = []; window.onresize = function() { if (__inst.isAbsoluteSize) return; __inst.Size(); }; this.ctx = this.canvas.getContext('2d'); Gamestack.game_windows.push(this); window.onerror = function(){ Gamestack.errors += 1; console.log('Canvas Error --'); if (Gamestack.errors &gt; Gamestack.settings.errorLimit) { Gamestack.stopDraw = true; var call = call || window.setTimeout(function(){ if(call) { window.clearTimeout(call); } console.log('%cDraw stopped at errorLimit:' + Gamestack.settings.errorLimit, 'color:darkorange;'); }, 200); } } } /** * returns the gameWindow.canvas property, an HTMLCanvasElement * * @function * @memberof GameWindow **********/ getCanvas(){ return this.canvas; } /** * returns a vector(x, y) showing the center of the GameWindow * * @function * @memberof GameWindow **********/ center() { return new Gamestack.Vector(Math.round(this.canvas.width / 2), Math.round(this.canvas.height / 2)); } TrackStat(){ this.__trackStat = true; return this; } /** * creates an array of gridUnits * * @function * @memberof GameWindow **********/ GridStyle(total_x, total_y, w, h, srcImage_Path) { if(!(this.grid instanceof Array)) { this.grid = []; } function GridUnit(x, y, w, h, srcImage_Path){ var size = new Gamestack.Vector(w, h), position = new Gamestack.Vector(x, y); var sprite; if(srcImage_Path) { sprite = new Gamestack.Sprite(srcImage_Path); sprite.Size(size); sprite.Pos(position); Gamestack.game_windows[0].add(sprite); } return { size:size, position:position }; }; for(var y = 0; y &lt; total_y; y++) { for(var x = 0; x &lt; total_x; x++) { this.grid.push(new GridUnit(x * w, y * h, w, h, srcImage_Path)); } } return this; } getCanvas(){ return this.canvas; } /** * adds an update to the GameWindow:: update to be called every 20 milliseconds * * @function * @memberof GameWindow **********/ onUpdate(f) { this.update_ext.push(f); } /** * the main update for the GameWindow:: called automatically after call of GameWindow.start() or GameWindow.animate() * * @function * @memberof GameWindow **********/ update() { Gamestack.each(this.drawables, function(ix, item) { if (item &amp;&amp; typeof(item.def_update) == 'function') { item.def_update(item); } if (item &amp;&amp; typeof(item.update) == 'function') { item.update(item); } if (item &amp;&amp; ['SpriteArray', 'RobotixArray', 'RobotixVerticalChain'].indexOf(item.constructor.name) &gt;= 0 &amp;&amp; typeof item.each == 'function') { item.each(function(ix, graphic){ graphic.update(graphic); }); } }); Gamestack.each(this.bool_events, function(ix, item) { if (item &amp;&amp; item.bool()) { item.callback(); } }); for (var x in this.update_ext) { this.update_ext[x](); } } draw() { var __gameWindow = this; if (this.before_draw_ext) { this.before_draw_ext(); } Gamestack.each(this.drawables, function(ix, item) { if(typeof item.draw == 'function') { item.draw(__gameWindow.ctx, __gameWindow.camera); } }); if (this.after_draw_ext) { this.after_draw_ext(); } } /** * adds a call before the GameWindow draw() * * @function * @memberof GameWindow **********/ onBeforeDraw(f) { var boundCall = f.bind(this); if(!this.before_draw_ext) this.before_draw_ext = function(){}; var beforeDraw = this.before_draw_ext.bind(this); this.before_draw_ext = function() { beforeDraw(); boundCall(); }; } /** * adds a call after the GameWindow draw() * * @function * @memberof GameWindow **********/ onAfterDraw(f) { var boundCall = f.bind(this); if(!this.after_draw_ext) this.after_draw_ext = function(){}; var afterDraw = this.after_draw_ext.bind(this); this.after_draw_ext = function() { afterDraw(); boundCall(); }; } /** * sets the size of the GameWindow * * @function * @param {integer} w the width of the GameWindow * @param {integer} h the HEIGHT of the GameWindow * @memberof GameWindow **********/ Size(w, h, isAbsoluteSize) { //call with no args to fill to browser-window-size; w = w || this.canvas.parentNode.clientWidth; h = h || this.canvas.parentNode.clientHeight; var c = this.canvas; if (c) { c.setAttribute('width', w) }; if (c) { c.setAttribute('height', h) }; Gamestack.WIDTH = w; Gamestack.HEIGHT = h; this.canvas.width = w; this.canvas.height = h; this.size = new Gamestack.Vector(w, h); this.isAbsoluteSize = isAbsoluteSize || false; return this; } /** * adds an object to the GameWindow * * @function * @param {Object} obj the object to be added (Sprite) * @param {Boolean} onBottom if true, adds to the bottom of layer-stack in GameWindow * @memberof GameWindow **********/ add(obj, options={}) { var optionsGuide = { obj:'The Object{} being added into play', options:{ position:'The Vector(x, y) offset to use when drawing the obj' } }; console.info('GameWindow.add() --2nd argument options is object of arguments &gt;&gt;&gt;', optionsGuide); var layer = options.layer || this.drawables.length - 1; if(!(typeof layer == 'number' &amp;&amp; layer &gt;= 0)) layer = this.drawables.length; var offset = new Gamestack.Vector(0, 0); if(options.position) offset = options.position; obj.window_offset = offset; //1: if Sprite(), Add object to the existing __gameWindow var __inst = this; if (obj instanceof Gamestack.Camera) { this.camera = obj; } else if (obj instanceof Gamestack.GSEvent) { if (Gamestack.__running) { return console.error('Events can only be added before Gamstack.animate() is called::aka before the main update / loop begins'); } else { obj.apply(); } } else { this.drawables.splice(layer, 0, obj); }; return obj; } /** * set background-color of GameWindow * * @function * @param {string} c the new background-color for GameWindow * @memberof GameWindow **********/ Background(c) { this.canvas.style.background = c; this.canvas.style.backgroundColor = c; return this; } /** * removes an object from the GameWindow * * @function * @param {Object} obj the object to be removed (Sprite) * @memberof GameWindow **********/ remove(obj) { var ix = this.drawables.indexOf(obj); if (ix &gt;= 0) { this.drawables.splice(ix, 1); } } /** * begins the animation-loop of GameWindow. * * @function * @param {number} time optional time parameter for usage with Tween * @memberof GameWindow **********/ animate(time) { var __inst = this; requestAnimationFrame(function() { __inst.animate(); }); if (this.__stats) { this.__stats.begin(); this.__statsMS.begin(); this.__statsMB.update(); } Gamestack.isAtPlay = true; if (window.TWEEN) TWEEN.update(time); __inst.update(); this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); this.draw(); if (this.__stats) { this.__stats.end(); this.__statsMS.end(); } } /** * begins the animation-loop of GameWindow, with performance Stats shown on-screen * * @function * @memberof GameWindow **********/ start() { if (typeof(Stats) == 'function') //Stats library exists { //basic stat animation this.__stats = new Stats(); this.__stats.showPanel(0); // 0: fps, 1: ms, 2: mb, 3+: custom this.__stats.dom.style.left = '10%'; this.__stats.dom.setAttribute('class', 'stat'); this.canvas.parentNode.appendChild(this.__stats.dom); //basic stat animation this.__statsMS = new Stats(); this.__statsMS.showPanel(1); // 0: fps, 1: ms, 2: mb, 3+: custom this.__statsMS.dom.style.left = '10%'; this.__statsMS.dom.style.marginLeft = '90px'; this.__statsMS.dom.setAttribute('class', 'stat'); this.canvas.parentNode.appendChild(this.__statsMS.dom); //basic stat animation this.__statsMB = new Stats(); this.__statsMB.showPanel(2); // 0: fps, 1: ms, 2: mb, 3+: custom this.__statsMB.dom.style.left = '10%'; this.__statsMB.dom.setAttribute('class', 'stat'); this.__statsMB.dom.style.marginLeft = '180px'; this.canvas.parentNode.appendChild(this.__statsMB.dom); } this.animate(); } } Gamestack.GameWindow = GameWindow; ; console.info('Module class :: keep as public'); class Module{ constructor(uri, callback){ this.load(uri, callback); } load(uri, callback){ var __object = this; callback = callback || function(){}; callback = callback.bind(this); var script = document.createElement('SCRIPT'); script.src = uri; //define onload fxn script.onload = function(){ var construct = window.module.exports; callback(construct); }; //append to the document document.head.appendChild(script); } }; Gamestack.Module = Module; ; /** * Creates an instance of Rectangle. * @param {Gamestack.Vector} min the minimum vector point (x,y) * @param {Gamestack.Vector} max the maximum vector point (x,y) * * @returns {Rectangle} a Rectangle object */ class Rectangle { constructor(min, max) { this.min = new Gamestack.Vector(min); this.max = new Gamestack.Vector(max); } toLine() { } } ; let VectorBounds = Rectangle; Gamestack.VectorBounds =VectorBounds; Gamestack.Rectangle = Rectangle; /** * Takes the min and max vectors plus termPoint ('termination-point'), returns VectorFrameBounds * *use this to define the bounds of an Animation object. * @param {Vector} min the minimum vector point (x,y) * @param {Vector} max the maximum vector point (x,y) * @param {Vector=} termPoint the optional termination vector point (x,y) : defaults to the value of 'max' * -While a min and max Gamestack.Vector(x,y) will describe the grid-size of Animation frames, * the termPoint will indicate the last frame on-grid for this set of frames --Animation may stop early on the 'grid') * @returns {VectorFrameBounds} a VectorFrameBounds object */ class VectorFrameBounds extends Rectangle { constructor(min, max, termPoint) { super(min, max); this.termPoint = termPoint || new Gamestack.Vector(this.max.x, this.max.y, this.max.z); } } ; Gamestack.VectorFrameBounds = VectorFrameBounds; var GeoMath = { rotatePointsXY:function(x,y,angle) { var theta = angle*Math.PI/180; var point = {}; point.x = x * Math.cos(theta) - y * Math.sin(theta); point.y = x * Math.sin(theta) + y * Math.cos(theta); point.z = 0; return point } } Gamestack.GeoMath = GeoMath; ; /** * Renderable : consistent base-type for graphic-objects * @param {Object} args the object of arguments * @returns {Renderable} a Gamestack.Renderable object. * */ class Renderable { constructor(args={}) { // Gamestack.FeatureInject(this, args); } } /** * A game-image object based on HTMLImage element. Creates GameImage, attaches gameImage.domElement --an instance of HTMLImageElement * @param {string} src the sourcePath of the image-file. * @returns {GameImage} a Gamestack.GameImage object. * */ class GameImage extends Renderable { constructor(src={}, onCreate=function(){I('image: applied default arg to onCreate():');}) { super(src); if(typeof src == 'object') { return src; } console.dev('GameImage--', this); this.domElement = document.createElement('IMG'); this.domElement.src = src; this.domElement.onerror = function () { this.__error = true; console.dev('--image error'); }; } }; Gamestack.GameImage = GameImage; ; console.info('Scriptable class :: keep as public'); console.info('Script class :: keep as public'); class Script{ constructor(uri, callback){ this.src = uri || ''; if(uri &amp;&amp; callback) { this.load(uri, callback); } else{ console.info('Created Script() without uri + callback --1st and 2nd arguments. To use object call script.load()'); } } load(uri, callback){ var __object = this; callback = callback || function(){}; callback = callback.bind(this); var script = document.createElement('SCRIPT'); script.src = uri; //define onload fxn script.onload = function(){ var construct = window.module.exports; callback(construct); }; //append to the document document.head.appendChild(script); } }; Gamestack.Script = Script; class Scriptable{ constructor(object, siblings){ this.object = object; this.siblings = siblings; } Object(object) { this.object = object; return this; } load(url, callback){ var __object = this; callback = callback || function(){}; callback = callback.bind(this); var script = document.createElement('SCRIPT'); script.src = url; //define onload fxn script.onload = function(){ var construct = window.module.exports; var MOD = construct(__object.object, __object.siblings); callback.bind(__object).call(MOD, __object.object, __object.siblings); }; //append to the document document.head.appendChild(script); } }; Gamestack.Scriptable = Scriptable; ; class Elipse{ constructor(pos, size){ this.position = new Gamestack.Vector(0, 0, 0); this.size = new Gamestack.Vector(0, 0, 0); this.rotation = new Gamestack.Vector(0, 0, 0); this.Pos(pos); this.Size(size); } draw(){ var halfX = (this.size.x / 2); var halfY = (this.size.y / 2); Gamestack.Canvas.arc(this.position, new Gamestack.Vector(halfX, halfY)); } } Gamestack.Elipse = Elipse; ; var Trigonometry = { rotate_from_xy:function(cx, cy, x, y, angle) { var radians = (Math.PI / 180) * angle, cos = Math.cos(radians), sin = Math.sin(radians), nx = (cos * (x - cx)) + (sin * (y - cy)) + cx, ny = (cos * (y - cy)) - (sin * (x - cx)) + cy; return new Gamestack.Vector(nx, ny); }, find_point_on_circle:function(x, y, radius, degrees){ } }; Gamestack.Trig = Trigonometry; Gamestack.Trigonometry = Trigonometry; ; function Curve_ToComplete(tag){ var log_it = function(sub_tag){ return (function(){ console.info('Curve_ToComplete:' + tag + '.' + sub_tag); })(); }; return { In:log_it('In'), Out:log_it('Out'), Seamless:log_it('Seamless') } }; var linkedCurves = { quadratic: function(t) { return t &lt; .5 ? 2 * t * t : -1 + (4 - 2 * t) * t }, cubic: function(t) { return t &lt; .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1 }, quartic: function(t) { return t &lt; .5 ? 8 * t * t * t * t : 1 - 8 * (--t) * t * t * t }, quintic: function(t) { return t &lt; .5 ? 16 * t * t * t * t * t : 1 + 16 * (--t) * t * t * t * t }, linear: function(t) { return t; } //provided for consistency / in case 'linear' is needed }; let Twix = { Curves:{ //ALL HAVE INPUT AND OUTPUT OF: 0-1.0 // no easing, no acceleration Linear: { None: function(t) { return t; } }, Quadratic: { In: function(t) { return t * t; }, Out: function(t) { return t * (2 - t); }, Seamless: function(t) { return t &lt; .5 ? 2 * t * t : -1 + (4 - 2 * t) * t; } }, Cubic: { In: function(t) { return t * t * t; }, Out: function(t) { return (--t) * t * t + 1; }, Seamless: function(t) { return t &lt; .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1; } }, Quartic: { In: function(t) { return t * t * t * t; }, Out: function(t) { return 1 - (--t) * t * t * t; }, Seamless: function(t) { return t &lt; .5 ? 8 * t * t * t * t : 1 - 8 * (--t) * t * t * t; } }, Quintic: { In: function(t) { return t * t * t * t * t; }, Out: function(t) { return 1 + (--t) * t * t * t * t; }, Seamless: function(t) { return t &lt; .5 ? 16 * t * t * t * t * t : 1 + 16 * (--t) * t * t * t * t; } }, Sine:Curve_ToComplete('Sine'), Cosine:Curve_ToComplete('Cosine'), Tangent:Curve_ToComplete('Tangent'), Exponential:Curve_ToComplete('Exponential'), }, LinkedCurves:linkedCurves }; const TranceCurves = {}; TranceCurves.Exponential = (value, power, min, max) =&gt; { }; TranceCurves.Power = (value, power, min, max) =&gt; { }; const TrigFunctions = {}; TrigFunctions.Sine = {}; TrigFunctions.Cosine = {}; TrigFunctions.Tangent = {}; const SpecialFunctions = {}; SpecialFunctions.Sawtooth = (t) =&gt; { return t &lt;= 1.0 ? t : 0; }; SpecialFunctions.Square = () =&gt; {}; SpecialFunctions.Triangle = () =&gt; {}; SpecialFunctions.Floor = () =&gt; {}; SpecialFunctions.Sign = () =&gt; {}; Gamestack.core = Gamestack.core || {}; Gamestack.core.XYFunctions = {}; Gamestack.core.XYFunctions.SpecialFunctions = SpecialFunctions; const SigmaFunctions = {}; const GammaFunctions = {}; ;(function() { console.log('Vector class... creating'); /** * Creates a Vector object with x, y, and z properties. * &lt;info-bit&gt;Vector-2D requires only x and y args --new Vector(10, 10) * For Vector-3D, use x,y, and z --new Vector(10, 10, 10) * Pass an existing Vector as the sole argument in order to copy that Vector to a new instance&lt;/info-bit&gt; * @param {number} x the x coordinate * @param {number} y the y coordinate * @param {number} z the optional z coordinate * @param {number} r the optional r value * @returns {Vector} a Vector object */ class Vector { constructor(x, y, z, r) { var copied = false; if (typeof(x) == 'object' &amp;&amp; x.hasOwnProperty('x') &amp;&amp; x.hasOwnProperty('y')) //optionally pass vector3 { this.x = x.x; this.y = x.y; this.z = x.z || 0; if (this.z == null) { this.z = 0; } this.valid_check(); copied = true; } if (z == null) { z = 0; } if (!copied) { this.x = x; this.y = y; this.z = z; this.r = r; this.valid_check(); } } valid_check() { if (this.x == undefined) { this.x = 0; } if (this.y == undefined) { this.y = 0; } if (this.z == undefined) { this.z = 0; } } /** * Subtracts another Vector from this vector and returns a vector for the resulting difference. * * @function * @param {Vector} v the vector to be subtracted from this vector * @memberof Vector **********/ sub(v) { if (typeof(v) == 'number') { v = { x: v, y: v, z: v }; }; return new Gamestack.Vector(this.x - v.x, this.y - v.y, this.z - v.z); } /** * Adds another Vector to this vector and returns a vector for the resulting sum. * * @function * @param {Vector} v the vector to be added to this vector * @memberof Vector **********/ add(v) { if (typeof(v) == 'number') { v = { x: v, y: v, z: v }; }; return new Gamestack.Vector(this.x + v.x, this.y + v.y, this.z + v.z); } /** * Multiplies another Vector by this vector and returns a vector for the resulting product. * * @function * @param {Vector} v the vector that this vector will by muliplied by * @memberof Vector **********/ mult(v) { if (typeof(v) == 'number') { v = { x: v, y: v, z: v }; }; return new Gamestack.Vector(this.x * v.x, this.y * v.y, this.z * v.z); } /** * Gets vector of absolute values. * * @function * @param {Vector} v the absolute vector * @memberof Vector **********/ abs() { return new Gamestack.Vector(Math.abs(this.x), Math.abs(this.y), Math.abs(this.z)); } /** * Divides another Vector by this vector and returns a vector for the resulting quotient. * * @function * @param {Vector} v the vector for this vector to be divided by * @memberof Vector **********/ div(v) { if (typeof(v) == 'number') { v = { x: v, y: v, z: v }; }; return new Gamestack.Vector(this.x / v.x, this.y / v.y, this.z / v.z); } /** * Rounds this vector to the nearest set of whole numbers and returns the result. * * @function * @memberof Vector * @returns {Vector} a Gamestack.Vector object **********/ round() { return new Gamestack.Vector(Math.round(this.x), Math.round(this.y), Math.round(this.z)); } /** * Floors this vector to the nearest set of whole numbers and returns the result (subtractive-only, an x of 1.7 becomes 1) * * @function * @memberof Vector * @returns {Vector} a Gamestack.Vector object **********/ floor() { return new Gamestack.Vector(Math.floor(this.x), Math.floor(this.y), Math.floor(this.z)); } /** * Ceils this vector to the nearest set of whole numbers and returns the result (additive-only, an x of 1.2 becomes 2) * * @function * @memberof Vector * @returns {Vector} a Gamestack.Vector object **********/ ceil() { return new Gamestack.Vector(Math.ceil(this.x), Math.ceil(this.y), Math.ceil(this.z)); } /** * Creates new vector, with the negated x,y,z values (-x-y-z), returns the resulting vector * * @function * @memberof Vector * @returns {Vector} a Gamestack.Vector object **********/ neg() { return new Gamestack.Vector(-this.x, -this.y, -this.z); } /** * An equals-test for vectors. Returns true OR false. * * @function * @memberof Vector * @returns {boolean} a true OR false value **********/ equals(v) { return this.x == v.x &amp;&amp; this.y == v.y &amp;&amp; this.z == v.z; } /** * Gets the specific distance between this and the argument-vector. --applies to x and y of two vectors. Returns a single number. * * @function * @memberof Vector * @returns {number} the specific distance between this and the argument-vector **********/ trig_distance_xy(v) { var dist = this.sub(v); return Math.sqrt(dist.x * dist.x + dist.y * dist.y); } is_between(v1, v2) { //TODO : overlap vectors return boolean return this.x &gt;= v1.x &amp;&amp; this.x &lt;= v2.x &amp;&amp; this.y &gt;= v1.y &amp;&amp; this.y &lt;= v2.y &amp;&amp; this.z &gt;= v1.z &amp;&amp; this.z &lt;= v2.z; } /** * Returns a vector-multiple: the original-size, multiplied by a random between the minFloat and maxFloat arguments. * * @function * @memberof Vector * @returns {Vector} the resulting vector. **********/ randomize(minFloat, maxFloat) { var random = (Math.random() * (maxFloat - minFloat) + minFloat) * 1000 / 1000; return this.mult(random); } /** * Returns a speed vector, based on rotation. * * @function * @param {number} rotation in degrees, 0-360 * @param {number} speed the level of speed to apply, default being 1 * @returns {Vector} * @memberof Vector **********/ rotationalSpeedPoint(rotation, speed) { var r = rotation; if (isNaN(speed)) { speed = 1; } if (typeof(rotation) == 'object' &amp;&amp; rotation.x) { r = rotation.x; } return new Gamestack.Vector(Math.cos((r) * 3.14 / 180) * speed, Math.sin((r) * 3.14 / 180) * speed); } /** * Returns the right-handed angle of degrees between two two position-vectors. * @memberof Vector * @function * @param {Vector} p1 the 1st vector-argument * @param {Vector} p2 the 2nd vector-argument * @returns {number} the resulting angle in degrees. **********/ angleBetween(p1, p2) { return Math.atan2(p2.y - p1.y, p2.x - p1.x) * 180 / Math.PI; } //apply minimum value to all values min2d() { function minimize(object, key1, key2) { if (object[key1] &lt; object[key2]) object[key2] = object[key1]; if (object[key2] &lt; object[key1]) object[key1] = object[key2]; }; minimize(this, 'x', 'y'); return this; } //apply maximum value to all values max2d() { function maximize(object, key1, key2) { if (object[key1] &gt; object[key2]) object[key2] = object[key1]; if (object[key2] &gt; object[key1]) object[key1] = object[key2]; }; maximize(this, 'x', 'y'); return this; } }; let Vector3 = Vector, Pos = Vector, Size = Vector, Position = Vector, Vector2 = Vector, Rotation = Vector; Gamestack.Vector = Vector; //synonymous w/ Vector:: Gamestack.Vector2d = Vector; Gamestack.Vector2D = Vector; Gamestack.Rotation = Vector; Gamestack.Pos = Vector; Gamestack.Position = Vector; Gamestack.Size = Vector; //The above are a list of synonymous expressions for Vector. All of these do the same thing in this library (store and manipulate x,y,z values) var VectorMath = { rotatePointsXY(x, y, angle) { var theta = angle * Math.PI / 180; var point = {}; point.x = x * Math.cos(theta) - y * Math.sin(theta); point.y = x * Math.sin(theta) + y * Math.cos(theta); point.z = 0; return point } } Gamestack.VectorMath = VectorMath; })(); ; /** * Creates a GameWindow object. * * &lt;iframe style='width:400px; height:450px; overflow:hidden;' src='../client/examples/js-class/GameWindow.html'&gt; &lt;/iframe&gt; * @param {Object} canvas the canvas element for this gameWindow. --GameWindow's if not supplied, the constructor will create a full-screen canvas, if a canvas. * @param {Object} drawables the drawable objects to be drawn. --Drawables can also be added after constructor call. * @returns {GameWindow} a Gamestack.GameWindow object * */ class WebGL { constructor(canvas = false, drawables = []) { if(!THREE) { return console.error('THREE.js required in window'); } document.body.style.position = \"absolute\"; document.body.style.width = \"100%\"; document.body.style.height = \"100%\"; var camera = new THREE.PerspectiveCamera(); var container = document.querySelector('#game-window'); this.renderer = new THREE.WebGLRenderer(); this.renderer.setSize( container.clientWidth, container.clientHeight ); this.scene = new THREE.Scene(); this.camera = new THREE.PerspectiveCamera( 75, container.clientWidth / container.clientHeight, 0.1, 1000 ); //was 1000 last arg container.append( this.renderer.domElement ); this.scene.add(this.camera); this.light = new THREE.AmbientLight( 0x404040 ); // soft white light this.scene.add( this.light ); this.drawables = drawables; this.bool_events = Gamestack.bool_events || []; this.canvas = this.renderer.domElement; this.camera.target = false; var __inst = this; this.update_ext = []; Gamestack.game_windows.push(this); window.onerror = function(){ Gamestack.errors += 1; console.log('Canvas Error --'); if (Gamestack.errors &gt; Gamestack.settings.errorLimit) { Gamestack.stopDraw = true; var call = call || window.setTimeout(function(){ if(call) { window.clearTimeout(call); } console.log('%cDraw stopped at errorLimit:' + Gamestack.settings.errorLimit, 'color:darkorange;'); }, 200); } } } /** * returns the gameWindow.canvas property, an HTMLCanvasElement * * @function * @memberof GameWindow **********/ getCanvas(){ return this.canvas; } /** * returns a vector(x, y) showing the center of the GameWindow * * @function * @memberof GameWindow **********/ center() { return new Gamestack.Vector(Math.round(this.canvas.width / 2), Math.round(this.canvas.height / 2)); } /** * creates an array of gridUnits * * @function * @memberof GameWindow **********/ GridStyle(total_x, total_y, w, h, srcImage_Path) { if(!(this.grid instanceof Array)) { this.grid = []; } function GridUnit(x, y, w, h, srcImage_Path){ var size = new Gamestack.Vector(w, h), position = new Gamestack.Vector(x, y); var sprite; if(srcImage_Path) { sprite = new Gamestack.Sprite(srcImage_Path); sprite.Size(size); sprite.Pos(position); Gamestack.game_windows[0].add(sprite); } return { size:size, position:position }; }; for(var y = 0; y &lt; total_y; y++) { for(var x = 0; x &lt; total_x; x++) { this.grid.push(new GridUnit(x * w, y * h, w, h, srcImage_Path)); } } return this; } getCanvas(){ return this.canvas; } /** * adds an update to the GameWindow:: update to be called every 20 milliseconds * * @function * @memberof GameWindow **********/ onUpdate(f) { this.update_ext.push(f); } /** * the main update for the GameWindow:: called automatically after call of GameWindow.start() or GameWindow.animate() * * @function * @memberof GameWindow **********/ update() { Gamestack.each(this.drawables, function(ix, item) { if (item &amp;&amp; typeof(item.def_update) == 'function') { item.def_update(item); } if (item &amp;&amp; typeof(item.update) == 'function') { item.update(item); } if (item &amp;&amp; ['SpriteArray', 'RobotixArray', 'RobotixVerticalChain'].indexOf(item.constructor.name) &gt;= 0 &amp;&amp; typeof item.each == 'function') { item.each(function(ix, graphic){ graphic.update(graphic); }); } }); Gamestack.each(this.bool_events, function(ix, item) { if (item &amp;&amp; item.bool()) { item.callback(); } }); for (var x in this.update_ext) { this.update_ext[x](); } } draw() { var __gameWindow = this; if (this.before_draw_ext) { this.before_draw_ext(); } Gamestack.each(this.drawables, function(ix, item) { if(typeof item.draw == 'function') { item.draw(__gameWindow.ctx, __gameWindow.camera); } }); if (this.after_draw_ext) { this.after_draw_ext(); } } /** * adds a call before the GameWindow draw() * * @function * @memberof GameWindow **********/ onBeforeDraw(f) { var boundCall = f.bind(this); if(!this.before_draw_ext) this.before_draw_ext = function(){}; var beforeDraw = this.before_draw_ext.bind(this); this.before_draw_ext = function() { beforeDraw(); boundCall(); }; } /** * adds a call after the GameWindow draw() * * @function * @memberof GameWindow **********/ onAfterDraw(f) { var boundCall = f.bind(this); if(!this.after_draw_ext) this.after_draw_ext = function(){}; var afterDraw = this.after_draw_ext.bind(this); this.after_draw_ext = function() { afterDraw(); boundCall(); }; } /** * sets the size of the GameWindow * * @function * @param {integer} w the width of the GameWindow * @param {integer} h the HEIGHT of the GameWindow * @memberof GameWindow **********/ Size(w, h, isAbsoluteSize) { //call with no args to fill to browser-window-size; w = w || this.canvas.parentNode.clientWidth; h = h || this.canvas.parentNode.clientHeight; var c = this.canvas; if (c) { c.setAttribute('width', w) }; if (c) { c.setAttribute('height', h) }; Gamestack.WIDTH = w; Gamestack.HEIGHT = h; this.canvas.width = w; this.canvas.height = h; this.size = new Gamestack.Vector(w, h); this.isAbsoluteSize = isAbsoluteSize || false; return this; } /** * adds an object to the GameWindow * * @function * @param {Object} obj the object to be added (Sprite) * @param {Boolean} onBottom if true, adds to the bottom of layer-stack in GameWindow * @memberof GameWindow **********/ add(obj, options={}) { var optionsGuide = { obj:'The Object{} being added into play', options:{ position:'The Vector(x, y) offset to use when drawing the obj' } }; console.info('GameWindow.add() --2nd argument options is object of arguments &gt;&gt;&gt;', optionsGuide); var layer = options.layer || this.drawables.length - 1; if(!(typeof layer == 'number' &amp;&amp; layer &gt;= 0)) layer = this.drawables.length; var offset = new Gamestack.Vector(0, 0); if(options.position) offset = options.position; obj.window_offset = offset; //1: if Sprite(), Add object to the existing __gameWindow var __inst = this; if (obj instanceof Gamestack.Camera) { this.camera = obj; } else if (obj instanceof Gamestack.GSEvent) { if (Gamestack.__running) { return console.error('Events can only be added before Gamstack.animate() is called::aka before the main update / loop begins'); } else { obj.apply(); } } else { this.drawables.splice(layer, 0, obj); }; return obj; } /** * set background-color of GameWindow * * @function * @param {string} c the new background-color for GameWindow * @memberof GameWindow **********/ Background(c) { this.canvas.style.background = c; this.canvas.style.backgroundColor = c; return this; } /** * removes an object from the GameWindow * * @function * @param {Object} obj the object to be removed (Sprite) * @memberof GameWindow **********/ remove(obj) { var ix = this.drawables.indexOf(obj); if (ix &gt;= 0) { this.drawables.splice(ix, 1); } } /** * begins the animation-loop of GameWindow. * * @function * @param {number} time optional time parameter for usage with Tween * @memberof GameWindow **********/ animate(time) { var __inst = this; requestAnimationFrame(function() { __inst.animate(); }); if (Gamestack.__stats) { Gamestack.__stats.begin(); Gamestack.__statsMS.begin(); Gamestack.__statsMB.update(); } Gamestack.isAtPlay = true; if (window.TWEEN) TWEEN.update(time); __inst.update(); console.log('Rendering'); this.renderer.render(this.scene, this.camera); this.draw(); if (Gamestack.__stats) { Gamestack.__stats.end(); Gamestack.__statsMS.end(); } } /** * begins the animation-loop of GameWindow, with performance Stats shown on-screen * * @function * @memberof GameWindow **********/ start() { if (typeof(Stats) == 'function') //Stats library exists { //basic stat animation Gamestack.__stats = new Stats(); Gamestack.__stats.showPanel(0); // 0: fps, 1: ms, 2: mb, 3+: custom Gamestack.__stats.dom.style.left = '10%'; Gamestack.__stats.dom.setAttribute('class', 'stat'); this.canvas.parentNode.appendChild(Gamestack.__stats.dom); //basic stat animation Gamestack.__statsMS = new Stats(); Gamestack.__statsMS.showPanel(1); // 0: fps, 1: ms, 2: mb, 3+: custom Gamestack.__statsMS.dom.style.left = '10%'; Gamestack.__statsMS.dom.style.marginLeft = '90px'; Gamestack.__statsMS.dom.setAttribute('class', 'stat'); this.canvas.parentNode.appendChild(Gamestack.__statsMS.dom); //basic stat animation Gamestack.__statsMB = new Stats(); Gamestack.__statsMB.showPanel(2); // 0: fps, 1: ms, 2: mb, 3+: custom Gamestack.__statsMB.dom.style.left = '10%'; Gamestack.__statsMB.dom.setAttribute('class', 'stat'); Gamestack.__statsMB.dom.style.marginLeft = '180px'; this.canvas.parentNode.appendChild(Gamestack.__statsMB.dom); } this.animate(); } } Gamestack.WebGL = WebGL; Gamestack.WebGl = WebGL; ;class RGBAColor { constructor(r=0, g=0, b=0, a=0) { this.r = r; this.g = g; this.b = b; this.a = a; } fromString(str){ str = str.replace(/^\\s*#|\\s*$/g, ''); str = str.toLowerCase(); if (ColorStrings[str]) str = ColorStrings[str]; var match; // RGB(A) if ((match = str.match(RE_RGB) || str.match(RE_RGBA))) { console.log('Processing Match::' + jstr(match)); return new Gamestack.RGBAColor( parseInt(match[1], 10), parseInt(match[2], 10), parseInt(match[3], 10), parseFloat(match.length === 4 ? 1 : match[4]) ); } } fromData(data) { return new Gamestack.RGBAColor( parseInt(data[0], 10), parseInt(data[1], 10), parseInt(data[2], 10), parseFloat(data.length === 3 ? 1 : data[3]) ); } distance(color){ var sumOfSquares = 0; sumOfSquares += Math.pow(this.r - color.r, 2); sumOfSquares += Math.pow(this.g - color.g, 2); sumOfSquares += Math.pow(this.b - color.b, 2); return Math.sqrt(sumOfSquares); } match_by_tolerance(color, tolerance) { var matches = { r:color.r, g:color.g, b:color.b }; var total_diff = 0; for(var x in matches) { var diff = Math.abs(color[x] - this[x]); console.log('COLOR-DIFF: --1::' + jstr(this) + ':: --2::' + jstr(color)); total_diff += diff; } return total_diff &lt;= tolerance; } }; Gamestack.RGBAColor = RGBAColor; var ColorStrings = { aliceblue: 'rgb(240, 248, 255)', antiquewhite: 'rgb(250, 235, 215)', aqua: 'rgb(0, 255, 255)', aquamarine: 'rgb(127, 255, 212)', azure: 'rgb(240, 255, 255)', beige: 'rgb(245, 245, 220)', bisque: 'rgb(255, 228, 196)', black: 'rgb(0, 0, 0)', blanchedalmond: 'rgb(255, 235, 205)', blue: 'rgb(0, 0, 255)', blueviolet: 'rgb(138, 43, 226)', brown: 'rgb(165, 42, 42)', burlywood: 'rgb(222, 184, 135)', cadetblue: 'rgb(95, 158, 160)', chartreuse: 'rgb(127, 255, 0)', chocolate: 'rgb(210, 105, 30)', coral: 'rgb(255, 127, 80)', cornflowerblue: 'rgb(100, 149, 237)', cornsilk: 'rgb(255, 248, 220)', crimson: 'rgb(220, 20, 60)', cyan: 'rgb(0, 255, 255)', darkblue: 'rgb(0, 0, 139)', darkcyan: 'rgb(0, 139, 139)', darkgoldenrod: 'rgb(184, 134, 11)', darkgray: 'rgb(169, 169, 169)', darkgreen: 'rgb(0, 100, 0)', darkgrey: 'rgb(169, 169, 169)', darkkhaki: 'rgb(189, 183, 107)', darkmagenta: 'rgb(139, 0, 139)', darkolivegreen: 'rgb(85, 107, 47)', darkorange: 'rgb(255, 140, 0)', darkorchid: 'rgb(153, 50, 204)', darkred: 'rgb(139, 0, 0)', darksalmon: 'rgb(233, 150, 122)', darkseagreen: 'rgb(143, 188, 143)', darkslateblue: 'rgb(72, 61, 139)', darkslategray: 'rgb(47, 79, 79)', darkslategrey: 'rgb(47, 79, 79)', darkturquoise: 'rgb(0, 206, 209)', darkviolet: 'rgb(148, 0, 211)', deeppink: 'rgb(255, 20, 147)', deepskyblue: 'rgb(0, 191, 255)', dimgray: 'rgb(105, 105, 105)', dimgrey: 'rgb(105, 105, 105)', dodgerblue: 'rgb(30, 144, 255)', firebrick: 'rgb(178, 34, 34)', floralwhite: 'rgb(255, 250, 240)', forestgreen: 'rgb(34, 139, 34)', fuchsia: 'rgb(255, 0, 255)', gainsboro: 'rgb(220, 220, 220)', ghostwhite: 'rgb(248, 248, 255)', gold: 'rgb(255, 215, 0)', goldenrod: 'rgb(218, 165, 32)', gray: 'rgb(128, 128, 128)', green: 'rgb(0, 128, 0)', greenyellow: 'rgb(173, 255, 47)', grey: 'rgb(128, 128, 128)', honeydew: 'rgb(240, 255, 240)', hotpink: 'rgb(255, 105, 180)', indianred: 'rgb(205, 92, 92)', indigo: 'rgb(75, 0, 130)', ivory: 'rgb(255, 255, 240)', khaki: 'rgb(240, 230, 140)', lavender: 'rgb(230, 230, 250)', lavenderblush: 'rgb(255, 240, 245)', lawngreen: 'rgb(124, 252, 0)', lemonchiffon: 'rgb(255, 250, 205)', lightblue: 'rgb(173, 216, 230)', lightcoral: 'rgb(240, 128, 128)', lightcyan: 'rgb(224, 255, 255)', lightgoldenrodyellow: 'rgb(250, 250, 210)', lightgray: 'rgb(211, 211, 211)', lightgreen: 'rgb(144, 238, 144)', lightgrey: 'rgb(211, 211, 211)', lightpink: 'rgb(255, 182, 193)', lightsalmon: 'rgb(255, 160, 122)', lightseagreen: 'rgb(32, 178, 170)', lightskyblue: 'rgb(135, 206, 250)', lightslategray: 'rgb(119, 136, 153)', lightslategrey: 'rgb(119, 136, 153)', lightsteelblue: 'rgb(176, 196, 222)', lightyellow: 'rgb(255, 255, 224)', lime: 'rgb(0, 255, 0)', limegreen: 'rgb(50, 205, 50)', linen: 'rgb(250, 240, 230)', magenta: 'rgb(255, 0, 255)', maroon: 'rgb(128, 0, 0)', mediumaquamarine: 'rgb(102, 205, 170)', mediumblue: 'rgb(0, 0, 205)', mediumorchid: 'rgb(186, 85, 211)', mediumpurple: 'rgb(147, 112, 219)', mediumseagreen: 'rgb(60, 179, 113)', mediumslateblue: 'rgb(123, 104, 238)', mediumspringgreen: 'rgb(0, 250, 154)', mediumturquoise: 'rgb(72, 209, 204)', mediumvioletred: 'rgb(199, 21, 133)', midnightblue: 'rgb(25, 25, 112)', mintcream: 'rgb(245, 255, 250)', mistyrose: 'rgb(255, 228, 225)', moccasin: 'rgb(255, 228, 181)', navajowhite: 'rgb(255, 222, 173)', navy: 'rgb(0, 0, 128)', oldlace: 'rgb(253, 245, 230)', olive: 'rgb(128, 128, 0)', olivedrab: 'rgb(107, 142, 35)', orange: 'rgb(255, 165, 0)', orangered: 'rgb(255, 69, 0)', orchid: 'rgb(218, 112, 214)', palegoldenrod: 'rgb(238, 232, 170)', palegreen: 'rgb(152, 251, 152)', paleturquoise: 'rgb(175, 238, 238)', palevioletred: 'rgb(219, 112, 147)', papayawhip: 'rgb(255, 239, 213)', peachpuff: 'rgb(255, 218, 185)', peru: 'rgb(205, 133, 63)', pink: 'rgb(255, 192, 203)', plum: 'rgb(221, 160, 221)', powderblue: 'rgb(176, 224, 230)', purple: 'rgb(128, 0, 128)', red: 'rgb(255, 0, 0)', rosybrown: 'rgb(188, 143, 143)', royalblue: 'rgb(65, 105, 225)', saddlebrown: 'rgb(139, 69, 19)', salmon: 'rgb(250, 128, 114)', sandybrown: 'rgb(244, 164, 96)', seagreen: 'rgb(46, 139, 87)', seashell: 'rgb(255, 245, 238)', sienna: 'rgb(160, 82, 45)', silver: 'rgb(192, 192, 192)', skyblue: 'rgb(135, 206, 235)', slateblue: 'rgb(106, 90, 205)', slategray: 'rgb(112, 128, 144)', slategrey: 'rgb(112, 128, 144)', snow: 'rgb(255, 250, 250)', springgreen: 'rgb(0, 255, 127)', steelblue: 'rgb(70, 130, 180)', tan: 'rgb(210, 180, 140)', teal: 'rgb(0, 128, 128)', thistle: 'rgb(216, 191, 216)', tomato: 'rgb(255, 99, 71)', turquoise: 'rgb(64, 224, 208)', violet: 'rgb(238, 130, 238)', wheat: 'rgb(245, 222, 179)', white: 'rgb(255, 255, 255)', whitesmoke: 'rgb(245, 245, 245)', yellow: 'rgb(255, 255, 0)', yellowgreen: 'rgb(154, 205, 50)', map_orange: 'rgb(255, 106, 0)', map_green: 'rgb(76, 255, 0)', map_red: 'rgb(255, 0, 0)', map_blue: 'rgb(0, 38, 255)', map_darkgreen: 'rgb(38, 127, 0)', map_yellow: 'rgb(255, 216, 0)', map_aqua: 'rgb(0, 255, 255)', map_grey: 'rgb(128, 128, 128)', map_gray: 'rgb(128, 128, 128)', map_darkgrey: 'rgb(64, 64, 64)', map_darkgray: 'rgb(64, 64, 64)', map_black: 'rgb(0, 0, 0)', }; var RE_RGB = /^rgb\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)$/; Gamestack.Colors = {}; Gamestack.PixelMapColors = {}; for(var x in ColorStrings) { if(ColorStrings.hasOwnProperty(x)) { Gamestack.Colors[x] = new Gamestack.RGBAColor().fromString(x); } } ;(function() { console.log('GSEvent class... creating'); class GSEvent { constructor(args = {}) { // Gamestack.Modifiers.informable(this, args); } } class MouseMoveEvent { constructor(callback) { callback = callback || function(x, y) {}; this.Callback(callback); } Callback(cb) { Gamestack.InputSystem.extend('mousemove', function(x, y) { cb(x, y); }); } }; Gamestack.MouseMoveEvent = MouseMoveEvent; class MousePosEvent { constructor(callback) { callback = callback || function(x, y) {}; this.Callback(callback); } Callback(cb) { Gamestack.InputSystem.extend('mousepos', function(x, y) { cb(x, y); }); } }; Gamestack.MousePosEvent = MousePosEvent; class MouseLeftClickEvent { constructor(callback) { callback = callback || function(x, y) {}; this.Callback(callback); } Callback(cb) { Gamestack.InputSystem.extend('leftclick', function(x, y) { cb(x, y); }); } }; Gamestack.MouseLeftClickEvent = MouseLeftClickEvent; class MouseRightClickEvent { constructor(callback) { callback = callback || function(x, y) {}; this.Callback(callback); } Callback(cb) { Gamestack.InputSystem.extend('rightclick', function(x, y) { cb(x, y); }); } }; Gamestack.MouseRightClickEvent = MouseRightClickEvent; function GSEventLink(extendedObject, extendedKey, extendor, extendorKey) { this.parent_id = extendedObject.id, this.child_id = extendor.id, this.parent_key = extendedKey, this.child_key = extendorKey; }; /** * Creates an instance of InputEvent * &lt;info-bit&gt; Gamestack.InputEvent runs a callback function when a specified input is triggered&lt;/info-bit&gt; * * &lt;tip is=\"p\"&gt;Instead of calling * * @param {Object} args object of arguments * @param {number} args.btnix the index of controller-button to be applied * @param {number} args.gpix the index of pc-gamepad --the 1st gamepad will have index 0 * @param {number} args.stickix the controller-stick-index to be applied * @param {Array} args.keys array of strings for keys to be applied * @param {Function} args.callback the function to call when InputEvent is triggered * @returns {Gamestack.InputEvent} a Gamestack.InputEvent object */ class InputEvent extends GSEvent { constructor(args) { super(args); var btnix = args.btnix || args.button_ix || false, gpix = args.gpix || args.gamepad_ix || 0, callback = args.callback || function() { }; var six = args.stickix || args.six || args.stick_ix || false; var inputKey = six !== false ? 'stick_' + six : btnix !== false ? 'button_' + btnix : false; //Keys: var keyboardKeys = Larva.arrayWrap(args.keys || []); //Run the Q() function if (keyboardKeys instanceof Array) { Gamestack.each(keyboardKeys, function(ix, keyitem) { Gamestack.InputSystem.extendKey('key_' + keyitem.toLowerCase(), function() { callback(keyitem.toLowerCase()); }); }); } if (inputKey &amp;&amp; gpix &gt;= 0) { Gamestack.GamepadAdapter.on(inputKey, gpix, function(x, y) { callback(x, y); }); } } }; /** * * @extends InputEvent * * Creates an instance of KeyboardEvent * &lt;info-bit&gt; Gamestack.KeyboardEvent runs a callback function when keyboard-keys are pressed&lt;/info-bit&gt; * @param {Array | string} keys the Array of keys or single string-key for this event * @param {Function} callback the callback-function to be called when this event is triggered * @returns {Gamestack.KeyboardEvent} */ class KeyboardEvent extends InputEvent { constructor(keys = keys instanceof Array ? keys : [keys], callback = function() {}) { super({}); this.keys = keys; this.callback = callback; } init() { var keyboardKeys = this.keys; var __inst = this; if (keyboardKeys instanceof Array) { Gamestack.each(keyboardKeys, function(ix, keyitem) { Gamestack.InputSystem.extendKey('key_' + keyitem.toLowerCase(), function() { __inst.callback(keyitem.toLowerCase()); }); }); } } Keys(keys = []) { this.keys = Larva.arrayWrap(keys) return this; } Call(callback = function() {}) { this.callback = callback; this.init(); return this; } }; /** * * @extends InputEvent * * Creates an instance of GamepadEvent * &lt;info-bit&gt; Gamestack.GamepadEvent runs a callback function when any specified gamepad-buttons or gamepad-sticks are pressed&lt;/info-bit&gt; * @param {Array | string} gamepadKeys the Array of gamepadKeys or single string-key, representing gamepad-buttons or gamepad-sticks for this event * @param {Function} callback the callback-function to be called when this event is triggered * @returns {Gamestack.GamepadEvent} */ class GamepadEvent extends InputEvent { constructor(keys = [], callback = function() {}) { super({}); this.keys = keys; this.callback = callback; } Gamepads(gps = []) { this.gps = gps = Larva.arrayWrap(gps || []); return this; } init() { var gamepadKeys = Larva.arrayWrap(this.keys || []); var __inst = this; Gamestack.GamepadAdapter.on(gamepadKeys, this.gps, function(x, y) { __inst.callback(x, y); }); } Keys(keys = []) { this.keys = Larva.arrayWrap(keys); return this; } Call(callback = function() {}) { this.callback = callback; this.init(); return this; } }; class CollisionEvent extends GSEvent { constructor(args = {}) { super(args); } /** * applies objects and siblings to be compared for the CollisionEvent instance * @memberof CollisionEvent * @param {Array} objects the main-objects for collision processing * @param {Array} siblings the comparable-objects for collision processing * @returns {CollisionEvent} the current instance of CollisionEvent, reference to 'this' keyword */ OnCollision(objects, siblings) { this.objects = Larva.arrayWrap(objects || this.objects || []); this.siblings = Larva.arrayWrap(siblings || this.siblings || []); return this; } /** * applies a callback to be called whenever the onBool function returns true * @memberof CollisionEvent * @param {callbackFunction} callbackFunction the function to be called --replaces the value of collisionEvent.callback * @returns {CollisionEvent} the current instance of CollisionEvent, reference to 'this' keyword */ Call(callbackFunction) { this.callback = callbackFunction || this.callback || function() {}; let __inst = this; $Q(this.objects).on('collide', $Q(this.siblings), function(obj1, obj2) { __inst.callback(obj1, obj2); }); return this; } }; /** * returns BoolEvent --allows code to run whenever a conditional-function returns true * @param {onBool} onBool the function to be tested each update * @param {call} call the function to be called when onBool returns true; * @returns {BoolEvent} a Gamestack.BoolEvent object */ class BoolEvent extends GSEvent { constructor(onBool, callback) { super({}); this.bool = onBool || function() { console.info('CustomBoolEvent():needs .on function(){}. --Add this as 1st argument or via chainable On() function returning bool argument'); } /*Defaults to false to avoid broken code*/ this.callback = callback || function() { console.info('CustomBoolEvent():needs .callback function(){} --Add this as 2nd argument or via chainable Call() function'); }; Gamestack.gs_events.push(this); } /** * applies a boolFunction to be tested for true each update * @param {boolFunction} boolFunction the function to be tested each update --replaces the value of boolEvent.onBool * @returns {BoolEvent} the current instance of BoolEvent, reference to 'this' keyword */ On(boolFunction) { this.bool = boolFunction; return this; } /** * applies a callback to be called whenever the onBool function returns true * @memberof BoolEvent * @param {callbackFunction} callbackFunction the function to be called --replaces the value of boolEvent.callback * @returns {BoolEvent} the current instance of BoolEvent, reference to 'this' keyword */ Call(callbackFunction) { this.callback = callbackFunction || this.callback || function() {}; return this; } }; BoolEvent.Bool = BoolEvent.On; Gamestack.GSEvent = GSEvent; Gamestack.GSEventLink = GSEventLink; Gamestack.InputEvent = InputEvent; Gamestack.GamepadEvent = GamepadEvent; Gamestack.KeyboardEvent = KeyboardEvent; Gamestack.CollisionEvent = CollisionEvent; Gamestack.BoxCollisionEvent = CollisionEvent; Gamestack.BoolEvent = BoolEvent; })(); ;(function () { console.log('Frame class... creating'); /** * Creates an instance of Frame * * &lt;info-bit&gt;Gamestack.Frame is called automatically by Gamestack.Sprite and Gamestack.Animation. * Gamestack.Frame does not take arguments. * It is instantiated, then initilized with chainable function-calls.&lt;/info-bit&gt; * * @returns {Frame} * * @example * * var selected_frame = new Gamestack.Frame().Image(gameImage).Size(frameSizeVector); */ class Frame { constructor() { var __inst = this; this.framePos = new Gamestack.Vector(0, 0); } Image(src) { this.image = new Gamestack.GameImage(src); return this; } onLoad(fxn){ fxn = fxn || function(){}; fxn = fxn.bind(this); this.image.domElement.onload = function(){ fxn(); }; } Size(s) { this.size = new Gamestack.Vector(s, s, s); this.frameSize = new Gamestack.Vector(s, s, s); return this; } Position(p) { this.position = new Gamestack.Vector(p, p, p); this.framePos = new Gamestack.Vector(p, p, p); return this; } FramePos(p) { this.position = new Gamestack.Vector(p, p, p); this.framePos = new Gamestack.Vector(p, p, p); return this; } StoreOffscreen(){ this.offscreen = new Gamestack.OffscreenCanvasRendering(this.image); for(var x in this.offscreen) { if(x == 'ctx' || x == 'canvas') this[x] = this.offscreen[x]; } return this; } getURL(){ this.StoreOffscreen(); return this.offscreen.canvas.toDataURL(); } getColoredPixelGrid(unitSize=5) { var grid = []; let min = this.framePos, max = this.framePos.add(this.frameSize); for (var x = min.x; x &lt;= max.x; x += unitSize) { for (var y = min.y; y &lt;= max.y; y += unitSize) { // Fetch pixel at current position var pixel = this.ctx.getImageData(x, y, 1, 1); // Check that opacity is above zero if (pixel.data[3] != 0) { var vector = new Gamestack.Vector(x, y), gridObject = { position: vector, size: new Gamestack.Vector(unitSize, unitSize), pixel:pixel }; grid.push(gridObject); } } } return grid; } getFullPixelGrid(unitSize=5) { var grid = []; let min = this.framePos, max = this.framePos.add(this.frameSize); for (var x = min.x; x &lt;= max.x; x += unitSize) { for (var y = min.y; y &lt;= max.y; y += unitSize) { // Fetch pixel at current position var pixel = this.ctx.getImageData(x, y, 1, 1); // Check that opacity is above zero var vector = new Gamestack.Vector(x, y), gridObject = { position: vector, size: new Gamestack.Vector(unitSize, unitSize), pixel:pixel }; grid.push(gridObject); } } return grid; } /** * Creates and returns a ColorMap for this animation, allowing opacity-based pixel-collision. * * @function * @param {number} unitDimen a Colormap grid-unit-size --A larger unitDimen decreases accuracy, and results in faster-processing. * @memberof Animation **********/ createColorMap(size, altImage) { if (!(altImage || this.image &amp;&amp; this.image.domElement)) return this; this.StoreOffscreen(); this.colorMap = this.getColoredPixelGrid(size, this.testCtx); return this.colorMap; } createFullPixelMap(size, altImage) { if (!(altImage || this.image &amp;&amp; this.image.domElement)) return this; this.StoreOffscreen(); this.fullPixelMap = this.getFullPixelGrid(size, this.testCtx); return this.fullPixelMap; } } Gamestack.Frame = Frame; })(); ;/** * @ignore * */ class ControllerEventKeys { constructor() { return { left_stick: false, right_stick: false, 0: false, 1: false, 2: false, 3: false, 4: false, 5: false, 6: false, 7: false, 8: false, 9: false, 10: false, 11: false, 12: false, 13: false, 14: false, 15: false, 16: false, 17: false, 18: false, 19: false } } } Gamestack.ControllerEventKeys = ControllerEventKeys; /** * Creates an instance of GamepadAdapter: --instead use the existing: Gamestack.GamepadAdapter, a working instance of this class. * -supports game-controller input for web-games * -accesses live gamepad input from the HTML5 Gamepad Api * @returns {GamepadAdapter} an instance of GamepadAdapter * */ Gamestack.gamepads = Gamestack.gamepads || []; class GamepadAdapter { constructor() { this.__gamepads = []; this.intervals = []; let controller_stack = this; let __gamepadMaster = this; this.events = []; window.addEventListener(\"gamepadconnected\", function (e) { console.log(\"Gamepad connected at index %d: %s. %d buttons, %d axes.\", e.gamepad.index, e.gamepad.id, e.gamepad.buttons.length, e.gamepad.axes.length); if (__gamepadMaster.mainLoop) { window.clearInterval(__gamepadMaster.mainLoop); } __gamepadMaster.mainLoop = window.setInterval(function () { var gps = navigator.getGamepads(); __gamepadMaster.gps = gps; for (var x = 0; x &lt; gps.length; x++) { var events = __gamepadMaster.__gamepads[x] ? __gamepadMaster.__gamepads[x] : {}; __gamepadMaster.process(__gamepadMaster.gps[x], events); } }, 20); }); } gamepads() { return navigator.getGamepads(); } disconnect_all() { for (var x = 0; x &lt; this.intervals.length; x++) { window.clearInterval(this.intervals[x]); } } disconnect_by_index(game_pad_index) { window.clearInterval(this.intervals[game_pad_index]); } hasAnyPad() { return \"getGamepads\" in navigator; } Event(key, game_pad, callback) { return { key: key, game_pad: game_pad, callback: callback } } GamepadEvents(args) { var gp = {}; gp.stick_left = args.stick_left || function (x, y) { // console.log('Def call'); } gp.stick_right = args.stick_right || function (x, y) { } gp.buttons = []; gp.extendFunc = function (f1, f2) { var fc = f2; return function (x, y) { f2(x, y); f1(x, y); } }; gp.on = function (key, callback) { if (this[key] &amp;&amp; key !== \"on\") { var current_cb = typeof(this[key]) == 'function' ? this[key] : function (x, y) { }; this[key] = this.extendFunc(callback, current_cb); } else if (key.indexOf('button') &gt;= 0 &amp;&amp; key.indexOf('_') &gt;= 0) { var parts = key.split('_'); var number; try { number = parseInt(parts[1]); var current_cb = typeof(this['buttons'][number]) == 'function' ? this['buttons'][number] : function (x, y) { }; this['buttons'][number] = this.extendFunc(callback, current_cb); } catch (e) { console.error('could not parse \"on\" event with ' + key); } } } gp.constructor = {name: \"GamepadEvents\"}; this.__gamepads.push(gp); Gamestack.gamepads = this.__gamepads; return gp; } getGamepads() { return Gamestack.gamepads; } process(gp, gpEvents) { this.process_buttons(gp, gpEvents); this.process_axes(gp, gpEvents); } process_axes(gp, events) { if (!gp || !gp['axes']) { return false; } for (var i = 0; i &lt; gp.axes.length; i += 2) { var axis1 = gp.axes[i], axia2 = gp.axes[i + 1]; var ix = (Math.ceil(i / 2) + 1), x = gp.axes[i], y = gp.axes[i + 1]; if (ix == 1 &amp;&amp; events.stick_left) { events.stick_left(x, y); } if (ix == 2 &amp;&amp; events.stick_right) { events.stick_right(x, y); } if (this.events &amp;&amp; this.events['stick_' + i] &amp;&amp; typeof(this.events['stick_' + i].callback) == 'function') { this.events['stick_' + i].callback(); } } } process_buttons(gp, events) { if (!gp || !gp['buttons']) { return false; } for (var i = 0; i &lt; gp.buttons.length; i++) { if (!events.buttons) break; else if (events.buttons.length &gt; i &amp;&amp; typeof(events.buttons[i]) == 'function') { events.buttons[i](gp.buttons[i].pressed); } else if (events.buttons.length &gt; i &amp;&amp; typeof(events.buttons[i]) == 'object' &amp;&amp; typeof(events.buttons[i].update) == 'function') { events.buttons[i].update(events.buttons[i].pressed); } var clearance_1 = this.events &amp;&amp; this.events[i], gpc, bkey = \"button_\" + i; if (clearance_1) { gpc = this.events[bkey] &amp;&amp; !isNaN(this.events[bkey].game_pad) ? this.gamepads[this.events[bkey].game_pad] : this.events[bkey].game_pad; } ; if (clearance_1 &amp;&amp; gpc &amp;&amp; typeof(this.events[bkey].callback) == 'function') { //call the callback this.events[i].callback(); } } } on(key, gpix, callback) { var keys = Larva.arrayWrap(key || []), gps = Larva.arrayWrap(gpix || []);; for(var x in keys) { for(var y in gps) { if (gps[y] &gt;= this.__gamepads.length) { this.__gamepads.push(this.GamepadEvents({})); } this.__gamepads[y].on(keys[x], callback); } } } } /********** * NOTE: here we bind the instance, and NOT the instantiator. * * *********/ if (!Gamestack.GamepadAdapter) { Gamestack.GamepadAdapter = new GamepadAdapter(); // __gameInstance.gamepads.push(gamepad); } ;class Line2d extends Scriptable { constructor() { super(); this.Object(this); this.points = []; this.position = new Gamestack.Vector(0, 0); this.size = new Gamestack.Vector(0, 0); this.index = 0; this.call = function() {}; } StepFunction(call) { this.call = call; return this; } next() { this.index += 1; return this.points[this.index % this.points.length]; } Color(c) { this.color = c; return this; } Fill() { for (var x = 1; x &lt;= this.size.x; x++) { var x_total = this.size.x; var out_of_1 = x / x_total; var next_x = this.position.x + x; console.log('using x portion::' + out_of_1); var next_y = this.position.y + (this.size.y * this.call(out_of_1, 1.0)), next_point = new Gamestack.Vector(next_x, next_y); this.points.push(next_point); } return this; } getOffsetPos(pos){ var offset = this.window_offset || new Gamestack.Vector(0, 0); return pos.add(offset); } draw(ctx, camera) { ctx = ctx || Gamestack.game_windows[0].ctx; camera = camera || Gamestack.game_windows[0].camera; var points = this.points; ctx.save(); ctx.strokeStyle = this.color; ctx.beginPath(); if (points instanceof Array) { for (var x = 0; x &lt; points.length; x++) { var p = points[x]; var position = p.position || p; var real_pos = this.getOffsetPos(position); if (real_pos.hasOwnProperty('x') &amp;&amp; real_pos.hasOwnProperty('y')) { if (x == 0) ctx.moveTo(real_pos.x, real_pos.y) else { ctx.lineTo(real_pos.x, real_pos.y); } } } } ctx.stroke(); ctx.restore(); } } Gamestack.Line2d = Line2d; Gamestack.Line2D = Line2d; ; /** * Creates a Sound instance. Implements HTML5-Audio object * --DevTODO : complete docs for the Sound class * * @param {string} src the source-path of the targeted sound-file * @returns {Sound} instance of Gamestack.Sound * */ class Sound { constructor(src, data) { if (typeof(src) == 'object') { this.sound = document.createElement('audio'); this.sound.src = src.src; this.src = src.src; } else if (typeof(src) == 'string') { this.sound = document.createElement('audio'); this.sound.src = src; this.src = src; } if(typeof(data)=='object') { for (var x in data) { if (x !== 'sound') { this[x] = data[x]; } } } this.onLoad = this.onLoad || function () { }; if (typeof(this.onLoad) == 'function') { this.onLoad(this.sound); } } Loop(loop) { this.sound.loop = loop || true; return this; } loop(loop) //same as Loop() { this.sound.loop = loop || true; return this; } Volume(val) { this.sound.volume = val; return this; } volume(val) //same as Volume() { this.sound.volume = val; return this; } Play() { if (typeof(this.sound) == 'object' &amp;&amp; typeof(this.sound.play) == 'function') { this.sound.play(); } return this; } play() { //same as Play() if (typeof(this.sound) == 'object' &amp;&amp; typeof(this.sound.play) == 'function') { this.sound.play(); } return this; } } class SoundList{ constructor(list) { this.cix = 1; this.sounds = []; if(list instanceof Array) { for(var x in list) { if(list[x].src) { this.sounds.push(new Sound(list[x].src, list[x])); } else if(typeof(list[x]) == 'string') { this.sounds.push(new Sound(list[x])); } } } } add(src, name) { if(typeof(src) == 'object' &amp;&amp; src.src) { this.sounds.push(new Sound(src.src, src)); } else if(typeof(src) == 'string') { var data = {}; if(name) { data.name = name; } this.sounds.push(new Sound(list[x], data)); } } Volume(v) { for(var x = 0; x &lt; this.sounds.length;x++) { this.sounds[x].volume(v); } return this; } volume(v) { for(var x = 0; x &lt; this.sounds.length;x++) { this.sounds[x].volume(v); } return this; } PlayNext() { this.sounds[this.cix % this.sounds.length].play(); this.cix += 1; } Play() { this.sounds[this.cix % this.sounds.length].play(); this.cix += 1; } playNext() //same as PlayNext() { this.sounds[this.cix % this.sounds.length].play(); this.cix += 1; } play() //same as Play() { this.sounds[this.cix % this.sounds.length].play(); this.cix += 1; } } Gamestack.Sound = Sound; Gamestack.SoundList = SoundList; ; var THREE_EXT = { defaults:{ DodecahedronGeometry:{radius:1, detail:0}, SphereGeometry:{radius:5, widthSegments:32, heightSegments:32}, BoxGeometry:{ width:20, height:20, depth:20 }, CylinderGeometry:{radiusTop:5, radiusBottom:5, height:20, heightSegments:32}, TorusGeometry:{radius:10, tube:3, radialSegments:16, tubularSegments:100 } } } class Three //dependency: THREE.js { constructor(args={}) { if(!THREE) //THREE.js library must be loaded { return console.error('ThreeJSObject():Library: Three.js is required for this object.'); } this.scene = new THREE.Scene(); if(args.geometry instanceof String &amp;&amp; THREE[args.geometry]) { this.geometry = new THREE[args.geometry](); } else { this.geometry = args.geometry || new THREE.TorusGeometry(50, 10, 16, 100); } this.scene.add( new THREE.AmbientLight( 0xffffff, 1.0 ) ); this.renderer = Gamestack.renderer || new THREE.WebGLRenderer({ preserveDrawingBuffer: true, alpha:true }); this.renderer.setSize(1000, 1000); this.camera = new THREE.PerspectiveCamera(70, 1, 1, 1000); this.camera.position.z = 1000 / 8; var __inst = this; var src = args.src || \"../assets/game/image/tiles/perlin_3.png\"; __inst.loader = new THREE.TextureLoader(); __inst.loader.load( src, function ( texture ) { __inst.material = args.material || new THREE.MeshPhongMaterial({ map: texture }); if(!__inst.__init) { __inst.mesh = new THREE.Mesh(__inst.geometry, __inst.material); __inst.scene.add(__inst.mesh); __inst.__init = true; } //__inst.mesh.size.set(__inst.size); __inst.renderer.render(__inst.scene, __inst.camera); __ServerSideFile.file_upload('test.png', __inst.renderer.domElement.toDataURL('image/png'), function(relpath, content){ relpath = relpath.replace('client/', '../'); __inst.selected_animation = new Animation({src:relpath, frameSize:new Vector(1000, 1000), frameBounds:new VectorFrameBounds(new Vector(0, 0, 0), new Vector(0, 0, 0),new Vector(0, 0, 0))}).singleFrame(); __inst.selected_animation.image.domElement.onload = function() { __inst.setSize(new Vector(__inst.selected_animation.image.domElement.width, __inst.selected_animation.image.domElement.height)); __inst.selected_animation.animate(); console.log(jstr(__inst.selected_animation.frames)); }; }); } ); } three_update() { console.log('THREE --GS-Object UPDATE'); this.mesh.rotation.y += 0.05; this.renderer.clear(); this.renderer.setSize(this.size.x, this.size.y); var pixels = new Uint8Array(this.size.x * this.size.y * 4); this.renderer.render(this.scene, this.camera); var gl = this.renderer.getContext(); gl.readPixels( 0, 0, this.size.x, this.size.y, gl.RGBA, gl.UNSIGNED_BYTE, pixels ); this.selected_animation.selected_frame = {image:{}}; this.selected_animation.selected_frame.image.data = new ImageData(new Uint8ClampedArray(pixels), this.size.x, this.size.y); } applyAnimativeState() { } } ;(function () { console.log('Animation class... creating'); /** * * Creates an instance of Animation with one or more Frames. * * &lt;iframe style='width:400px; height:450px; overflow:hidden;' src='../client/examples/js-class/Animation.html'&gt; &lt;/iframe&gt; * * @param {string=} [src] the src/file-path for this Animation * @param {GameImage= | HTMLImageElement=} [gameImage] the existing GameImage to be applied * @param {Object= | Animation=} [anime] the existing Animation-data to be returned as fully unique instance * @returns {Animation} an Animation object * * @example * * //constructor call: Creates a single-frame Animation from src * var singleFrameAnime = new Animation('directory/myFile.png'); * * @example * //constructor call with chainable function-calls: Creates multi-frame Animation from src, then sets properties with chainable-function-calls. * var multiFrameAnime = new Gamestack.Animation('../images/characters/full/spaceman1.png') //constructor is called * .FrameSize(130, 130) * .FrameBounds(new Gamestack.Vector(9, 0), new Gamestack.Vector(23, 0), new Gamestack.Vector(23, 0)) * .Seesaw() //The Animation will play back-and-forth repeatedly (cycle through frames forwards, then backwards and so on. * .Duration(900); //Animation lasts 900 millis OR just under 1 second * * @design * * //single-responsibility : to define a list of frames, then progress that list of frames with a 'selected_frame' property * var singleFrameAnime = new Animation('directory/myFile.png'); */ class Animation { constructor(src={}) { var args = typeof(src) == 'object' ? src : {}; //Gamestack.Modifiers.informable(this, args); if (typeof src == 'string') { this.Src(src, args.frameBounds); } else if(args instanceof Gamestack.GameImage) { console.log('Animation(): args are an instance of GameImage'); this.image = args; } else if(args instanceof HTMLImageElement) { console.log('Animation(): args was an instance of HTMLImageElement'); this.image = new Gamestack.GameImage(args); } else if(args instanceof Gamestack.Animation) { this.image = args.image; } else if(typeof(args)=='object' &amp;&amp; args.src) { this.src = args.src; this.image = new Gamestack.GameImage(args.src); } this.frameSize = this.frameSize || new Gamestack.Vector(args.frameSize || new Gamestack.Vector(0, 0)); if (args.frameBounds &amp;&amp; args.frameBounds.min &amp;&amp; args.frameBounds.max) { this.frameBounds = new Gamestack.VectorFrameBounds(args.frameBounds.min, args.frameBounds.max, args.frameBounds.termPoint); } else { this.frameBounds = new Gamestack.VectorFrameBounds(new Gamestack.Vector(0, 0, 0), new Gamestack.Vector(0, 0, 0), new Gamestack.Vector(0, 0, 0)); } this.frameOffset = this.getArg(args, 'frameOffset', new Gamestack.Vector(0, 0, 0)); this.apply2DFrames(); this.flipX = this.getArg(args, 'flipX', false); this.cix = 0; this.selected_frame = this.frames[0] || false; this.timer = 0; this.duration = args.duration || 2000; this.seesaw_mode = args.seesaw_mode || false; this.reverse_frames = args.reverse_frames || false; this.run_ext = args.run_ext || []; this.complete_ext = args.complete_ext || []; // this.colorMap = this.createColorMap(5); } Src(src, options={}){ if (typeof src == 'string') { console.log('setting GameImage with string:' + src); this.src = src; this.image = new Gamestack.GameImage(src); } else if(src instanceof GameImage) { console.log('Animation(): args are an instance of GameImage'); this.image = src; } else if(src instanceof HTMLImageElement) { console.log('Animation(): args was an instance of HTMLImageElement'); this.image = new Gamestack.GameImage(src); } if(!options.frameBounds) this.init_singleFrame(); return this; } Image(src){ if (typeof(src) == 'string') { console.log('setting GameImage with string:' + src); this.src = src; this.image = new Gamestack.GameImage(src); } else if(src instanceof Gamestack.GameImage) { console.log('Animation(): args are an instance of GameImage'); this.image = src; } else if(src instanceof HTMLImageElement) { console.log('Animation(): args was an instance of HTMLImageElement'); this.image = new Gamestack.GameImage(src); } this.init_singleFrame(); return this; } /** * sets this Animation to a single-frame-animation, from existing image * @function * @memberof Animation **********/ init_singleFrame() { var __inst = this; this.image.domElement.onload = function () { if(!__inst.__isInit) __inst.FrameSize(__inst.image.domElement.width, __inst.image.domElement.height) .FrameBounds(new Gamestack.Vector(0, 0), new Gamestack.Vector(0, 0)); __inst.run(); }; Gamestack.log('Animation():set single-frame animation'); return this; } /***** * Overridable / Extendable functions * -allows stacking of external object-function calls ******/ /** * Provides a function to be called whenever this Animation starts. Function should run every time the Animation reaches frame-index 0 * * @function * @params {Function} call the function to be called on start * @memberof Animation **********/ onRun(call) { if (this.run_ext.indexOf(call) == -1) { this.run_ext.push(call.bind(this)); } } /** * Provides a function to be called whenever this Animation completes. Function should run every time the Animation reaches it's last frame-index. * * @function * @params {Function} call the function to be called on complete * @memberof Animation **********/ onComplete(call) { if (this.complete_ext.indexOf(call) == -1) { this.complete_ext.push(call.bind(this)); } } call_on_run() { //call any function extension that is present for (var x = 0; x &lt; this.run_ext.length; x++) { this.run_ext[x](this); } } call_on_complete() { //call any function extension that is present for (var x = 0; x &lt; this.complete_ext.length; x++) { this.complete_ext[x](this); } } FrameSize(w, h) { this.frameSize = new Gamestack.Vector(w, h); this.__isInit = true; this.run(); return this; } Hang(){ this._hang = true; return this; } FrameBounds(minVector, maxVector, termVector) { this.frameBounds = new Gamestack.VectorFrameBounds(minVector, maxVector, termVector); this.__isInit = true; this.run(); return this; } FrameOffset(x, y){ this.frameOffset = new Gamestack.Vector(x, y); return this; } Seesaw() { if(!this.seesaw_mode) { this.seesaw_mode = true; } return this; } Duration(millis) { this.duration = millis; return this; } /** * Reverses all frames of the animation. Frames are then expected to run backwards. * * @function * @memberof Animation **********/ ReverseFrames() { this.reverse_frames = true; return this; } /** * Declares the animation a a single frame / full-image. * * @function * @param {Vector} frameSize optional size param * @memberof Animation **********/ SingleFrame() { this.__frametype = 'single'; this.frameSize = new Gamestack.Vector(this.image.domElement.width, this.image.domElement.height); this.frameBounds = false; this.selected_frame = new Gamestack.Frame().Image(this.image).Size(this.frameSize); this.frames = []; this.frames[0] = this.selected_frame; return this; } getArg(args, key, fallback) { if (args.hasOwnProperty(key)) { return args[key]; } else { return fallback; } } init(){ this.apply2DFrames(); return this; } apply2DFrames() { this.frames = []; var fcount = 0; var quitLoop = false; for (let y = this.frameBounds.min.y; y &lt;= this.frameBounds.max.y; y++) { for (let x = this.frameBounds.min.x; x &lt;= this.frameBounds.max.x; x++) { let framePos = { x: x * this.frameSize.x + this.frameOffset.x, y: y * this.frameSize.y + this.frameOffset.y }; var f = new Gamestack.Frame().Image(this.image).Size(this.frameSize).Position(framePos); this.frames.push(f); if (x &gt;= this.frameBounds.termPoint.x &amp;&amp; y &gt;= this.frameBounds.termPoint.y) { quitLoop = true; break; } fcount += 1; if (quitLoop) break; } } this.frames[0] = this.selected_frame = this.frames[0] || new Gamestack.Frame().Image(this.image).Size(this.frameSize); if (this.seesaw_mode) { // console.log('Animation: applying seesaw'); var frames_reversed = this.frames.slice().reverse(); this.frames.pop(); this.frames = this.frames.concat(frames_reversed); } if (this.reverse_frames) { this.frames.reverse(); } } scaleOf(sized_Object) { var s = Larva.getPreferredPropertyByKey(sized_Object, 'size', 'argument had nested size variable. Using this instead.'); return s.div(this.frameSize); } init_colorMap() { Larva.info('init_colorMap()'); if(!Larva.allDefined([this.image, this.image.domElement])) return []; this.canvasObject = this.canvasObject || new Gamestack.OffscreenCanvasRendering(this.image); this.colorMap = this.colorMap || this.ColoredPixelGrid(); return this.colorMap; } ColoredPixelGrid() { I('ColoredPixelGrid()'); var image = this.image.domElement, ctx = this.canvasObject.ctx, grid = [], frameSizeDiv = this.selected_frame.frameSize.div(12).round(); for (var x = 0; x &lt;= image.width; x+= frameSizeDiv.x) { for (var y = 0; y &lt;= image.height; y+= frameSizeDiv.y) { // Fetch pixel at current position var pixel = ctx.getImageData(x, y, 1, 1); // Check that opacity is above zero if (pixel.data[3] != 0) { var vector = new Gamestack.Vector(x, y), gridObject = { position:vector, size:frameSizeDiv }; grid.push(gridObject); } } } return grid; } /** * Returns the existing ColorMap for this animation. * * @function * @memberof Animation **********/ getCurrentPixelMap() { Larva.info('getCurrentPixelMap()'); var map = []; var frame = this.selected_frame; let __inst = this; this.colorMap = this.init_colorMap(); for(var x in this.colorMap) { var c = this.colorMap[x]; if(Gamestack.Collision.boxesCollide(frame.framePos, frame.frameSize, c.position, c.size)) { map.push(c); } } return map; } /** * Sets the frame to a specific array-index. * * @function * @param {number} ix the frame-index to apply. * @memberof Animation **********/ setFrame(ix) { this.selected_frame = this.frames[ix]; } update() { if(this._hang &amp;&amp; this.cix &gt;= this.frames.length - 1) { this.cix = this.frames.length - 1 } this.selected_frame = this.frames[Math.round(this.cix) % this.frames.length]; } reset() { this.apply2DFrames(); this.cix = 0; } /** * Applies a continuous animation. Use this in parent-sprite's update if continuous animation is required. * Also works as a single call at any time during game-update. * * @function * @memberof Animation **********/ run() { if (this.__frametype == 'single') { return 0; } this.apply2DFrames(); //update once: this.update(); if (this.cix == 0) { this.engage(); } } /** * animate():: same as run() * * @function * @memberof Animation **********/ animate() { if (this.__frametype == 'single') { return 0; } this.apply2DFrames(); //update once: this.update(); if (this.cix == 0) { this.engage(); } } /** * Engages, or updates the animation for a one full frame-cycle. * * @function * @param {number} duration the number of milliseconds the animation should take. * @memberof Animation **********/ engage(duration) { this.call_on_run(); duration = duration || this.duration || this.frames.length * 20; if (this.__frametype == 'single') { return 0; } let __inst = this; //we have a target this.tween = new TWEEN.Tween(this) .easing(__inst.curve || TWEEN.Easing.Linear.None) .to({cix: __inst.frames.length - 1}, duration) .onUpdate(function () { //console.log(objects[0].position.x,objects[0].position.y); // __inst.cix = Math.ceil(__inst.cix); __inst.update(); }) .onComplete(function () { //console.log(objects[0].position.x, objects[0].position.y); __inst.cix = 0; __inst.call_on_complete(); __inst.isComplete = true; }); if(this.cix == 0) this.tween.start(); if(this.cix &gt;= this.frames.length &amp;&amp; !this._hang) { this.cix = 0; } } } ; /** @memberof Gamestack */ Gamestack.Animation = Animation; Gamestack.Animation.continuous = Gamestack.Animation.run; //'continuous is an alternate reference to 'run'.' Gamestack.Animation.continue = Gamestack.Animation.run; //'continue is an alternate reference to 'run'.' Gamestack.Animation.animate = Gamestack.Animation.run; //'animate is an alternate reference to 'run'.' })(); ;/** * Creates an instance of Sprite. * * &lt;info-bit&gt;Gamestack.Sprite is a container for 2D Animations. * -apply Sprite class to create behaviors for an entire 2d-game-entity. * * Sprites hold reference to their-own Animations and Sounds.&lt;/info-bit&gt; * &lt;iframe style='width:400px; height:450px; overflow:hidden;' src='../client/examples/js-class/Sprite.html'&gt; &lt;/iframe&gt; * @param {string=} [src] the srcPath for the image of the Sprite * @param {scale=} [anime] the scale to be applied to width + height of the image * * @returns {Sprite} a Gamestack.Sprite object * * @example * * //Create Sprite using Sprite constructor, with one src argument * * */ class Sprite extends Scriptable { constructor(src = {}, scale = 1.0) { super(); this.Object(this); var args = typeof src == 'object' ? src : {}; if (args instanceof Gamestack.Animation) //instantiate from animation { console.dev('args was Gamestack.Animation', args); args = { selected_animation: args, image: args.image, size: new Gamestack.Vector(args.frameSize) }; } //apply image from string 'src' if (typeof src == 'string') { this.src = src; this.selected_animation = new Gamestack.Animation(src); this.image = this.selected_animation.image; this.SingleFrame(); } this.animations = []; //create size property this.size = new Gamestack.Vector(0, 0); if (typeof(scale) == 'number') //image plus 'scale' argument { this.scale = scale || 1.0; } this.active = true; //defaults to active or visible //apply remaining args this.apply_args(args); if (!this.selected_animation) this.SingleFrame(); } static_image_load(img) { this.size = new Gamestack.Vector(img.width * this.scale, img.height * this.scale).round(); } /** * runs a function for the onload event of this sprite's image * * @function * @param {Function} f the function to be called on load * @memberof Sprite **********/ onLoad(f) { var img = this.image.domElement, load = img.onload; f = f || function() {}; f.bind(this); this.load_call = f; var $sprite = this; img.onload = function() { $sprite.load_total += 1; load.bind($sprite).call($sprite); // $sprite.static_image_load(img); $sprite.load_call($sprite); }; img.onerror = function(err) { $sprite.load_call(false, $sprite); }; return this; } /********** * @ignore **********/ apply_args(args = {}) { this.FromData(args, true); //Using a FUNCTIONAL COPY --heavy to process if (args.image instanceof Gamestack.GameImage &amp;&amp; !this.image) { this.image = args.image; } this.name = args.name || \"__blankName\"; this.life = args.life || 999999999999; this.description = args.description || \"__spriteDesc\"; this.id = this.create_id(); this.animations = Gamestack.getArg(args, 'animations', []); this.scripts = Gamestack.getArg(args, 'scripts', []); this.motions = Gamestack.getArg(args, 'motions', []); this.particles = Gamestack.getArg(args, 'particles', []); this.shots = Gamestack.getArg(args, 'shots', []); this.sounds = Gamestack.getArg(args, 'sounds', []); this.init_ext = Gamestack.getArg(args, 'init_ext', []); this.group = Gamestack.getArg(args, 'group', 'one'); this.scrollFactor = args.scrollFactor || 1.0; this.noScroll = args.noScroll || false; if (this.noScroll) { this.scrollFactor = 0; } this.speed = new Gamestack.Vector(Gamestack.getArg(args, 'speed', new Gamestack.Vector(0, 0))); this.size = new Gamestack.Vector(Gamestack.getArg(args, 'size', new Gamestack.Vector(0, 0))); this.position = new Gamestack.Vector(Gamestack.getArg(args, 'position', new Gamestack.Vector(0, 0, 0))); this.collision_bounds = Gamestack.getArg(args, 'collision_bounds', new Gamestack.VectorBounds(new Gamestack.Vector(0, 0, 0), new Gamestack.Vector(0, 0, 0))); this.rotation = new Gamestack.Vector(Gamestack.getArg(args, 'rotation', new Gamestack.Vector(0, 0, 0))); this.scale = args.scale || 1.0; this.acceleration = Gamestack.getArg(args, 'acceleration', new Gamestack.Vector(0, 0, 0)); this.rot_speed = new Gamestack.Vector(Gamestack.getArg(args, 'rot_speed', new Gamestack.Vector(0, 0))); this.rot_accel = new Gamestack.Vector(Gamestack.getArg(args, 'rot_accel', new Gamestack.Vector(0, 0))); this.padding = Gamestack.getArg(args, 'padding', new Gamestack.Vector(0, 0, 0)); var __inst = this; //Apply / instantiate Sound(), Gamestack.Motion(), and Gamestack.Animation() args... Gamestack.each(this.shots, function(ix, item) { __inst.shots[ix] = new Gamestack.Shot(item); }); Gamestack.each(this.sounds, function(ix, item) { __inst.sounds[ix] = new Gamestack.Sound(item); }); Gamestack.each(this.motions, function(ix, item) { __inst.motions[ix] = new Gamestack.TweenMotion(item); }); Gamestack.each(this.animations, function(ix, item) { __inst.animations[ix] = new Gamestack.Animation(item); }); Gamestack.each(this.particles, function(ix, item) { __inst.particles[ix] = new Gamestack.GSProton(item); }); //Apply initializers: Gamestack.each(this.init_ext, function(ix, item) { __inst.addInitializer(item); }); if (!this.selected_animation &amp;&amp; args.selected_animation) { console.dev('applying animation:' + jstr(args.selected_animation)); this.selected_animation = new Gamestack.Animation(args.selected_animation); } } /** * Clones a sprite from existing data * * @function * @param {Object} object the data to be cloned * @memberof Sprite **********/ Clone(sprite){ console.log('using Clone() function'); var clone = new Gamestack.Sprite(sprite.src); clone.Anime(new Gamestack.Animation(sprite.anime)); clone.apply_args(sprite); return clone; } draw(ctx, camera) { var sprite = this; camera = camera || Gamestack.game_windows[0].camera || { position: new Gamestack.Vector(0, 0, 0) }; if (sprite.active &amp;&amp; (this.DRAWOFFSCREEN || sprite.onScreen(Gamestack.WIDTH, Gamestack.HEIGHT))) { this.draw_current_frame(ctx, camera); } } draw_current_frame(ctx, camera){ var sprite = this; var frame; if (sprite.active) { if (sprite.selected_animation instanceof Object &amp;&amp; sprite.selected_animation.hasOwnProperty('selected_frame')) { frame = sprite.selected_animation.selected_frame; } else { // console.error('Sprite is missing arguments'); //delay the draw return; } var p = sprite.position; var camera_pos = camera.position || { x: 0, y: 0, z: 0 }; if (!sprite.hasOwnProperty('scrollFactor')) { sprite.scrollFactor = 1.0; } var x = p.x, y = p.y, scrollFactor = sprite.scrollFactor &gt;= -1.0 &amp;&amp; sprite.scrollFactor &lt;= 1.0 ? sprite.scrollFactor : 1.0; if (sprite.noScroll) { scrollFactor = 0; } x -= camera_pos.x * scrollFactor || 0; y -= camera_pos.y * scrollFactor || 0; //optional animation : gameSize var targetSize = sprite.size || sprite.selected_animation.size; var realWidth = targetSize.x; var realHeight = targetSize.y; var origin = sprite.origin || new Gamestack.Vector(realWidth / 2, realHeight / 2); //optional animation : offset if (sprite.selected_animation &amp;&amp; sprite.selected_animation.hasOwnProperty('offset')) { x += sprite.selected_animation.offset.x; y += sprite.selected_animation.offset.y; } var rotation; if (typeof(sprite.rotation) == 'object') { rotation = sprite.rotation.x; } else { rotation = sprite.rotation; } var frame = sprite.selected_animation.selected_frame; sprite.realPosition = new Gamestack.Vector(x, y); if (frame &amp;&amp; frame.image &amp;&amp; frame.image.data) { ctx.putImageData(frame.image.data, x, y, 0, 0, sprite.size.x, sprite.size.y); } else { if (!sprite.selected_animation || !sprite.selected_animation.selected_frame.image.domElement) return; if (frame.image.domElement instanceof HTMLImageElement) { Gamestack.Canvas.draw_image_frame(frame.image.domElement, frame.framePos, frame.frameSize, new Gamestack.Vector2D(Math.round(x + (realWidth / 2)), Math.round(y + (realHeight / 2))), new Gamestack.Vector2D(realWidth, realHeight), rotation % 360, ctx, sprite.flipX, sprite.flipY, origin); } } } } /** * adds an animation to the sprites * * @function * @param {Object} object the animation to be added * @memberof Sprite **********/ Add(object) { if (object instanceof Gamestack.Animation) { this.animations.add(object); } return this; } get animation() { return this.selected_animation; } get anime() { return this.selected_animation; } Anime(anime) { if(anime) this.selected_animation = anime; return this; } Animation(anime) { if(anime) this.selected_animation = anime; return this; } FromData(data = {}, fxlCopy = false) { for (var x in data) { if (fxlCopy || typeof(data[x]) !== 'function') this[x] = data[x]; } return this; } /************************************************************** * scales the sprite.size property according to image-size. * @param {number} scaleFloat a 0-1+ value * * @function * @memberof Sprite **************************************************************/ Scale(scaleFloat) { this.scale = scaleFloat; this.size = new Gamestack.Vector(this.image.domElement.width * scaleFloat, this.image.domElement.height * scaleFloat); return this; } /************************************************************** * applies a float value arg to Sprite.scrollFactor * @param {number} s a 0-1+ value * * @function * @memberof Sprite **************************************************************/ ScrollFactor(s) { this.scrollFactor = s; return this; } engage(obj) //engages an object having an engage function { obj.parent = this; if (obj.engage) { obj.engage(); } } /** * pass argument v to the sprite.life property. * @function * @memberof Sprite * @param {number} v number of render-updates that this Sprite will last. --update occurs 60+ times per second, or less, depending on performance * @returns {Sprite} the sprite object --enables chainable function calls **********/ Life(v) { this.life = v; return this; } /** * initializes sprites. triggers all functions previously passed to the addInitializer function. * Use this function when a sprite, instantiated from json-data, carries initializers. * --This feature is built for the purpose of data-persistence. --sprites from json-file may carry behaviors onto the scene. * * @function * @memberof Sprite **********/ init() { } /** * extends the init function. * @function * @memberof Sprite * @param {function} fun the function to be passed into the init function of the sprite **********/ addInitializer(fun) { let boundFun = fun.bind(this) if (this.init_ext.indexOf(boundFun) &lt; 0) { this.init_ext.push(boundFun) }; } /***************************** * Getters ***************************/ /** * returns the 'id' property of the sprite * @function * @memberof Sprite * @returns {string} **********/ get_id() { return this.id; } /********** * @ignore **********/ to_map_object(size, framesize) { this.__mapSize = new Gamestack.Vector(size || this.size); this.frameSize = new Gamestack.Vector(framesize || this.size); return this; } /***************************** * Setters and Creators ***************************/ /** * creates a unique string id property for the sprite. * @function * @memberof Sprite * @returns {string} **********/ create_id() { return Gamestack.create_id(); } /** * returns a maximum scaled size, according to max dimensions of width and height * @param {number} mx the maximum size.x for the returned size * @param {number} my the maximum size.y for the returned size * @function * @memberof Sprite * @returns {Vector} a vector of x,y,z? values **********/ getSizeByMax(mx, my) { var size = new Gamestack.Vector(this.size); var wth = size.y / size.x; var htw = size.x / size.y; if (size.x &gt; mx) { size.x = mx; size.y = size.x * wth; } if (size.y &gt; my) { size.y = my; size.x = size.y * htw; } return size; } /***************************** * assert the existence of a speed{} property * sprite.speed (vector) is created if not existing in sprite * @memberof Sprite ***************************/ assertSpeed() { if (!this.speed) { this.speed = new Gamestack.Vector(0, 0, 0); } } /** * set the 'selected_animation' property to a single-frame-animation * @function * @memberof Sprite **********/ SingleFrame() { if (!this.image || !this.image.domElement) { return this; } var __inst = this, load = this.image.domElement.onload || function() {}; if (this.size &amp;&amp; this.size.x !== 0 &amp;&amp; this.size.y !== 0) return; var _obj = this; this.image.domElement.onload = function() { load(false, __inst); if (_obj.size &amp;&amp; _obj.size.x !== 0 &amp;&amp; _obj.size.y !== 0) { } else{ __inst.size = new Gamestack.Vector(__inst.image.domElement.width, __inst.image.domElement.height); __inst.selected_animation = new Gamestack.Animation(__inst.image).FrameSize(__inst.size); __inst.Scale(__inst.scale || 1.0); } }; Gamestack.log('set single-frame animation'); return this; } /** * set the 'life' property to a specified integer * @function * @memberof Sprite **********/ LifeSpan(value) { this.life = value; } /** * set the 'life' property to a specified integer * @function * @memberof Sprite **********/ Life(value) //same as LifeSpan { this.life = value; } /** * tells if sprite has been taken out of game * @function * @memberof Sprite **********/ isDead(gw) { gw = gw || Gamestack.game_windows[0]; return this.hasOwnProperty('life') &amp;&amp; this.life &lt;= 0; } /** * sets life to 0, then ending the sprite * @function * @memberof Sprite **********/ die(gw) { this.life = 0; return this; } /** * indicates if any portion of the sprite is within screen bounds --uses Gamestack.WIDTH, Gamestack.HEIGHT OR any w,h arguments passed to this method * @function * @memberof Sprite * @param {number} w optional screen-width argument, defaults to Gamestack.WIDTH * @param {number} h optional screen-height argument, defaults to Gamestack.HEIGHT * @returns {boolean} a true or false value to show if any part of the sprite is on-screen **********/ onScreen(w, h, gw) { w = w || Gamestack.WIDTH; h = h || Gamestack.HEIGHT; gw = gw || Gamestack.game_windows[0]; var camera = gw.camera || Gamestack.camera || { position: new Gamestack.Vector(0, 0, 0) }, scrollFactor = this.noScroll ? 0 : this.scrollFactor; var camPos = new Gamestack.Vector(camera.position).mult(scrollFactor); var p = new Gamestack.Vector(this.position.x - camPos.x, this.position.y - camPos.y, this.position.z - camPos.z); return p.x + this.size.x &gt; -1000 - w &amp;&amp; p.x &lt; w + 1000 &amp;&amp; p.y + this.size.y &gt; 0 - 1000 - h &amp;&amp; p.y &lt; h + 1000; } /***************************** * Updates ***************************/ /***************************** * update() * -starts empty:: is applied recursively by Gamestack.js as the main sprite-update ***************************/ /** * the main update for the sprite --applied recursively by GameWindow after gameWindow.start is called * @function * @memberof Sprite **********/ update(sprite) {} /***************************** * def_update() * -applies speed and other default factors of movement * -is used by Quick2d.js as the system def_update (default update) ***************************/ /** * Automatically updates various speed and rotational properties for the Sprite() * @function * @memberof Sprite * * @example * // applies a constant speed property --speed is Vector(x, y) * mySprite.rot_speed = new Gamestack.Vector(3); * //def_update() will run automatically with the gamestack update. The above sprite will rotate at a constant speed of 3. * @example * // how to reset to nothing:: if automatic speed updates are undesired, replace the def_update() function with a 'do nothing' function. * mySprite.def_update = function() * { * //do nothing * }; **********/ def_update(sprite) { if (this.hasOwnProperty('life') &amp;&amp; !isNaN(this.life)) { this.life -= 1; }; for (var x in this.speed) { if (this.speed[x] &gt; 0 || this.speed[x] &lt; 0) { this.position[x] += this.speed[x]; } } for (var x in this.acceleration) { if (this.acceleration[x] &gt; 0 || this.acceleration[x] &lt; 0) { this.speed[x] += this.acceleration[x]; } } for (var x in this.rot_speed) { if (this.rot_speed[x] &gt; 0 || this.rot_speed[x] &lt; 0) { this.rotation[x] += this.rot_speed[x]; } } for (var x in this.rot_accel) { if (this.rot_accel[x] &gt; 0 || this.rot_accel[x] &lt; 0) { this.rot_speed[x] += this.rot_accel[x]; } } } /** * extends an existing function, and is applied by Gamestack in addInitializer(); * @ignore * -REMOVED FROM DOCS : SYSTEM USE ONLY **********/ extendFunc(fun, extendedFunc) { console.log('extending func'); var ef = extendedFunc; var __inst = this; return function() { ef(__inst); //any new function comes after fun(__inst); }.bind(this); } /***************************** * onUpdate(fun) * -args: 1 function(sprite){ } //the self-instance/sprite is passed into the function() * -overrides and maintains existing code for update(){} function ***************************/ /** * extends the update of this sprite with a new function to be called during the update * --repeated calls will extend, (not replace) the update --Allows multiple extensions of the update * @function * @memberof Sprite * @param {function} fun the function to be appended to sprite.update * * * @example * // extend the behavior of your sprite * mySprite.onUpdate(function(spr) * * console.log('extended update'); //runs automatically whenever sprite.update runs * * }); * **********/ onUpdate(fun) { var id = this.create_id(); fun = fun.bind(this); let update = this.update.bind(this); let __inst = this; this.update = function(__inst) { update(__inst); fun(__inst); }; } /***************************** * travelLineTwoWay() * -sprite travels line: any Line() or object with property of line ***************************/ /******************************************************************************** * sprite travels on a line in a back-and-forth motion --to the end of the line, and back. * #Dev-todo:MORE ON THIS * @function * @memberof Sprite *********************************************************************************/ travelLineTwoWay(lineObject, speed, curveKey, offset) { speed = speed || 1; var motionCurveOptions = [\"linear\", \"quadratic\", \"cubic\"]; curveKey = curveKey || \"linear\"; var line = lineObject; if (lineObject.line) { line = lineObject.line; } this.__crtLineIx = this.__crtLineIx || 0; var __inst = this, pctFloat = __inst.__crtLineIx % ((line.points.length - 1) / 2) / ((line.points.length - 1) / 2); if (__inst.__crtLineIx &gt;= ((line.points.length - 1) / 2)) { pctFloat = 1.0 - pctFloat; } var ixChange = Gamestack.Curves.InOut[curveKey](pctFloat) * speed * 0.5; if (curveKey == 'linear') { ixChange = speed; } ixChange = Math.ceil(ixChange); if (ixChange &lt; 1) { ixChange = 1; } __inst.position = new Gamestack.Vector(line.points[__inst.__crtLineIx]); //console.log(ixChange); __inst.__crtLineIx += ixChange; if (__inst.__crtLineIx &gt;= line.points.length) { line.points = line.points.reverse(); __inst.__crtLineIx = 0; } if (offset instanceof Gamestack.Vector) { this.position = this.position.add(offset); } } /***************************** * travelLineOnLoop() * -sprite travels line: any Line() or object with property of line ***************************/ /** * the sprite travels one line in a looping motion --useful for traveling Square, Circle, or other enclosed Lines. * #Dev-todo:MORE ON THIS * @function * @memberof Sprite **********/ travelLineOnLoop(lineObject, speed, curveKey, offset) { speed = speed || 1; var motionCurveOptions = [\"linear\", \"quadratic\", \"cubic\"]; curveKey = curveKey || \"linear\"; var line = lineObject; if (lineObject.line) { line = lineObject.line; } this.__crtLineIx = this.__crtLineIx || 0; var __inst = this, pctFloat = __inst.__crtLineIx % ((line.points.length - 1) / 2) / ((line.points.length - 1) / 2); if (__inst.__crtLineIx &gt;= ((line.points.length - 1) / 2)) { pctFloat = 1.0 - pctFloat; } var ixChange = Gamestack.Curves.InOut[curveKey](pctFloat) * speed * 0.5; if (curveKey == 'linear') { ixChange = speed; } ixChange = Math.ceil(ixChange); if (ixChange &lt; 1) { ixChange = 1; } __inst.position = new Gamestack.Vector(line.points[__inst.__crtLineIx]); // console.log(ixChange); __inst.__crtLineIx += ixChange; if (__inst.__crtLineIx &gt;= line.points.length) { __inst.__crtLineIx = 0; } if (offset instanceof Gamestack.Vector) { this.position = this.position.add(offset); } } /** * returns a true || false value for immediate color-collision --non-transparent-pixels --between colored-pixels of this sprite and the sprite argument * @function * @memberof Sprite * @param {Sprite} spr the sprite object to be collided * @returns {boolean} a true or false value to show if collision is happening **********/ hasPixelCollision(sprite) { if (!Larva.truthyPropsPerArray([this, sprite], 'selected_animation')) return; if (!Larva.truthyPropsPerArray([this.selected_animation, sprite.selected_animation], 'getCurrentPixelMap')) return; let anime = this.selected_animation, alt_anime = sprite.selected_animation; var grid1 = anime.selectedFramePixelMap = this.selected_animation.getCurrentPixelMap(), grid2 = alt_anime.selectedFramePixelMap = alt_anime.getCurrentPixelMap(); for (var x in grid1) { for (var y in grid2) { if (Gamestack.Collision.boxesCollide(grid1[x].position, grid1[x].size, grid2[y].position, grid2[y].size)) { return true; } } } return false; } init_pixelCollision() { let anime = this.selected_animation; this.selectedFramePixelMap = anime.getCurrentPixelMap(anime.scaleOf(this.size)); this.colliderHighlights = this.colliderHighlights || []; } init_colliderHighlights(unitMarker) { while (this.colliderHighlights.length &lt; 100) { var sprite = new Gamestack.Sprite(unitMarker); this.colliderHighlights.push(sprite); Gamestack.game_windows[0].add(sprite); } } pixelGridOff() { } set_colliderHighlights(hSprite, on) { this.collider_highlightsOn = on || false; this.init_pixelCollision(); this.init_colliderHighlights(hSprite); let anime = this.selected_animation; for (var x in this.colliderHighlights) { this.colliderHighlights[x].active = false; } if (hSprite &amp;&amp; this.collider_highlightsOn) for (var x in this.selectedFramePixelMap) { if (!this.colliderHighlights[x]) { continue; } let gridPiece = this.selectedFramePixelMap[x]; let anime_scale = anime.scaleOf(this.size), real_gridPiece_pos = gridPiece.position.mult(anime_scale), real_gridPiece_size = gridPiece.size.mult(anime_scale); this.colliderHighlights[x].Pos(this.position.add(new Gamestack.Vector(real_gridPiece_pos.x, real_gridPiece_pos.y).sub(anime.selected_frame.framePos.mult(anime_scale)))); this.colliderHighlights[x].Size(real_gridPiece_size); this.colliderHighlights[x].active = true; }; } onPixelCollision(sprite, callback, highlightSprite) { let anime = this.selected_animation; this.onUpdate(function() { var anime = this.selected_animation; if (this.hasPixelCollision(sprite)) { if (!this.colliderHighlights) { } else for (var x in colliderHighlights) { gameWindow.remove(colliderHighlights[x]); }; callback(this, sprite); }; }); } /** * returns a true || false value for immediate box-collision --between this sprite and the sprite argument * @function * @memberof Sprite * @param {Sprite} sprite the alternate Sprite for collision detection * @returns {boolean} a true or false value to show if collision is happening **********/ hasBoxCollision(sprite) { return Gamestack.Collision.spriteBoxesCollide(this, sprite); } onBoxCollision(sprite, callback) { this.onUpdate(function() { if (this.hasBoxCollision(sprite, this.boxCollisionSettings.padding)) { callback(this, sprite); }; }); } /***************************** * shoot(sprite) * -fire a shot from the sprite:: as in a firing gun or spaceship * -takes options{} for number of shots anglePerShot etc... * -TODO: complete and test this code ***************************/ /** * fire a Shot, or bullet-Sprite from the Sprite * @function * @memberof Sprite * @param {Object} options an object of arguments * @param {Gamestack.Animation} animation the animation to fire from the Sprite * @param {number} speed the speed of the shot that is projected * @param {Gamestack.Vector} position the initial position of the shot: defaults to current Sprite position * @param {Gamestack.Vector} size the Vector size of the shot * @param {Gamestack.Vector} rot_offset the rotational offset to apply: controls direction of the shot **********/ shoot(options, gw) { //character shoots an animation gw = gw || Gamestack.game_windows[0]; this.prep_key = 'shoot'; let animation = options.bullet || options.animation || options.anime || new Gamestack.Animation(); let speed = options.speed || options.velocity || 1; let size = options.size || new Gamestack.Vector(10, 10, 0); let position = new Gamestack.Vector(options.position) || new Gamestack.Vector(this.position); let rot_offset = options.rot_offset || options.rotation || 0; let total = options.total || 1; let rot_disp = options.rot_disp || 0; //the full rotational-dispersion of the bullets let life = options.life || 900; var shots = []; for (var x = 0; x &lt; total; x++) { var __playerInst = this; if (Gamestack.isAtPlay) { var bx = position.x, by = position.y, bw = size.x, bh = size.y; var shot = new Gamestack.Sprite({ active: true, position: new Gamestack.Vector(position), size: new Gamestack.Vector(size), speed: speed, image: animation.image, rotation: new Gamestack.Vector(0, 0, 0), flipX: false, life: options.life }); shot.setAnimation(animation); rot_offset = new Gamestack.Vector(rot_offset, 0, 0); shot.position.x = bx, shot.position.y = by; //Danger On this line: annoying math --dispersing rotation of bullets by rot_disp var div = rot_disp / total; var rotPlus = div * x + div / 2 - rot_disp / 2; shot.rotation.x = rot_offset.x + rotPlus; // shot.origin = new Gamestack.Vector(position); shot.speed = new Gamestack.Vector(Math.cos((shot.rotation.x) * 3.14 / 180) * speed, Math.sin((shot.rotation.x) * 3.14 / 180) * speed); shots.push(shot); shot.onUpdate(function(spr) { // console.log('update:rotation:' + shot.rotation.x); }); gw.add(shot); } } return shots; } /** * create a sub-sprite belonging to the current sprite * @function * @memberof Sprite * @param {Object} options an object of arguments * @param {Animation} animation the animation to fire from the Sprite * @param {number} speed the speed of the shot that is projected * @param {Vector} position the initial position of the shot: defaults to current Sprite position * @param {Vector} size the Vector size of the shot * @param {Vector} offset the positional offset to apply * @returns {Sprite} a Gamestack.Sprite object **********/ subsprite(options, gw) { gw = gw || Gamestack.game_windows[0]; let animation = options.animation || new Gamestack.Animation(); let position = options.position || new Gamestack.Vector(this.position); let offset = options.offset || new Gamestack.Vector(0, 0, 0); let size = new Gamestack.Vector(options.size || this.size); if (Gamestack.isAtPlay) { var subsprite = gw.add(new Gamestack.Sprite({ active: true, position: position, size: size, offset: offset, image: animation.image, rotation: new Gamestack.Vector(0, 0, 0), flipX: false, scrollFactor: this.scrollFactor, noScroll: this.noScroll })); subsprite.setAnimation(animation); return subsprite; } else { alert('No subsprite when not at play'); } } /** * switch to the next frame on sprite.selected_animation * @function * @memberof Sprite * @param {Animation} animation the optional animation to switch to before animate is called, defaults to the existing sprite.selected_animation **********/ animate(animation) { if (Gamestack.isAtPlay) { if (animation) { this.setAnimation(animation) } this.selected_animation.run(); } } /** * run a function when the sprite.selected_animation is complete * * @function * @memberof Sprite * @param {Function} fun the function to call when the animation is complete * **********/ onAnimationComplete(fun) { this.selected_animation.onComplete(fun); } /***************************** * accelY * -accelerate on Y-Axis with 'accel' and 'max' (speed) arguments * -example-use: gravitation of sprite || up / down movement ***************************/ /** * accelerate speed on the y-axis * * @function * @memberof Sprite * @param {number} accel the increment of acceleration * @param {number} max the maximum for speed * **********/ accelY(accel, max) { accel = Math.abs(accel); if (typeof(max) == 'number') { max = { y: max }; } this.assertSpeed(); let diff = max.y - this.speed.y; if (diff &gt; 0) { this.speed.y += Math.abs(diff) &gt;= accel ? accel : diff; }; if (diff &lt; 0) { this.speed.y -= Math.abs(diff) &gt;= accel ? accel : diff; }; } /***************************** * accelX * -accelerate on x-Axis * -example-use: running of sprite || left / right movement ***************************/ /** * accelerate speed on the x-Axis * * @function * @memberof Sprite * @param {number} accel the increment of acceleration * @param {number} max the maximum for speed * **********/ accelX(accel, max) { accel = Math.abs(accel); if (typeof(max) == 'number') { max = { x: max }; } this.assertSpeed(); let diff = max.x - this.speed.x; if (diff &gt; 0) { this.speed.x += Math.abs(diff) &gt;= accel ? accel : diff; }; if (diff &lt; 0) { this.speed.x -= Math.abs(diff) &gt;= accel ? accel : diff; }; } /***************************** * accel * -accelerate any acceleration -key ***************************/ /** * decelerate speed on the x-Axis, toward zero * @function * @memberof Sprite * @param {number} amt the increment of deceleration, negatives ignored * **********/ decelY(amt) { amt = Math.abs(amt); if (Math.abs(this.speed.y) &lt;= amt) { this.speed.y = 0; } else if (this.speed.y &gt; amt) { this.speed.y -= amt; } else if (this.speed.y &lt; amt * -1) { this.speed.y += amt; } } /***************************** * decelX * -decelerate on the X axis * -args: 1 float:amt ***************************/ /** * decelerate speed on the x-Axis, toward zero * @function * @memberof Sprite * @param {number} amt the increment of deceleration, negatives ignored * **********/ decelX(amt) { amt = Math.abs(amt); if (this.speed.x &gt; amt) { this.speed.x -= amt; } else if (this.speed.x &lt; amt * -1) { this.speed.x += amt; } if (Math.abs(this.speed.x) &lt;= amt) { this.speed.x = 0; } } /** * accelerate toward a max value on any object-property * @function * @memberof Sprite * @param {Object} prop The object to control * @param {string} key the target property-key for object argument * @param {number} accel the additive increase to the property on each call * @param {number} max the max value to accelerate towards **********/ accel(object, key, accel, max) { var prop = object; accel = Math.abs(accel); if (typeof(max) == 'number') { max = { x: max }; } let speed = prop[key]; // this.assertSpeed(); let diff = max.x - prop[key]; if (diff &gt; 0) { prop[key] += Math.abs(diff) &gt;= accel ? accel : diff; }; if (diff &lt; 0) { prop[key] -= Math.abs(diff) &gt;= accel ? accel : diff; }; } /***************************** * decel * -deceleration -key ***************************/ /** * decelerate toward a max value on any object-property * @function * @memberof Sprite * @param {Object} prop the object to control * @param {string} key the property-key for targeted property of prop argument * * @param {number} decel the increment of deceleration * * @param {number} max the max value to decelerate towards * * **********/ decel(prop, key, rate) { if (typeof(rate) == 'object') { rate = rate.rate; } rate = Math.abs(rate); if (Math.abs(prop[key]) &lt;= rate) { prop[key] = 0; } else if (prop[key] &gt; 0) { prop[key] -= rate; } else if (prop[key] &lt; 0) { prop[key] += rate; } else { prop[key] = 0; } } seekPosition(target_Position, differential_SpeedMultiple) { var target = {}; //always positive: differential_SpeedMultiple = Math.abs(differential_SpeedMultiple); if (target_Position.hasOwnProperty('position')) { console.log('1st argument had its own position property. Using this property now:'); target = target_Position.position; } else { target = target_Position; } let diff = this.position.sub(target).mult(-1); this.speed = diff.mult(differential_SpeedMultiple); } /***************************** * decelY * -decelerate on the Y axis * -args: 1 float:amt ***************************/ /** * A generic 'smooth motion', adds to position.x and position.y with smooth acceleration and deceleration * --uses quadratic-easing of the TWEEN.js library * @function * @memberof Sprite * @param {number} x The x to be added to Sprite().positon.x over the course of the SmoothMotion --use negative for subtractive motion * @param {number} y The y to be added to Sprite().positon.y over the course of the SmoothMotion- -use negative for subtractive motion * @param {number} duration the amount of time taken to complete this motion * **********/ SmoothMotion(x, y, duration) { if (typeof(x) == 'object') //argument coercion: x is a vector, y is duration { duration = y; y = x.y; x = x.x; } x = x + this.position.x; y = y + this.position.y; if (!TWEEN instanceof Object) { return console.error('TWEEN.js required for SmoothMotion();'); } var t = new TWEEN.Tween(this.position) .easing(TWEEN.Easing.Quadratic.InOut) .to(new Gamestack.Vector(x, y), duration) .onUpdate(function() { //console.log(objects[0].position.x,objects[0].position.y); }) .onComplete(function() { //console.log(objects[0].position.x, objects[0].position.y); }); t.start(); } /** * A generic 'smooth rotate', adds to rotation.x with smooth acceleration and deceleration * --uses quadratic-easing of the TWEEN.js library * @function * @memberof Sprite * @param {number} r The numeric value to be added to Sprite().rotation.x over the course of the SmoothRotate --use negative for subtractive rotation * @param {number} duration the amount of time taken to complete this rotation **********/ SmoothRotate(r, duration) { if (!TWEEN instanceof Object) { return console.error('TWEEN.js required for SmoothRotate();'); } r = r + this.rotation.x; var t = new TWEEN.Tween(this.rotation) .easing(TWEEN.Easing.Quadratic.InOut) .to(new Gamestack.Vector(r), duration) .onUpdate(function() { //console.log(objects[0].position.x,objects[0].position.y); }) .onComplete(function() { //console.log(objects[0].position.x, objects[0].position.y); }); t.start(); } /** * get the vector-position at the center of the sprite, based on its current position and size * @function * @memberof Sprite * * @returns (Vector) a vector-position pinpointing the current-center of the sprite * **********/ center() { return new Gamestack.Vector(this.position.x + this.size.x / 2, this.position.y + this.size.y / 2, 0); } /***************************** * System Use / Collision ***************************/ /***************************** * @ignore ***************************/ shortest_stop(item, callback) { var diff_min_y = item.min ? item.min.y : Math.abs(item.position.y - this.position.y + this.size.y); var diff_min_x = item.min ? item.min.x : Math.abs(item.position.x - this.position.x + this.size.x); var diff_max_y = item.max ? item.max.y : Math.abs(item.position.y + item.size.y - this.position.y); var diff_max_x = item.max ? item.max.x : Math.abs(item.position.x + item.size.x - this.position.y); var dimens = { top: diff_min_y, left: diff_min_x, bottom: diff_max_y, right: diff_max_x }; var minkey = \"\", min = 10000000; for (var x in dimens) { if (dimens[x] &lt; min) { min = dimens[x]; minkey = x; // a key of top left bottom or right } } callback(minkey); } /************* * #BE CAREFUL * -with this function :: change sensitive / tricky / 4 way collision * *************/ /** * determine if sprite overlaps on x-axis with another sprite * * @function * @memberof Sprite * @param {Sprite} item the Sprite to compare with * @param {number} padding the 0-1.0 float value of padding to use on self when testing overlap * @returns {boolean} a true || false var showing if overlap has occured * **********/ overlap_x(item, padding) { if (!padding) { padding = 0; } var paddingX = Math.round(padding * this.size.x), paddingY = Math.round(padding * this.size.y), left = this.position.x + paddingX, right = this.position.x + this.size.x - paddingX, top = this.position.y + paddingY, bottom = this.position.y + this.size.y - paddingY; return right &gt; item.position.x &amp;&amp; left &lt; item.position.x + item.size.x; } /************* * #BE CAREFUL * -with this function :: change sensitive / tricky / 4 way collision * *************/ /** * determine if sprite overlaps on y-axis with another sprite * @function * @memberof Sprite * @param {Sprite} item the Sprite to compare with * @param {number} padding the 0-1.0 float value of padding to use on self when testing overlap * @returns {boolean} a true || false var showing if overlap has occured * **********/ overlap_y(item, padding) { if (!padding) { padding = 0; } var paddingX = Math.round(padding * this.size.x), paddingY = Math.round(padding * this.size.y), left = this.position.x + paddingX, right = this.position.x + this.size.x - paddingX, top = this.position.y + paddingY, bottom = this.position.y + this.size.y - paddingY; return bottom &gt; item.position.y &amp;&amp; top &lt; item.position.y + item.size.y; } /************* * #BE CAREFUL * -with this function :: change sensitive / tricky / 4 way collision * *************/ /** * stop collision on x-axis with another sprite * @function * @memberof Sprite * @param {Sprite} item the Sprite with which to collide-stop on the x-axis **********/ collide_stop_x(item) { var apart = false; var ct = 10000; while (!apart &amp;&amp; ct &gt; 0) { ct--; var diffX = this.center().sub(item.center()).x; var distX = Math.abs(this.size.x / 2 + item.size.x / 2 - Math.round(this.size.x * this.padding.x)); if (Math.abs(diffX) &lt; distX) { this.position.x -= diffX &gt; 0 ? -1 : 1; } else { this.speed.x = 0; apart = true; } } } /************* * #BE CAREFUL * -with this function :: change sensitive / tricky / 4 way collision * *************/ /** * Trigger a fourway collision-stop between this and another Sprite :: * objects will behave clastically and resist passing through one-another * * @function * @memberof Sprite * @param {Sprite} item the Sprite to collide with * **********/ collide_stop(item) { if (this.id == item.id) { return false; } this.speed = this.speed || new Gamestack.Vector(0, 0, 0); this.padding = this.padding || new Gamestack.Vector(0, 0, 0); // this.position = this.position.sub(this.speed); if (this.hasBoxCollision(item)) { var diff = this.center().sub(item.center()); if (this.overlap_x(item, this.padding.x + 0.1) &amp;&amp; Math.abs(diff.x) &lt; Math.abs(diff.y)) { var apart = false; var ct = 10000; while (!apart &amp;&amp; ct &gt; 0) { ct--; var diffY = this.center().sub(item.center()).y; var distY = Math.abs(this.size.y / 2 + item.size.y / 2 - Math.round(this.size.y * this.padding.y)); if (Math.abs(diffY) &lt; distY) { this.position.y -= diffY &gt; 0 ? -1 : diffY &lt; 0 ? 1 : 0; this.position.y = Math.round(this.position.y); } else { if (diffY &lt;= 0) { this.__inAir = false; }; this.speed.y = 0; return apart = true; } } } if (this.overlap_y(item, this.padding.y) &amp;&amp; Math.abs(diff.y) &lt; Math.abs(diff.x)) { this.collide_stop_x(item); } } } /** * collide-stop only from the top (of the sprite passed as argument) :: * * @function * @memberof Sprite * @param {Sprite} item the Sprite to collide with * **********/ collide_stop_top(item, callback) { if (this.id == item.id) { return false; } if (this.overlap_x(item, this.padding.x + 0.1)) { console.log('OVERLAP_X'); var paddingY = this.padding.y * this.size.y; if (this.position.y + this.size.y - paddingY &lt;= item.position.y) { this.groundMaxY = item.position.y - this.size.y + paddingY; } } } /** * restore a sprite from existing json-data --applies to data-persistence * * @function * @memberof Sprite * * @returns (Sprite) **********/ restoreFrom(data) { data.image = new GameImage(data.src || data.image.src); return new Gamestack.Sprite(data); } /***************************** * @ignore * #IN-TESTING * fromFile(file_path) * -TODO : complete this function based on code to load Sprite() from file, located in the spritemaker.html file * -TODO: test this function ***************************/ fromFile(file_path) { if (typeof file_path == 'string') { var __inst = this; $.getJSON(file_path, function(data) { __inst = new Gamestack.Sprite(data); }); } } /***************************** * return a decycled json-string for the sprite --without circular references * @returns {string} a json string ***************************/ toJSONString() { return jstr(JSON.decycle(this)); } }; Gamestack.Sprite = Sprite; ; class Text { constructor(value){ this.Text(value); this.FontSize(15); this.FontFamily('Arial'); this.color = 'white'; this.position = new Gamestack.Vector(0, 0); } Font(fsize, ffamily){ this.FontSize(fsize); this.FontFamily(ffamily) return this; } FontSize(value){ if(typeof value !== 'string') value = value + ''; value = value.replace('px', '') + 'px'; this.fontSize = value; return this; } FontFamily(value) { this.fontFamily = value; return this; } getOffsetPos(pos){ var offset = this.window_offset || new Gamestack.Vector(0, 0); return pos.add(offset); } draw(ctx, camera){ var x = this.position.x + camera.position.x, y = this.position.y + camera.position.y; if(ctx.save) { ctx.save(); } ctx.fillStyle = this.color; ctx.font = this.fontSize + ' ' + this.fontFamily; var pos = new Gamestack.Vector(x, y), realPos = this.getOffsetPos(pos); ctx.fillText(this.text, realPos.x, realPos.y); ctx.restore(); } } Gamestack.Text = Text; ;/**************************** * Robotix ***************************/ //Appendage:: one stack of objects which behave as single appendage: //--a chain of links or an arm or leg made of separate parts class Appendage { constructor() { } } //Single part which exists along with its parent object class Attachment { constructor(){ } } ;/** * Creates a GravityForce instance. * *@param {Object} args the object of arguments * @param {string} args.name optional * @param {string} args.description optional * @param {Array} args.subjects the subjects to be pulled by the GravityForce * @param {Array} args.clasticObjects any clastic object or array-of-objects that should have collision-stop behavior with subjects * @param {Vector} args.max the max speed of the gravity-force, similar to concept of 'terminal velocity' * @param {number} args.accel the increment of acceleration for each update called, while subjects are falling * * @returns {GravityForce} a GravityForce object */ (function () { console.log('Force class... creating'); class GravityForce { constructor(args = {}) { this.name = args.name || \"\"; this.description = args.description || \"\"; this.subjects = args.subjects || []; this.clasticObjects = args.clasticObjects || []; this.topClastics = args.topClastics || []; this.max = args.max || new Vector3(3, 3, 3); this.accel = args.accel || new Vector3(1.3, 1.3, 1.3); for (var x in this.clasticObjects) { if (!this.clasticObjects[x] instanceof Gamestack.Sprite) { this.clasticObjects[x] = Gamestack.getById(this.clasticObjects[x].id); } } for (var x in this.topClastics) { if (!this.topClastics[x] instanceof Gamestack.Sprite) { this.topClastics[x] = Gamestack.getById(this.topClastics[x].id); } } for (var x in this.subjects) { if (!this.subjects[x] instanceof Gamestack.Sprite) { this.subjects[x] = Gamestack.getById(this.subjects[x].id); } } } getArg(args, key, fallback) { if (args.hasOwnProperty(key)) { return args[key]; } else { return fallback; } } /** * Updates position for all objects effected by this instance. * @memberof GravityForce */ update() { var subjects = this.subjects; var clasticObjects = this.clasticObjects; var topClastics = this.topClastics; var accel = this.accel || {}; var max = this.max || {}; Gamestack.each(subjects, function (ix, itemx) { if(!itemx.jumping &amp;&amp; !itemx.flying) itemx.accelY(accel, max); itemx.__inAir = true; if (itemx.position.y &gt;= itemx.groundMaxY) { itemx.position.y = itemx.groundMaxY; } itemx.groundMaxY = 3000000; //some crazy number you'll never reach in-game Gamestack.each(topClastics, function (iy, itemy) { // itemx.collide_stop_top(itemy); }); }); } }; let Force = GravityForce; Gamestack.Force = Force; Gamestack.GForce = Force; Gamestack.GravityForce = GravityForce; })(); ;;;;;class Player extends Sprite { constructor() { super(...arguments); } OnInput(inputDevice, arg1, arg2, callback) { console.info('Player.OnInput: Feature not implemented'); } } Gamestack.Player = Player; ; /** * Creates an instance of Shot. * &lt;info-bit&gt;Shot object fires a moving-animation from a sprite &lt;/info-bit&gt; * * @param {string} name the name of this Shot * @param {GameImage | Animation} imageOrAnimation the GameImage or Animation to apply for this Shot * @returns {Shot} a Gamestack.Shot object */ class Shot { constructor(name, imageOrAnimation) { this.name = name || 'No-Name'; if(imageOrAnimation instanceof Gamestack.GameImage) { this.anime = new Animation(imageOrAnimation); } else if(imageOrAnimation instanceof Gamestack.Animation) { this.anime = imageOrAnimation; } this.rotation = 0; this.rot_disp = 0; var args = name instanceof Object ? name : {}; //is name / first arg an entire instance of shot? this.init(args); } init(args) { if(args instanceof Object) { for (var x in args) { this[x] = args[x]; if(args[x] instanceof Object &amp;&amp; args[x].hasOwnProperty('x'))//process as Vector { this[x] = new Vector(args[x]); } } } } Image(image) { this.anime = new Animation(image); } Animation(anime) { this.anime = anime; return this; } Total(total, rot_disp_per_unit) { this.total =total; this.rot_disp = rot_disp_per_unit; return this; } WaveGrowth(growth) { if(growth &gt; 0) this.curve_growth = growth; } CurveMode(key, size, growth) { this.curve = Gamestack.Curves.InOut[key.toLowerCase()]; this.curve_key = key.toLowerCase(); this.curve_size = size; if(growth &gt; 0) this.curve_growth = growth; if(typeof(this.curve_size)=='number') this.curve_size = new Gamestack.Vector(this.curve_size, this.curve_size); return this; } RotDisp( rot_disp) { this.rot_disp = rot_disp; return this; } Velocity(v) { this.velocity = v; return this; } onCollide(collideables, callback) { } } Gamestack.Shot = Shot; ;class Background extends Gamestack.Sprite { constructor(arg1={}, arg2={}) { super(arg1, arg2); let args = typeof(arg1) == 'object' ? arg1 : {}; this.type = args.type || \"parallax\" || \"basic\" || false; this.source_objects = args.objects || args.source_objects || []; this.members = []; this.rows = args.rows || 1;//The Y number of repititions this.cols = args.cols || 1; //The X number of repetitions of the images this.flip = args.flip || false; this.fill = args.fill || false; this.flip = args.flip || false; } Flip(value) { if(value == undefined) { this.flip = true; } else if (value == true || value == false) { this.flip = value; } return this; } Rows(r) { this.rows = r; return this; } Cols(c) { this.cols = c; return this; } Fill(approxRows, approxCols, gw) { approxRows = approxRows || this.rows || 1; approxCols = approxCols || this.cols || 1; this.members.push(new Background(this)); //\"This\" or base image is always applied for(var x = 0; x &lt; this.source_objects.length; x++) { this.members.push(new Background(this.source_objects[x]));//src strings OR Sprites() } gw = gw || Gamestack.game_windows[0]; var w= gw.canvas.width, h = gw.canvas.height, xBacksTotal = Math.floor(approxRows / 2), yBacksTotal = Math.floor(approxCols / 2); var __inst = this; //create first row: for(var y = -yBacksTotal; y &lt;= yBacksTotal + 1; y++) { console.log('adding background:' + y); for(var x = -xBacksTotal; x &lt;= xBacksTotal + 1; x++) { this.members.push(new Background(this)); var b = this.members[this.members.length - 1]; b.setSize(this.size); var __inst = this; b.position.x = x * this.size.x; b.position.y = y * this.size.y; b.minX = -xBacksTotal * b.size.x + b.size.x; b.maxX = (xBacksTotal + 1) * b.size.x ; b.minY = -yBacksTotal * b.size.y + b.size.y; b.maxY = yBacksTotal * b.size.y ; if(x % 2 == 0) { b.flipX = true; } if(y % 2 == 0) { b.flipY = true; } b.onUpdate(function(spr){ spr.campos = gw.camera.position; var cx = spr.campos.x - (spr.campos.x % spr.size.x), cy = spr.campos.y - ( spr.campos.y % spr.size.y ); if(spr.position.x - cx &lt; spr.minX) { spr.position.x = spr.maxX + cx; } if(spr.position.x - cx &gt; spr.maxX) { spr.position.x = spr.minX + cx; } if(spr.position.y - cy &lt; spr.minY) { spr.position.y = spr.maxY + cy; } if(spr.position.y - cy &gt; spr.maxY) { spr.position.y = spr.minY + cy; } }); gw.add(b); //add to window } } return this; } add(object) { var cleanCheck = object instanceof Gamestack.Sprite || object instanceof Array &amp;&amp; object[0] instanceof Gamestack.Sprite; //is Sprite if(!cleanCheck) { return console.error('Must have: valid contents (Gamestack.Sprite OR [] of Gamestack.Sprite())'); } if(object instanceof Array) { this.source_objects.cancat(object) } else { this.source_objects.push(object); } return this; } } Gamestack.Background = Background;; //Author: Jordan E. Blake class Effect { constructor() { } isAnimation() { } isParticleEffect() { } isSoundEffect() { } commit() { } } class SpriteMove { constructor(args = {}) { this.line = 100; this.timeLimit = 350; this.degreesRotated = 90; } setAnimation() { } setAnimationForward() //set the basic animation OR 'forward anime' { } setAnimationBackard() //set the backward animation OR 'backward-anime' { } setLineBack() //set the 'backward movement', should the Sprite need to return from the move { } setLine() //set the basic line OR 'forward movement' { } setLineForward() //set the basic line OR 'forward movement' { } setLineBack() //set the 'backward movement', should the Sprite need to return from the move { } setImmediateEffects() //Effects triggered when the SpriteMove starts { } setAfterEffects() //Effects triggered when the SpriteMove completes { } commit() { } then() { } } class Jump { constructor(spriteMove) { } setAnimation() { } setTimeLimit() { } setUpward(distance, duration) { } setDownward(distance, duration) { } commit() { } } class Vault { constructor(forward, back, afterEffects) { } commit() { } setForwardMove(line, curve, duration) { } setBackwardMove(line, curve, duration) { } onForwardDone(psuedoEffect) { } onBackwardDone(psuedoEffect) { } } class Attack { constructor(spriteMove, rpsLevel, powerLevel, afterEffects) { } commit() { } setAfterEffects(afterEffects) { } setRpsLevel(rpsLevel) { } setPowerLevel(pLevel) { } } ;/** * Takes an object of arguments and returns Projectile() object. Projectile fires a shot from the parent sprite, with specified offset, rotation, motion_curve, line_curve * @param {Object} args object of arguments * @param {string} args.name optional * @param {string} args.description optional * @param {string} args.distance the distance before dissappearance * @param {TWEEN.Easing.'objectGroup'.'objectMember'} args.motion_curve the TWEEN.Easing function to be applied for motion/speed (Example: TWEEN.Easing.Quadratic.InOut) * * * @param {TWEEN.Easing.'objectGroup'.'objectMember'} args.line_curve the TWEEN.Easing function to be applied for line (Example: TWEEN.Easing.Quadratic.InOut) * * @returns {Projectile} a Projectile object */ class Projectile { constructor(args = {}) { this.getArg = $Q.getArg; for (var x in args) { this[x] = args[x]; } this.name = args.name || \"__\"; this.description = args.description || \"__\"; this.animation = Gamestack.getArg(args, 'animation', new Animation()); this.parent_id = args.parent_id || args.object_id || \"__blank\"; //The parent object this.name = Gamestack.getArg(args, 'name', \"__\"); this.size = false; if(args.size) { this.size = new Vector(args.size); } else if(this.animation &amp;&amp; this.animation.frameSize) { this.size = new Vector(this.animation.frameSize); } else { console.info('Projectile():using default size.'); this.size = new Vector(20, 20, 20); } this.origin = args.origin || new Vector(0, 0, 0); this.rotation = args.rotation || 0; this.line.Rotation(this.rotation); this.description = Gamestack.getArg(args, 'description', false); this.duration = Gamestack.getArg(args, 'duration', 500); this.delay = Gamestack.getArg(args, 'delay', 0); this.position = Gamestack.getArg(args, 'position', new Vector(0, 0, 0)); this.motion_curve = Gamestack.getArg(args, 'motion_curve', TWEEN.Easing.Linear.None); this.highlighted = false; this.sprites = []; this.run_ext = args.run_ext || []; } /** * specify a function to be called when Motion is complete * * @function * @memberof Projectile * @param {Function} fun the function to be called when complete * **********/ onComplete(fun) { this.complete = fun; } onCollide(fun) { this.collide = fun; } setAnimation(anime) { this.animation = anime; return this; } setMotionCurve(c) { this.motion_curve = c; return this; } kill_one() { var spr = this.sprites[this.sprites.length - 1]; Gamestack.remove(spr); } onRun(caller, callkey) { this.run_ext = this.run_ext || []; this.run_ext.push({caller: caller, callkey: callkey}); } shoot_basic(position, size, rot_offset, speed, numberShots, disp){ var __playerInst = this; var bx = position.x, by = position.y, bw = size.x, bh = size.y; var half = numberShots / 2; for(var x = half * -1; x &lt;= half; x++) { var shot = Gamestack.add(new Sprite({ active: true, position: position, size: size, speed: speed, image: animation.image, rotation: new Vector3(0, 0, 0), flipX: false })); shot.setAnimation(animation); rot_offset = new Vector(rot_offset + (x * disp), 0, 0); shot.position.x = bx, shot.position.y = by; shot.rotation.x = 0 + rot_offset.x; shot.stats = { damage: 1 }; if (!options.line) { shot.onUpdate(function () { shot.position.x += Math.cos((shot.rotation.x) * 3.14 / 180) * speed; shot.position.y += Math.sin((shot.rotation.x) * 3.14 / 180) * speed; }); } } } fire(origin, rotation) { for (var x = 0; x &lt; this.run_ext.length; x++) { this.run_ext[x].caller[this.run_ext[x].callkey](); } this.line.origin = origin; this.line.rotation = rotation; console.log('FIRING FROM:' + jstr(origin)); var sprite = new Sprite({image: this.animation.image}); sprite.setAnimation(this.animation); sprite.setSize(this.size); sprite.position = new Vector(0, 0, 0); var __inst = this; __inst.line.fill(); var lp = this.line.points; sprite.position = new Vector(lp[0]); sprite.onUpdate(function (sprite) { for (var x = 0; x &lt; lp.length; x++) { if (sprite.position.equals(lp[x]) &amp;&amp; x &lt; lp.length - 1) { sprite.position = new Vector(lp[x + 1]); break; } if (x == lp.length - 1) { Gamestack.remove(sprite); } } }); Gamestack.add(sprite); this.sprites.push(sprite); } } Gamestack.Projectile = Projectile;; (function(){ console.log('Terrain class... creating'); class Terrain extends Gamestack.Sprite { constructor(args={}) { super(args); //init as Gamestack.Sprite() this.collideables = args.collideables || args.colliders || []; } Collideables(c) { this.collideables = c || []; if(!this.collideables instanceof Array) { return console.error('Must pass array for \"c\" argument'); } return this; } onCollide() // Gamestack.Terrain instance should have an onCollide() function { } } Gamestack.Terrain= Terrain; })(); ; (function(){ console.log('Interactive class... creating'); class Interactive extends Gamestack.Sprite { constructor(args = {}) { super(args); //init as Gamestack.Sprite() this.collision_settings = new Gamestack.CollisionSettings(args); this.collideables = args.collideables || []; Gamestack.Extendors.collideable(this, args); //overwrites the onCollide(): } Collideables(c) { this.collideables = c || []; if(!this.collideables instanceof Array) { return console.error('Must pass array for \"c\" argument'); } return this; } onCollide() // Gamestack.Interactive instance should have an onCollide() function { } } Gamestack.Interactive = Interactive; })();;class SpriteArray { constructor() { this.sprites = []; this.update = []; this.moves = {}; this.load = function() {}; this.update = function() {}; } each(f) { var ix = 0; this.sprites.forEach(function(spr) { f(ix, spr); ix += 1; }); } add(sprite) { this.sprites.push(sprite); return this; } /** * runs a function when the sprite's image has loaded * * @function * @params {Function} f the function to be called on load * @memberof Sprite **********/ onLoadSprites(f) { var sprites = this.sprites, len = this.sprites.length, ix = 0; var __spriteList = this; __spriteList.load = f.bind(this); sprites.forEach(function(spr) { spr.onLoad(function() { ix += 1; if (ix == len) { __spriteList.load(__spriteList.sprites); } }); }); } } Gamestack.SpriteArray = SpriteArray; class SpriteVerticalChain extends SpriteArray { constructor() { super(); } add(sprite) { sprite.parent = this.sprites.length &gt;= 1 ? this.sprites[this.sprites.length - 1] : false; sprite.onUpdate(function() { this.origin = this.origin || new Gamestack.Vector(this.size.x / 2, 0); if (this.parent) { this.offset = this.offset || new Gamestack.Vector(0, 0); var extremity = new Gamestack.Vector(0, this.parent.size.y); var p = this.parent.position.add(this.parent.origin); // p = p.sub(this.origin); // p = p.add(parent.origin); var np = new Gamestack.Vector(Gamestack.GeoMath.rotatePointsXY(extremity.x, extremity.y, this.parent.rotation.x)); this.position = p.add(np).add(this.offset); } }); this.sprites.push(sprite); return this; } } Gamestack.SpriteVerticalChain = SpriteVerticalChain; ; class SpriteCollider { constructor(){ } PixelUnit(){ } Box(){ } Eliptical(){ } TestMode(){ } } ;class FeatureSymbol { constructor(key) { this.key = key || \"@NONE\"; this.symbol = Symbol(key); } } Gamestack.FeatureSymbol = FeatureSymbol; Gamestack.FeatureInjectors = Gamestack.FeatureInjectors || {}; Gamestack.FeatureInject = function(constructor, args) { //console.log('Gamestack.FeatureInject()'); var GClassFeatures = {}; for (var y in Gamestack.ObjectFeatureMap) { if (Gamestack[y] &amp;&amp; typeof Gamestack[y] == 'function') { var constructor = Gamestack[y]; GClassFeatures[y] = {}; // console.log('Feature Symbol-key:' + Gamestack.ObjectFeatureMap[x][y]); GClassFeatures[y].featureSymbols = GClassFeatures[y].featureSymbols || []; for (var z in Gamestack.ObjectFeatureMap[y]) { GClassFeatures[y].featureSymbols.push(new Gamestack.FeatureSymbol(Gamestack.ObjectFeatureMap[y][z])); GClassFeatures[y].featureSymbols.hasKey = function(key) { for (var x = 0; x &lt; this.length; x++) { if (typeof this[x].key !== 'string') continue; if (this[x].key.indexOf('@') == -1) console.error('feature-keys must contain @'); // console.log('eval key:' + this[x].key.split('@')[1]); if (this[x].key.split('@')[1] == key) return true; } return false; }; GClassFeatures[y].featureSymbols.hasSymbol = function(symbol) { for (var x in this) { if (this[x].symbol == symbol) return true; } return false; }; // console.info('adding feature-symbol:' + Gamestack.ObjectFeatureMap[x][y]); } } else { console.error('Gamestack.ObjectFeatureMap: member by name of ' + x + ' does not exist as member of Gamestack'); } } console.info('FEATURES:', GClassFeatures); for (var x in Gamestack.FeatureInjectors) { // console.log(Gamestack.FeatureInjectors[x]); var props = Larva.getProtoFuncs(Gamestack.FeatureInjectors[x]); for (var y = 0; y &lt; props.length; y++) { console.log(x + \":\" + props[y]); for (var z in GClassFeatures) if (GClassFeatures[z] &amp;&amp; GClassFeatures[z].featureSymbols.hasKey(props[y])) { Gamestack.FeatureInjectors[x][props[y]](Gamestack[z].prototype, args); } } } }; class CssFeatures { colored(obj){ obj.Color = function(c) { this.color = c; return this; } } color_transition(min_color, max_color){ this.min_color = min_color; this.max_color = max_color; return this; } text(obj){ obj.Text = function(value) { this.text = value; return this; } } opaque(obj){ obj.Opacity = function(o){ this.opacity = o; return this; } } }; class DataFunctions { data(obj){ obj.Name = function(n) { this.name = n; return this; }; obj.Description = function(d){ this.description = d; return this; }; obj.Context = function(c) { this.context = c; return this; }; } } /*************************** GeometryFeatures: A functional dependency injector injects properties and functions according to Symbols **************************/ class VectorFunctions { constructor() { this.name = 'VectorFunctionals'; } collideable(obj) { obj.collision_callback = function() {}; obj.onCollide = args.onCollide || function(collideables, callback) { if (typeof(collideables) == 'function') { callback = collideables; } this.collision_callback = callback || function() {}; }; } spatial(obj) { obj.Size = function(x, y, z) { if (typeof(x) == 'object') this.size = new Gamestack.Vector(x); else if (!isNaN(x) &amp;&amp; !isNaN(y)) //has minimum of numeric x and y this.size = new Gamestack.Vector(x, y, z); else //use x accross the vector this.size = new Gamestack.Vector(x, x, x); return this; }; obj.Pos = function(x, y, z) { if (typeof(x) == 'object') this.position = new Gamestack.Vector(x); else if (!isNaN(x) &amp;&amp; !isNaN(y)) //has minimum of numeric x and y this.position = new Gamestack.Vector(x, y, z); else //use x accross the vector this.position = new Gamestack.Vector(x, x, x); return this; }; obj.Rot = function(x, y, z) { if (typeof(x) == 'object') this.rotation = new Gamestack.Vector(x); else if (!isNaN(x) &amp;&amp; !isNaN(y)) //has minimum of numeric x and y this.rotation = new Gamestack.Vector(x, y, z); else //use x accross the vector this.rotation = new Gamestack.Vector(x, x, x); return this; }; obj.Position = obj.Pos; obj.Rotate = obj.Rot; obj.Rotation = obj.Rot; } posable(obj) { obj.Pos = function(x, y, z) { if (typeof(x) == 'object') this.position = new Gamestack.Vector(x); else if (!isNaN(x) &amp;&amp; !isNaN(y)) //has minimum of numeric x and y this.position = new Gamestack.Vector(x, y, z); else //use x accross the vector this.position = new Gamestack.Vector(x, x, x); return this; }; obj.Position = obj.Pos; } sizeable(obj) { obj.Size = function(x, y, z) { if (typeof(x) == 'object') this.size = new Gamestack.Vector(x); else if (!isNaN(x) &amp;&amp; !isNaN(y)) //has minimum of numeric x and y this.size = new Gamestack.Vector(x, y, z); else //use x accross the vector this.size = new Gamestack.Vector(x, x, x); return this; }; obj.Position = obj.Pos; } rotable(obj) { obj.Rot = function(x, y, z) { if (typeof(x) == 'object') this.rotation = new Gamestack.Vector(x); else if (!isNaN(x) &amp;&amp; !isNaN(y)) //has minimum of numeric x and y this.rotation = new Gamestack.Vector(x, y, z); else //use x accross the vector this.rotation = new Gamestack.Vector(x, x, x); if (typeof this.Transpose == 'function') { this.Transpose(); } return this; }; obj.Rotate = obj.Rot; obj.Rotation = obj.Rot; } minable(obj) { obj.Min = function(x, y, z) { if (typeof(x) == 'object') this.min = new Gamestack.Vector(x); else if (!isNaN(x) &amp;&amp; !isNaN(y)) //has minimum of numeric x and y this.min = new Gamestack.Vector(x, y, z); else //use x accross the vector this.min = new Gamestack.Vector(x, x, x); return this; }; obj.Minimum = obj.Min; } maxable(obj) { obj.Max = function(x, y, z) { if (typeof(x) == 'object') this.max = new Gamestack.Vector(x); else if (!isNaN(x) &amp;&amp; !isNaN(y)) //has minimum of numeric x and y this.max = new Gamestack.Vector(x, y, z); else //use x accross the vector this.max = new Gamestack.Vector(x, x, x); return this; }; obj.Maximum = obj.Max; } boundable(obj) { this.minable(obj); this.maxable(obj); } selftransposable(obj) { //apply the transposition obj.Transpose = function(rotation, position) { this.rotation = new Gamestack.Vector(rotation || this.rotation); this.position = new Gamestack.Vector(position || this.position); //TODO: Modify this trig function and its call below to an optional 3D rotation for (var x = 0; x &lt; this.points.length; x++) { var p = this.points[x]; var np = Gamestack.Trig.rotate_from_xy(0, 0, p.x, p.y, this.rotation.x); this.points[x] = this.position.add(np); } return this; }; } pointarrayflippable(obj) { //apply the transposition obj.FlipX = function() { var middle = Math.floor(this.points.length / 2); //account for FlipX with length of --odd number var x, y; for (x = this.points.length - 1, y = 0; x &gt; middle, y &lt; middle; x--, y++) { var p1 = this.points[x], p2 = this.points[y]; [p1.x, p2.x] = [p2.x, p1.x]; } return this; }; //apply the transposition obj.FlipY = function() { var middle = Math.floor(this.points.length / 2); //account for FlipX with length of --odd number var x, y; for (x = this.points.length - 1, y = 0; x &gt; middle, y &lt; middle; x--, y++) { var p1 = this.points[x], p2 = this.points[y]; [p1.y, p2.y] = [p2.y, p1.y]; } return this; }; } informable(obj, args) { obj.name = Gamestack.getArg(args, 'name', \"__ObjectName\"); obj.description = Gamestack.getArg(args, 'description', false); obj.group = Gamestack.getArg(args, 'group', 'one'); } tweenable(obj) { obj.curve_string = obj.curve_string || \"linearNone\"; obj.setTweenCurve = function(c) { c = c || \"linear_none\"; var cps = c.split('_'); //alert(cps); var s1 = cps[0].toLowerCase(), s2 = cps[1].toLowerCase(); var curve = TWEEN.Easing.Linear.None; obj.curve_string = 'linear_none' Gamestack.each(TWEEN.Easing, function(ix, easing) { Gamestack.each(TWEEN.Easing[ix], function(iy, easeType) { if (ix == s1 &amp;&amp; iy == s2) { // alert('setting curve'); curve = TWEEN.Easing[ix][iy]; obj.curve_string = ix + '_' + iy; } }); }); obj.curve = curve; return curve; }; obj.curvesToArray = function() { var c = []; Gamestack.each(TWEEN.Easing, function(ix, easing) { Gamestack.each(easing, function(iy, easeType) { if (['in', 'out', 'inout', 'none'].indexOf(iy.toLowerCase()) &gt;= 0) { c.push(ix + \"_\" + iy); } }); }); return c; } } }; Gamestack.FeatureInjectors.CssFeatures = new CssFeatures(); Gamestack.FeatureInjectors.VectorFunctions = new VectorFunctions(); Gamestack.FeatureInjectors.DataFunctions = new DataFunctions(); ;let Larva = { DEV:false, //Display message in console info: function(arg1, arg2) { if(!this.DEV) return; console.info(arg1, arg2); }, log:function(arg1, arg2){ if(!this.DEV) return; console.log(arg1, arg2); }, /* ERRORS always show */ error:function(arg1, arg2){ if(!this.DEV) return; console.error(arg1, arg2); }, warn:function(arg1, arg2){ if(!this.DEV) return; console.error(arg1, arg2); }, //obj is number or becomes fallback number: function(number, fallback = 0) { number = typeof(number) == 'number' ? number : fallback; }, //obj is string or becomes fallback string: function(string, fallback) { string = typeof(string) == 'string' ? string : fallback; }, //obj is Array or becomes wrapped in [] as [obj] arrayWrap: function(obj) { if (obj instanceof Array) return obj; else return [obj]; }, //obj or array-of-objects are ALL truthy (return=true) or not (return=false) allDefined: function(obj_all) { var list = this.arrayWrap(obj_all); var failed = false; for (var x in list) { if (!list[x]) { failed = true; console.error('Failed to define @ Larva.Define()'); } }; return !failed; }, //getPreferredPropertyByKey(): uses the property[key] if present, if not returns same property passed in getPreferredPropertyByKey:function(property, key, warning){ if(property.hasOwnProperty(key)) { this.warn(warning); return property[key]; } else { return property; } }, //obj's are all of type or return false psuedoTypeCheck: function(obj, psuedotype = [], throwing = false) //obj is type or is encapsulated into type { var list = this.arrayWrap(obj); for (var x in list) { if (typeof(list[x]) !== psuedotype &amp;&amp; !(list[x] instanceof psuedotype)) { if (!throwing) return console.error(error); else throw new console.error(error); } } return true; }, getAllFuncs: function(obj) { return Object.getOwnPropertyNames(obj).filter(function (p) { return typeof obj[p] === 'function'; }); }, getProtoFuncs: function(obj) { return Object.getOwnPropertyNames(obj.__proto__).filter(function (p) { return typeof obj[p] === 'function'; }); }, truthOrDie:function(list, exitMessage) //All members of Array are truthy or the program exits with Error() { function findError(obj, error) { return obj || new Error(error) }; for (var x in list) { let e = findError(list[x], exitMessage); if (e instanceof Error) { console.Error(e); } }; }, truthyPropsPerArray: function(obj, propKeys, kill) { var list = this.arrayWrap(obj), keys = this.arrayWrap(propKeys); let error = \"The required truthy property has non-truthy value.\"; function findError(obj, prop) { return obj[prop] || new Error(error) }; var failed = false; for (var x in list) { for (var y in keys) { let e = findError(list[x], keys[y]); if (e instanceof Error) { failed = true; if (kill) throw e; else console.error(e); } } } return !failed; }, typeArgsExtract: function(obj, type) //obj is type or is each-converted into type { if (obj instanceof type) { return obj; } else { obj = [obj]; } return obj; }, typeOrHalt: function(obj, type) //obj is type or error is thrown { if (obj instanceof type) { return obj; } else { throw new Error('object not of required type'); console.info(obj); console.info(type + \"?\"); } return obj; }, typeOrError: function(obj, type) //obj is type or error is logged, execution continues { if (obj instanceof type) { return obj; } else { console.log(new Error('object not of required type')); console.info(obj); console.info(type + \"?\"); } return obj; }, check:function(object, propKey, propValue) { if(!object[propKey]) { object[propKey] = propValue; } } }; ;let Logger = { options: { error: true, info: true, warning: true }, log: function (message) { }, interlog: function (message, loopDuration) { }, info: function (message) { }, warning: function (message) { }, error: function (message) { } } ; let E = function(msg, halt){ //basic Error console.error(msg); }; let L = function(str1, str2){ console.log(str1, str2); }; let I = function(str1, str2){ console.info(str1, str2); }; let R = function(obj, callback){ for(var x in obj) { callback(obj[x]); } }; ;/** * Creates Gamestack.js Canvas: The canvas-renderer for Gamestack games. @description This Canvas library handles the low-level drawing of Gamestack.Animation objects on HTML5Canvas. -Draws Sprites according to their rotation, size, and properties. * @returns {CanvasLib} a CanvasLib object. */ (function() { console.log('CanvasStack class... creating'); class GamestackCanvas { constructor() { this.__levelMaker = false; //draw is synonymous w/ drawSprite this.draw = this.draw_object; } isStopped() { return Gamestack.stopDraw || false; } arc(p1, p2, options = {}) { if (this.isStopped()) return; var ctx = Gamestack.game_windows[0].ctx; ctx.strokeStyle = 'aqua'; ctx.beginPath(); ctx.arc(p1.x, p1.y, p2.x, p2.y, Math.PI * 2, true); ctx.stroke(); } draw_image_frame(image, framePos, frameSize, position, size, rotation, canvasContext, flipX, flipY, origin) { if (this.isStopped()) return; var fx = framePos.x, fy = framePos.y, fw = frameSize.x, fh = frameSize.y, x = position.x, y = position.y, width = size.x, height = size.y; //save canvas state before draw canvasContext.save(); //degrees rotation: var deg = Math.round(rotation); deg = deg % 360; var rad = deg * Math.PI / 180; //Set the origin to the center of the image canvasContext.translate(x, y); canvasContext.rotate(rad); //Rotate the canvas around the origin canvasContext.translate(0, canvasContext.width); if (flipX) { canvasContext.scale(-1, 1); } else { } if (flipY) { canvasContext.scale(1, -1); } else { } origin = origin || new Gamestack.Vector(width / 2, height / 2); //draw the image canvasContext.drawImage(image, fx, fy, fw, fh, origin.x * (-1), origin.y * (-1), width, height); //reset the canvas canvasContext.restore(); } draw_data(x, y, w, h, data, ctx) { if (this.isStopped()) return; ctx.putImageData(data, x, y, 0, 0, w, h); } } Gamestack.Canvas = new GamestackCanvas(); Gamestack.GamestackCanvas = GamestackCanvas; class OffscreenCanvasRendering { constructor(psuedoImage) { I('StashToCanvas():'); this.htmlImage = psuedoImage.domElement || psuedoImage; this.testCanvas = document.createElement(\"CANVAS\"); this.testCtx = this.testCanvas.getContext(\"2d\"); this.testCanvas.width = this.htmlImage.width; this.testCanvas.height = this.htmlImage.height; this.testCanvas.style.zIndex = '9999'; this.testCtx.drawImage(this.htmlImage, 0, 0); return { canvas: this.testCanvas, ctx: this.testCtx } } }; Gamestack.OffscreenCanvasRendering = OffscreenCanvasRendering; })(); ;if (typeof JSON.decycle !== 'function') { JSON.decycle = function decycle(object) { \"use strict\"; var objects = [], // Keep a reference to each unique object or array paths = []; // Keep the path to each unique object or array return (function derez(value, path) { var i, // The loop counter name, // Property name nu; // The new object or array switch (typeof value) { case 'object': if (!value) { return null; } for (i = 0; i &lt; objects.length; i += 1) { if (objects[i] === value) { return {$ref: paths[i]}; } } // Otherwise, accumulate the unique value and its path. objects.push(value); paths.push(path); // If it is an array, replicate the array. if (Object.prototype.toString.apply(value) === '[object Array]') { nu = []; for (i = 0; i &lt; value.length; i += 1) { nu[i] = derez(value[i], path + '[' + i + ']'); } } else { // If it is an object, replicate the object. nu = {}; for (name in value) { if (Object.prototype.hasOwnProperty.call(value, name)) { nu[name] = derez(value[name], path + '[' + JSON.stringify(name) + ']'); } } } return nu; case 'number': case 'string': case 'boolean': return value; } }(object, '$')); }; } if (typeof JSON.retrocycle !== 'function') { JSON.retrocycle = function retrocycle($) { \"use strict\"; var px = /^\\$(?:\\[(?:\\d?|\\\"(?:[^\\\\\\\"\\u0000-\\u001f]|\\\\([\\\\\\\"\\/bfnrt]|u[0-9a-zA-Z]{4}))*\\\")\\])*$/; (function rez(value) { var i, item, name, path; if (value &amp;&amp; typeof value === 'object') { if (Object.prototype.toString.apply(value) === '[object Array]') { for (i = 0; i &lt; value.length; i += 1) { item = value[i]; if (item &amp;&amp; typeof item === 'object') { path = item.$ref; if (typeof path === 'string' &amp;&amp; px.test(path)) { value[i] = eval(path); } else { rez(item); } } } } else { for (name in value) { if (typeof value[name] === 'object') { item = value[name]; if (item) { path = item.$ref; if (typeof path === 'string' &amp;&amp; px.test(path)) { value[name] = eval(path); } else { rez(item); } } } } } } }($)); return $; }; } var json_stringify = JSON.stringify; JSON.stringify = function(object, arg2, arg3) { var clean_object = JSON.decycle(object); return json_stringify(clean_object, arg2, arg3); }; var json_parse = JSON.parse; JSON.parse = function(object, arg2, arg3){ var retro_object = JSON.retrocycle(object); return json_parse(retro_object); }; ;/** * @author mrdoob / http://mrdoob.com/ */ /*************** * * @ignore * * *****************/ var Stats = function () { var mode = 0; var container = document.createElement( 'div' ); container.style.cssText = 'position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000'; container.addEventListener( 'click', function ( event ) { event.preventDefault(); showPanel( ++ mode % container.children.length ); }, false ); // function addPanel( panel ) { container.appendChild( panel.dom ); return panel; } function showPanel( id ) { for ( var i = 0; i &lt; container.children.length; i ++ ) { container.children[ i ].style.display = i === id ? 'block' : 'none'; } mode = id; } // var beginTime = ( performance || Date ).now(), prevTime = beginTime, frames = 0; var fpsPanel = addPanel( new Stats.Panel( 'FPS', '#0ff', '#002' ) ); var msPanel = addPanel( new Stats.Panel( 'MS', '#0f0', '#020' ) ); if ( self.performance &amp;&amp; self.performance.memory ) { var memPanel = addPanel( new Stats.Panel( 'MB', '#f08', '#201' ) ); } showPanel( 0 ); return { REVISION: 16, dom: container, addPanel: addPanel, showPanel: showPanel, begin: function () { beginTime = ( performance || Date ).now(); }, end: function () { frames ++; var time = ( performance || Date ).now(); msPanel.update( time - beginTime, 200 ); if ( time &gt;= prevTime + 1000 ) { fpsPanel.update( ( frames * 1000 ) / ( time - prevTime ), 100 ); prevTime = time; frames = 0; if ( memPanel ) { var memory = performance.memory; memPanel.update( memory.usedJSHeapSize / 1048576, memory.jsHeapSizeLimit / 1048576 ); } } return time; }, update: function () { beginTime = this.end(); }, // Backwards Compatibility domElement: container, setMode: showPanel }; }; Stats.Panel = function ( name, fg, bg ) { var min = Infinity, max = 0, round = Math.round; var PR = round( window.devicePixelRatio || 1 ); var WIDTH = 80 * PR, HEIGHT = 48 * PR, TEXT_X = 3 * PR, TEXT_Y = 2 * PR, GRAPH_X = 3 * PR, GRAPH_Y = 15 * PR, GRAPH_WIDTH = 74 * PR, GRAPH_HEIGHT = 30 * PR; var canvas = document.createElement( 'canvas' ); canvas.width = WIDTH; canvas.height = HEIGHT; canvas.style.cssText = 'width:80px;height:48px'; var context = canvas.getContext( '2d' ); context.font = 'bold ' + ( 9 * PR ) + 'px Helvetica,Arial,sans-serif'; context.textBaseline = 'top'; context.fillStyle = bg; context.fillRect( 0, 0, WIDTH, HEIGHT ); context.fillStyle = fg; context.fillText( name, TEXT_X, TEXT_Y ); context.fillRect( GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT ); context.fillStyle = bg; context.globalAlpha = 0.9; context.fillRect( GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT ); return { dom: canvas, update: function ( value, maxValue ) { min = Math.min( min, value ); max = Math.max( max, value ); context.fillStyle = bg; context.globalAlpha = 1; context.fillRect( 0, 0, WIDTH, GRAPH_Y ); context.fillStyle = fg; context.fillText( round( value ) + ' ' + name + ' (' + round( min ) + '-' + round( max ) + ')', TEXT_X, TEXT_Y ); context.drawImage( canvas, GRAPH_X + PR, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT, GRAPH_X, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT ); context.fillRect( GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, GRAPH_HEIGHT ); context.fillStyle = bg; context.globalAlpha = 0.9; context.fillRect( GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, round( ( 1 - ( value / maxValue ) ) * GRAPH_HEIGHT ) ); } }; }; ;/** * Tween.js - Licensed under the MIT license * https://github.com/tweenjs/tween.js * ---------------------------------------------- * * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors. * Thank you all, you're awesome! */ /* * * @ignore * * */ var TWEEN = TWEEN || (function () { var _tweens = []; return { getAll: function () { return _tweens; }, removeAll: function () { _tweens = []; }, add: function (tween) { _tweens.push(tween); }, remove: function (tween) { var i = _tweens.indexOf(tween); if (i !== -1) { _tweens.splice(i, 1); } }, update: function (time, preserve) { if (_tweens.length === 0) { return false; } var i = 0; time = time !== undefined ? time : TWEEN.now(); while (i &lt; _tweens.length) { if (_tweens[i].update(time) || preserve) { i++; } else { _tweens.splice(i, 1); } } return true; } }; })(); //removed polyfill TWEEN.now = Date.now; TWEEN.Tween = function (object) { var _object = object; var _valuesStart = {}; var _valuesEnd = {}; var _valuesStartRepeat = {}; var _duration = 1000; var _repeat = 0; var _repeatDelayTime; var _yoyo = false; var _isPlaying = false; var _reversed = false; var _delayTime = 0; var _startTime = null; var _easingFunction = TWEEN.Easing.Linear.None; var _interpolationFunction = TWEEN.Interpolation.Linear; var _chainedTweens = []; var _onStartCallback = null; var _onStartCallbackFired = false; var _onUpdateCallback = null; var _onCompleteCallback = null; var _onStopCallback = null; // Set all starting values present on the target object for (var field in object) { _valuesStart[field] = parseFloat(object[field], 10); } this.to = function (properties, duration) { if (duration !== undefined) { _duration = duration; } _valuesEnd = properties; return this; }; this.start = function (time) { TWEEN.add(this); _isPlaying = true; _onStartCallbackFired = false; _startTime = time !== undefined ? time : TWEEN.now(); _startTime += _delayTime; for (var property in _valuesEnd) { // Check if an Array was provided as property value if (_valuesEnd[property] instanceof Array) { if (_valuesEnd[property].length === 0) { continue; } // Create a local copy of the Array with the start value at the front _valuesEnd[property] = [_object[property]].concat(_valuesEnd[property]); } // If `to()` specifies a property that doesn't exist in the source object, // we should not set that property in the object if (_object[property] === undefined) { continue; } _valuesStart[property] = _object[property]; if ((_valuesStart[property] instanceof Array) === false) { _valuesStart[property] *= 1.0; // Ensures we're using numbers, not strings } _valuesStartRepeat[property] = _valuesStart[property] || 0; } return this; }; this.stop = function () { if (!_isPlaying) { return this; } TWEEN.remove(this); _isPlaying = false; if (_onStopCallback !== null) { _onStopCallback.call(_object, _object); } this.stopChainedTweens(); return this; }; this.end = function () { this.update(_startTime + _duration); return this; }; this.stopChainedTweens = function () { for (var i = 0, numChainedTweens = _chainedTweens.length; i &lt; numChainedTweens; i++) { _chainedTweens[i].stop(); } }; this.delay = function (amount) { _delayTime = amount; return this; }; this.repeat = function (times) { _repeat = times; return this; }; this.repeatDelay = function (amount) { _repeatDelayTime = amount; return this; }; this.yoyo = function (yoyo) { _yoyo = yoyo; return this; }; this.easing = function (easing) { _easingFunction = easing; return this; }; this.interpolation = function (interpolation) { _interpolationFunction = interpolation; return this; }; this.chain = function () { _chainedTweens = arguments; return this; }; this.onStart = function (callback) { _onStartCallback = callback; return this; }; this.onUpdate = function (callback) { _onUpdateCallback = callback; return this; }; this.onComplete = function (callback) { _onCompleteCallback = callback; return this; }; this.onStop = function (callback) { _onStopCallback = callback; return this; }; this.update = function (time) { var property; var elapsed; var value; if (time &lt; _startTime) { return true; } if (_onStartCallbackFired === false) { if (_onStartCallback !== null) { _onStartCallback.call(_object, _object); } _onStartCallbackFired = true; } elapsed = (time - _startTime) / _duration; elapsed = elapsed &gt; 1 ? 1 : elapsed; value = _easingFunction(elapsed); for (property in _valuesEnd) { // Don't update properties that do not exist in the source object if (_valuesStart[property] === undefined) { continue; } var start = _valuesStart[property] || 0; var end = _valuesEnd[property]; if (end instanceof Array) { _object[property] = _interpolationFunction(end, value); } else { // Parses relative end values with start as base (e.g.: +10, -3) if (typeof (end) === 'string') { if (end.charAt(0) === '+' || end.charAt(0) === '-') { end = start + parseFloat(end, 10); } else { end = parseFloat(end, 10); } } // Protect against non numeric properties. if (typeof (end) === 'number') { _object[property] = start + (end - start) * value; } } } if (_onUpdateCallback !== null) { _onUpdateCallback.call(_object, value); } if (elapsed === 1) { if (_repeat &gt; 0) { if (isFinite(_repeat)) { _repeat--; } // Reassign starting values, restart by making startTime = now for (property in _valuesStartRepeat) { if (typeof (_valuesEnd[property]) === 'string') { _valuesStartRepeat[property] = _valuesStartRepeat[property] + parseFloat(_valuesEnd[property], 10); } if (_yoyo) { var tmp = _valuesStartRepeat[property]; _valuesStartRepeat[property] = _valuesEnd[property]; _valuesEnd[property] = tmp; } _valuesStart[property] = _valuesStartRepeat[property]; } if (_yoyo) { _reversed = !_reversed; } if (_repeatDelayTime !== undefined) { _startTime = time + _repeatDelayTime; } else { _startTime = time + _delayTime; } return true; } else { if (_onCompleteCallback !== null) { _onCompleteCallback.call(_object, _object); } for (var i = 0, numChainedTweens = _chainedTweens.length; i &lt; numChainedTweens; i++) { // Make the chained tweens start exactly at the time they should, // even if the `update()` method was called way past the duration of the tween _chainedTweens[i].start(_startTime + _duration); } return false; } } return true; }; }; TWEEN.Easing = { Linear: { None: function (k) { return k; } }, Quadratic: { In: function (k) { return k * k; }, Out: function (k) { return k * (2 - k); }, InOut: function (k) { if ((k *= 2) &lt; 1) { return 0.5 * k * k; } return - 0.5 * (--k * (k - 2) - 1); } }, Cubic: { In: function (k) { return k * k * k; }, Out: function (k) { return --k * k * k + 1; }, InOut: function (k) { if ((k *= 2) &lt; 1) { return 0.5 * k * k * k; } return 0.5 * ((k -= 2) * k * k + 2); } }, Quartic: { In: function (k) { return k * k * k * k; }, Out: function (k) { return 1 - (--k * k * k * k); }, InOut: function (k) { if ((k *= 2) &lt; 1) { return 0.5 * k * k * k * k; } return - 0.5 * ((k -= 2) * k * k * k - 2); } }, Quintic: { In: function (k) { return k * k * k * k * k; }, Out: function (k) { return --k * k * k * k * k + 1; }, InOut: function (k) { if ((k *= 2) &lt; 1) { return 0.5 * k * k * k * k * k; } return 0.5 * ((k -= 2) * k * k * k * k + 2); } }, Sinusoidal: { In: function (k) { return 1 - Math.cos(k * Math.PI / 2); }, Out: function (k) { return Math.sin(k * Math.PI / 2); }, InOut: function (k) { return 0.5 * (1 - Math.cos(Math.PI * k)); } }, Exponential: { In: function (k) { return k === 0 ? 0 : Math.pow(1024, k - 1); }, Out: function (k) { return k === 1 ? 1 : 1 - Math.pow(2, - 10 * k); }, InOut: function (k) { if (k === 0) { return 0; } if (k === 1) { return 1; } if ((k *= 2) &lt; 1) { return 0.5 * Math.pow(1024, k - 1); } return 0.5 * (- Math.pow(2, - 10 * (k - 1)) + 2); } }, Circular: { In: function (k) { return 1 - Math.sqrt(1 - k * k); }, Out: function (k) { return Math.sqrt(1 - (--k * k)); }, InOut: function (k) { if ((k *= 2) &lt; 1) { return - 0.5 * (Math.sqrt(1 - k * k) - 1); } return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1); } }, Elastic: { In: function (k) { if (k === 0) { return 0; } if (k === 1) { return 1; } return -Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI); }, Out: function (k) { if (k === 0) { return 0; } if (k === 1) { return 1; } return Math.pow(2, -10 * k) * Math.sin((k - 0.1) * 5 * Math.PI) + 1; }, InOut: function (k) { if (k === 0) { return 0; } if (k === 1) { return 1; } k *= 2; if (k &lt; 1) { return -0.5 * Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI); } return 0.5 * Math.pow(2, -10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI) + 1; } }, Back: { In: function (k) { var s = 1.70158; return k * k * ((s + 1) * k - s); }, Out: function (k) { var s = 1.70158; return --k * k * ((s + 1) * k + s) + 1; }, InOut: function (k) { var s = 1.70158 * 1.525; if ((k *= 2) &lt; 1) { return 0.5 * (k * k * ((s + 1) * k - s)); } return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2); } }, Bounce: { In: function (k) { return 1 - TWEEN.Easing.Bounce.Out(1 - k); }, Out: function (k) { if (k &lt; (1 / 2.75)) { return 7.5625 * k * k; } else if (k &lt; (2 / 2.75)) { return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75; } else if (k &lt; (2.5 / 2.75)) { return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375; } else { return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375; } }, InOut: function (k) { if (k &lt; 0.5) { return TWEEN.Easing.Bounce.In(k * 2) * 0.5; } return TWEEN.Easing.Bounce.Out(k * 2 - 1) * 0.5 + 0.5; } } }; TWEEN.Interpolation = { Linear: function (v, k) { var m = v.length - 1; var f = m * k; var i = Math.floor(f); var fn = TWEEN.Interpolation.Utils.Linear; if (k &lt; 0) { return fn(v[0], v[1], f); } if (k &gt; 1) { return fn(v[m], v[m - 1], m - f); } return fn(v[i], v[i + 1 &gt; m ? m : i + 1], f - i); }, Bezier: function (v, k) { var b = 0; var n = v.length - 1; var pw = Math.pow; var bn = TWEEN.Interpolation.Utils.Bernstein; for (var i = 0; i &lt;= n; i++) { b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i); } return b; }, CatmullRom: function (v, k) { var m = v.length - 1; var f = m * k; var i = Math.floor(f); var fn = TWEEN.Interpolation.Utils.CatmullRom; if (v[0] === v[m]) { if (k &lt; 0) { i = Math.floor(f = m * (1 + k)); } return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i); } else { if (k &lt; 0) { return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]); } if (k &gt; 1) { return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]); } return fn(v[i ? i - 1 : 0], v[i], v[m &lt; i + 1 ? m : i + 1], v[m &lt; i + 2 ? m : i + 2], f - i); } }, Utils: { Linear: function (p0, p1, t) { return (p1 - p0) * t + p0; }, Bernstein: function (n, i) { var fc = TWEEN.Interpolation.Utils.Factorial; return fc(n) / fc(i) / fc(n - i); }, Factorial: (function () { var a = [1]; return function (n) { var s = 1; if (a[n]) { return a[n]; } for (var i = n; i &gt; 1; i--) { s *= i; } a[n] = s; return s; }; })(), CatmullRom: function (p0, p1, p2, p3, t) { var v0 = (p2 - p0) * 0.5; var v1 = (p3 - p1) * 0.5; var t2 = t * t; var t3 = t * t2; return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (- 3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1; } } }; //Attach to the global Gamestack object /*************** * * @memberOf Gamestack * * *****************/ Gamestack.TWEEN = TWEEN; /* // UMD (Universal Module Definition) (function (root) { if (typeof define === 'function' &amp;&amp; define.amd) { // AMD define([], function () { return TWEEN; }); } else if (typeof module !== 'undefined' &amp;&amp; typeof exports === 'object') { // Node.js module.exports = TWEEN; } else if (root !== undefined) { // Global variable root.TWEEN = TWEEN; } })(this); */ ; //Call Gamestack.FeatureInject:: Gamestack.FeatureInject(); // UMD (Universal Module Definition) (function (root) { if (typeof define === 'function' &amp;&amp; define.amd) { // AMD define([], function () { return Gamestack; }); } else if (typeof module !== 'undefined' &amp;&amp; typeof exports === 'object') { // Node.js module.exports = Gamestack; } else if (root !== undefined) { // Global variable root.Gamestack = Gamestack; } })(this);  Search results Close Documentation generated by JSDoc 3.5.5 "},"index.html":{"id":"index.html","title":"Home","body":" Home - Documentation GamestackJs Documentation ClassesCameraGameWindowgetCanvascenterGridStyleonUpdateupdateonBeforeDrawonAfterDrawSizeaddBackgroundremoveanimatestartWebGL#getCanvasWebGL#centerWebGL#GridStyleWebGL#onUpdateWebGL#updateWebGL#onBeforeDrawWebGL#onAfterDrawWebGL#SizeWebGL#addWebGL#BackgroundWebGL#removeWebGL#animateWebGL#startRectangleVectorFrameBoundsRenderableGameImageVectorsubaddmultabsdivroundfloorceilnegequalstrig_distance_xyrandomizerotationalSpeedPointangleBetweenWebGLInputEventKeyboardEventGamepadEventBoolEventOnCallFrameSoundAnimationFrame#createColorMapinit_singleFrameonRunonCompleteReverseFramesSingleFramegetCurrentPixelMapsetFramerunanimateengageSpriteonLoadCloneAddLifeinitaddInitializerget_idcreate_idgetSizeByMaxSingleFrameLifeSpanLifeisDeaddieonScreenupdatedef_updateonUpdatetravelLineOnLoophasPixelCollisionhasBoxCollisionshootsubspriteanimateonAnimationCompleteaccelYaccelXdecelYdecelXacceldecelSmoothMotionSmoothRotatecenteroverlap_xoverlap_ycollide_stop_xcollide_stopcollide_stop_toprestoreFromSpriteArray#onLoadSpritesShotProjectileonComplete Spritebox.js is a javascript library for 2D games. Includes: javascript solutions to common 2D game problems examples and documentation to show how the Spritebox library works Spritebox.js features: javascript game-objects, 2D-graphics, gamepad-input, events, sounds, and behaviors Sprites, Animations, Sounds, Particles gamepad-input events and function-overrides Demos: Spritebox.js main-page, examples and documentationLicensing: Spritebox.js main-page, examples and documentation Spritebox.js is open-source under the MIT License. Game-developers who use Spritebox should purchase our LICENSE FOR SPRITEBOX DEVELOPMENT.  Search results Close Documentation generated by JSDoc 3.5.5 "},"Camera.html":{"id":"Camera.html","title":"Camera","body":" Camera - Documentation GamestackJs Documentation ClassesCameraGameWindowgetCanvascenterGridStyleonUpdateupdateonBeforeDrawonAfterDrawSizeaddBackgroundremoveanimatestartWebGL#getCanvasWebGL#centerWebGL#GridStyleWebGL#onUpdateWebGL#updateWebGL#onBeforeDrawWebGL#onAfterDrawWebGL#SizeWebGL#addWebGL#BackgroundWebGL#removeWebGL#animateWebGL#startRectangleVectorFrameBoundsRenderableGameImageVectorsubaddmultabsdivroundfloorceilnegequalstrig_distance_xyrandomizerotationalSpeedPointangleBetweenWebGLInputEventKeyboardEventGamepadEventBoolEventOnCallFrameSoundAnimationFrame#createColorMapinit_singleFrameonRunonCompleteReverseFramesSingleFramegetCurrentPixelMapsetFramerunanimateengageSpriteonLoadCloneAddLifeinitaddInitializerget_idcreate_idgetSizeByMaxSingleFrameLifeSpanLifeisDeaddieonScreenupdatedef_updateonUpdatetravelLineOnLoophasPixelCollisionhasBoxCollisionshootsubspriteanimateonAnimationCompleteaccelYaccelXdecelYdecelXacceldecelSmoothMotionSmoothRotatecenteroverlap_xoverlap_ycollide_stop_xcollide_stopcollide_stop_toprestoreFromSpriteArray#onLoadSpritesShotProjectileonComplete Camera Camera Creates an instance of 2d-camera to be applied as the viewing-point for a GameWindow. Constructor new Camera(x, y, z)  {Camera} Parameters: Name Type Description x number an optional position-x y number an optional position-y z number an optional position-z Source: spritebox.js, line 1953  Search results Close Documentation generated by JSDoc 3.5.5 "},"GameWindow.html":{"id":"GameWindow.html","title":"GameWindow","body":" GameWindow - Documentation GamestackJs Documentation ClassesCameraGameWindowgetCanvascenterGridStyleonUpdateupdateonBeforeDrawonAfterDrawSizeaddBackgroundremoveanimatestartWebGL#getCanvasWebGL#centerWebGL#GridStyleWebGL#onUpdateWebGL#updateWebGL#onBeforeDrawWebGL#onAfterDrawWebGL#SizeWebGL#addWebGL#BackgroundWebGL#removeWebGL#animateWebGL#startRectangleVectorFrameBoundsRenderableGameImageVectorsubaddmultabsdivroundfloorceilnegequalstrig_distance_xyrandomizerotationalSpeedPointangleBetweenWebGLInputEventKeyboardEventGamepadEventBoolEventOnCallFrameSoundAnimationFrame#createColorMapinit_singleFrameonRunonCompleteReverseFramesSingleFramegetCurrentPixelMapsetFramerunanimateengageSpriteonLoadCloneAddLifeinitaddInitializerget_idcreate_idgetSizeByMaxSingleFrameLifeSpanLifeisDeaddieonScreenupdatedef_updateonUpdatetravelLineOnLoophasPixelCollisionhasBoxCollisionshootsubspriteanimateonAnimationCompleteaccelYaccelXdecelYdecelXacceldecelSmoothMotionSmoothRotatecenteroverlap_xoverlap_ycollide_stop_xcollide_stopcollide_stop_toprestoreFromSpriteArray#onLoadSpritesShotProjectileonComplete GameWindow GameWindow Creates a GameWindow object. Constructor new GameWindow(canvas, drawables)  {GameWindow} Parameters: Name Type Description canvas Object the canvas element for this gameWindow. --GameWindow's if not supplied, the constructor will create a full-screen canvas, if a canvas. drawables Object the drawable objects to be drawn. --Drawables can also be added after constructor call. Source: spritebox.js, line 2057 Methods getCanvas() returns the gameWindow.canvas property, an HTMLCanvasElement Source: spritebox.js, line 2141 center() returns a vector(x, y) showing the center of the GameWindow Source: spritebox.js, line 2154 GridStyle() creates an array of gridUnits Source: spritebox.js, line 2175 onUpdate() adds an update to the GameWindow:: update to be called every 20 milliseconds Source: spritebox.js, line 2233 update() the main update for the GameWindow:: called automatically after call of GameWindow.start() or GameWindow.animate() Source: spritebox.js, line 2246 onBeforeDraw() adds a call before the GameWindow draw() Source: spritebox.js, line 2321 onAfterDraw() adds a call after the GameWindow draw() Source: spritebox.js, line 2345 Size(w, h) sets the size of the GameWindow Parameters: Name Type Description w integer the width of the GameWindow h integer the HEIGHT of the GameWindow Source: spritebox.js, line 2371 add(obj, onBottom) adds an object to the GameWindow Parameters: Name Type Description obj Object the object to be added (Sprite) onBottom Boolean if true, adds to the bottom of layer-stack in GameWindow Source: spritebox.js, line 2412 Background(c) set background-color of GameWindow Parameters: Name Type Description c string the new background-color for GameWindow Source: spritebox.js, line 2471 remove(obj) removes an object from the GameWindow Parameters: Name Type Description obj Object the object to be removed (Sprite) Source: spritebox.js, line 2488 animate(time) begins the animation-loop of GameWindow. Parameters: Name Type Description time number optional time parameter for usage with Tween Source: spritebox.js, line 2506 start() begins the animation-loop of GameWindow, with performance Stats shown on-screen Source: spritebox.js, line 2549 (static) WebGL#getCanvas() returns the gameWindow.canvas property, an HTMLCanvasElement Source: spritebox.js, line 3535 (static) WebGL#center() returns a vector(x, y) showing the center of the GameWindow Source: spritebox.js, line 3548 (static) WebGL#GridStyle() creates an array of gridUnits Source: spritebox.js, line 3562 (static) WebGL#onUpdate() adds an update to the GameWindow:: update to be called every 20 milliseconds Source: spritebox.js, line 3620 (static) WebGL#update() the main update for the GameWindow:: called automatically after call of GameWindow.start() or GameWindow.animate() Source: spritebox.js, line 3633 (static) WebGL#onBeforeDraw() adds a call before the GameWindow draw() Source: spritebox.js, line 3708 (static) WebGL#onAfterDraw() adds a call after the GameWindow draw() Source: spritebox.js, line 3732 (static) WebGL#Size(w, h) sets the size of the GameWindow Parameters: Name Type Description w integer the width of the GameWindow h integer the HEIGHT of the GameWindow Source: spritebox.js, line 3758 (static) WebGL#add(obj, onBottom) adds an object to the GameWindow Parameters: Name Type Description obj Object the object to be added (Sprite) onBottom Boolean if true, adds to the bottom of layer-stack in GameWindow Source: spritebox.js, line 3799 (static) WebGL#Background(c) set background-color of GameWindow Parameters: Name Type Description c string the new background-color for GameWindow Source: spritebox.js, line 3858 (static) WebGL#remove(obj) removes an object from the GameWindow Parameters: Name Type Description obj Object the object to be removed (Sprite) Source: spritebox.js, line 3875 (static) WebGL#animate(time) begins the animation-loop of GameWindow. Parameters: Name Type Description time number optional time parameter for usage with Tween Source: spritebox.js, line 3893 (static) WebGL#start() begins the animation-loop of GameWindow, with performance Stats shown on-screen Source: spritebox.js, line 3937  Search results Close Documentation generated by JSDoc 3.5.5 "},"Rectangle.html":{"id":"Rectangle.html","title":"Rectangle","body":" Rectangle - Documentation GamestackJs Documentation ClassesCameraGameWindowgetCanvascenterGridStyleonUpdateupdateonBeforeDrawonAfterDrawSizeaddBackgroundremoveanimatestartWebGL#getCanvasWebGL#centerWebGL#GridStyleWebGL#onUpdateWebGL#updateWebGL#onBeforeDrawWebGL#onAfterDrawWebGL#SizeWebGL#addWebGL#BackgroundWebGL#removeWebGL#animateWebGL#startRectangleVectorFrameBoundsRenderableGameImageVectorsubaddmultabsdivroundfloorceilnegequalstrig_distance_xyrandomizerotationalSpeedPointangleBetweenWebGLInputEventKeyboardEventGamepadEventBoolEventOnCallFrameSoundAnimationFrame#createColorMapinit_singleFrameonRunonCompleteReverseFramesSingleFramegetCurrentPixelMapsetFramerunanimateengageSpriteonLoadCloneAddLifeinitaddInitializerget_idcreate_idgetSizeByMaxSingleFrameLifeSpanLifeisDeaddieonScreenupdatedef_updateonUpdatetravelLineOnLoophasPixelCollisionhasBoxCollisionshootsubspriteanimateonAnimationCompleteaccelYaccelXdecelYdecelXacceldecelSmoothMotionSmoothRotatecenteroverlap_xoverlap_ycollide_stop_xcollide_stopcollide_stop_toprestoreFromSpriteArray#onLoadSpritesShotProjectileonComplete Rectangle Rectangle Creates an instance of Rectangle. Constructor new Rectangle(min, max)  {Rectangle} Parameters: Name Type Description min Gamestack.Vector the minimum vector point (x,y) max Gamestack.Vector the maximum vector point (x,y) Source: spritebox.js, line 2642  Search results Close Documentation generated by JSDoc 3.5.5 "},"VectorFrameBounds.html":{"id":"VectorFrameBounds.html","title":"VectorFrameBounds","body":" VectorFrameBounds - Documentation GamestackJs Documentation ClassesCameraGameWindowgetCanvascenterGridStyleonUpdateupdateonBeforeDrawonAfterDrawSizeaddBackgroundremoveanimatestartWebGL#getCanvasWebGL#centerWebGL#GridStyleWebGL#onUpdateWebGL#updateWebGL#onBeforeDrawWebGL#onAfterDrawWebGL#SizeWebGL#addWebGL#BackgroundWebGL#removeWebGL#animateWebGL#startRectangleVectorFrameBoundsRenderableGameImageVectorsubaddmultabsdivroundfloorceilnegequalstrig_distance_xyrandomizerotationalSpeedPointangleBetweenWebGLInputEventKeyboardEventGamepadEventBoolEventOnCallFrameSoundAnimationFrame#createColorMapinit_singleFrameonRunonCompleteReverseFramesSingleFramegetCurrentPixelMapsetFramerunanimateengageSpriteonLoadCloneAddLifeinitaddInitializerget_idcreate_idgetSizeByMaxSingleFrameLifeSpanLifeisDeaddieonScreenupdatedef_updateonUpdatetravelLineOnLoophasPixelCollisionhasBoxCollisionshootsubspriteanimateonAnimationCompleteaccelYaccelXdecelYdecelXacceldecelSmoothMotionSmoothRotatecenteroverlap_xoverlap_ycollide_stop_xcollide_stopcollide_stop_toprestoreFromSpriteArray#onLoadSpritesShotProjectileonComplete VectorFrameBounds VectorFrameBounds Takes the min and max vectors plus termPoint ('termination-point'), returns VectorFrameBounds *use this to define the bounds of an Animation object. Constructor new VectorFrameBounds(min, max, termPointopt)  {VectorFrameBounds} Parameters: Name Type Attributes Description min Vector the minimum vector point (x,y) max Vector the maximum vector point (x,y) termPoint Vector &lt;optional&gt; the optional termination vector point (x,y) : defaults to the value of 'max' -While a min and max Gamestack.Vector(x,y) will describe the grid-size of Animation frames, the termPoint will indicate the last frame on-grid for this set of frames --Animation may stop early on the 'grid') Source: spritebox.js, line 2677  Search results Close Documentation generated by JSDoc 3.5.5 "},"Renderable.html":{"id":"Renderable.html","title":"Renderable","body":" Renderable - Documentation GamestackJs Documentation ClassesCameraGameWindowgetCanvascenterGridStyleonUpdateupdateonBeforeDrawonAfterDrawSizeaddBackgroundremoveanimatestartWebGL#getCanvasWebGL#centerWebGL#GridStyleWebGL#onUpdateWebGL#updateWebGL#onBeforeDrawWebGL#onAfterDrawWebGL#SizeWebGL#addWebGL#BackgroundWebGL#removeWebGL#animateWebGL#startRectangleVectorFrameBoundsRenderableGameImageVectorsubaddmultabsdivroundfloorceilnegequalstrig_distance_xyrandomizerotationalSpeedPointangleBetweenWebGLInputEventKeyboardEventGamepadEventBoolEventOnCallFrameSoundAnimationFrame#createColorMapinit_singleFrameonRunonCompleteReverseFramesSingleFramegetCurrentPixelMapsetFramerunanimateengageSpriteonLoadCloneAddLifeinitaddInitializerget_idcreate_idgetSizeByMaxSingleFrameLifeSpanLifeisDeaddieonScreenupdatedef_updateonUpdatetravelLineOnLoophasPixelCollisionhasBoxCollisionshootsubspriteanimateonAnimationCompleteaccelYaccelXdecelYdecelXacceldecelSmoothMotionSmoothRotatecenteroverlap_xoverlap_ycollide_stop_xcollide_stopcollide_stop_toprestoreFromSpriteArray#onLoadSpritesShotProjectileonComplete Renderable Renderable Renderable : consistent base-type for graphic-objects Constructor new Renderable(args)  {Renderable} Parameters: Name Type Description args Object the object of arguments Source: spritebox.js, line 2722  Search results Close Documentation generated by JSDoc 3.5.5 "},"GameImage.html":{"id":"GameImage.html","title":"GameImage","body":" GameImage - Documentation GamestackJs Documentation ClassesCameraGameWindowgetCanvascenterGridStyleonUpdateupdateonBeforeDrawonAfterDrawSizeaddBackgroundremoveanimatestartWebGL#getCanvasWebGL#centerWebGL#GridStyleWebGL#onUpdateWebGL#updateWebGL#onBeforeDrawWebGL#onAfterDrawWebGL#SizeWebGL#addWebGL#BackgroundWebGL#removeWebGL#animateWebGL#startRectangleVectorFrameBoundsRenderableGameImageVectorsubaddmultabsdivroundfloorceilnegequalstrig_distance_xyrandomizerotationalSpeedPointangleBetweenWebGLInputEventKeyboardEventGamepadEventBoolEventOnCallFrameSoundAnimationFrame#createColorMapinit_singleFrameonRunonCompleteReverseFramesSingleFramegetCurrentPixelMapsetFramerunanimateengageSpriteonLoadCloneAddLifeinitaddInitializerget_idcreate_idgetSizeByMaxSingleFrameLifeSpanLifeisDeaddieonScreenupdatedef_updateonUpdatetravelLineOnLoophasPixelCollisionhasBoxCollisionshootsubspriteanimateonAnimationCompleteaccelYaccelXdecelYdecelXacceldecelSmoothMotionSmoothRotatecenteroverlap_xoverlap_ycollide_stop_xcollide_stopcollide_stop_toprestoreFromSpriteArray#onLoadSpritesShotProjectileonComplete GameImage GameImage A game-image object based on HTMLImage element. Creates GameImage, attaches gameImage.domElement --an instance of HTMLImageElement Constructor new GameImage(src)  {GameImage} Parameters: Name Type Description src string the sourcePath of the image-file. Source: spritebox.js, line 2737  Search results Close Documentation generated by JSDoc 3.5.5 "},"Vector.html":{"id":"Vector.html","title":"Vector","body":" Vector - Documentation GamestackJs Documentation ClassesCameraGameWindowgetCanvascenterGridStyleonUpdateupdateonBeforeDrawonAfterDrawSizeaddBackgroundremoveanimatestartWebGL#getCanvasWebGL#centerWebGL#GridStyleWebGL#onUpdateWebGL#updateWebGL#onBeforeDrawWebGL#onAfterDrawWebGL#SizeWebGL#addWebGL#BackgroundWebGL#removeWebGL#animateWebGL#startRectangleVectorFrameBoundsRenderableGameImageVectorsubaddmultabsdivroundfloorceilnegequalstrig_distance_xyrandomizerotationalSpeedPointangleBetweenWebGLInputEventKeyboardEventGamepadEventBoolEventOnCallFrameSoundAnimationFrame#createColorMapinit_singleFrameonRunonCompleteReverseFramesSingleFramegetCurrentPixelMapsetFramerunanimateengageSpriteonLoadCloneAddLifeinitaddInitializerget_idcreate_idgetSizeByMaxSingleFrameLifeSpanLifeisDeaddieonScreenupdatedef_updateonUpdatetravelLineOnLoophasPixelCollisionhasBoxCollisionshootsubspriteanimateonAnimationCompleteaccelYaccelXdecelYdecelXacceldecelSmoothMotionSmoothRotatecenteroverlap_xoverlap_ycollide_stop_xcollide_stopcollide_stop_toprestoreFromSpriteArray#onLoadSpritesShotProjectileonComplete Vector Vector Creates a Vector object with x, y, and z properties. Vector-2D requires only x and y args --new Vector(10, 10) For Vector-3D, use x,y, and z --new Vector(10, 10, 10) Pass an existing Vector as the sole argument in order to copy that Vector to a new instance Constructor new Vector(x, y, z, r)  {Vector} Parameters: Name Type Description x number the x coordinate y number the y coordinate z number the optional z coordinate r number the optional r value Source: spritebox.js, line 3074 Methods sub(v) Subtracts another Vector from this vector and returns a vector for the resulting difference. Parameters: Name Type Description v Vector the vector to be subtracted from this vector Source: spritebox.js, line 3130 add(v) Adds another Vector to this vector and returns a vector for the resulting sum. Parameters: Name Type Description v Vector the vector to be added to this vector Source: spritebox.js, line 3151 mult(v) Multiplies another Vector by this vector and returns a vector for the resulting product. Parameters: Name Type Description v Vector the vector that this vector will by muliplied by Source: spritebox.js, line 3172 abs(v) Gets vector of absolute values. Parameters: Name Type Description v Vector the absolute vector Source: spritebox.js, line 3193 div(v) Divides another Vector by this vector and returns a vector for the resulting quotient. Parameters: Name Type Description v Vector the vector for this vector to be divided by Source: spritebox.js, line 3207 round()  {Vector} Rounds this vector to the nearest set of whole numbers and returns the result. Source: spritebox.js, line 3227 floor()  {Vector} Floors this vector to the nearest set of whole numbers and returns the result (subtractive-only, an x of 1.7 becomes 1) Source: spritebox.js, line 3240 ceil()  {Vector} Ceils this vector to the nearest set of whole numbers and returns the result (additive-only, an x of 1.2 becomes 2) Source: spritebox.js, line 3253 neg()  {Vector} Creates new vector, with the negated x,y,z values (-x-y-z), returns the resulting vector Source: spritebox.js, line 3266 equals()  {boolean} An equals-test for vectors. Returns true OR false. Source: spritebox.js, line 3278 trig_distance_xy()  {number} Gets the specific distance between this and the argument-vector. --applies to x and y of two vectors. Returns a single number. Source: spritebox.js, line 3291 randomize()  {Vector} Returns a vector-multiple: the original-size, multiplied by a random between the minFloat and maxFloat arguments. Source: spritebox.js, line 3318 rotationalSpeedPoint(rotation, speed)  {Vector} Returns a speed vector, based on rotation. Parameters: Name Type Description rotation number in degrees, 0-360 speed number the level of speed to apply, default being 1 Source: spritebox.js, line 3336 angleBetween(p1, p2)  {number} Returns the right-handed angle of degrees between two two position-vectors. Parameters: Name Type Description p1 Vector the 1st vector-argument p2 Vector the 2nd vector-argument Source: spritebox.js, line 3361  Search results Close Documentation generated by JSDoc 3.5.5 "},"WebGL.html":{"id":"WebGL.html","title":"WebGL","body":" WebGL - Documentation GamestackJs Documentation ClassesCameraGameWindowgetCanvascenterGridStyleonUpdateupdateonBeforeDrawonAfterDrawSizeaddBackgroundremoveanimatestartWebGL#getCanvasWebGL#centerWebGL#GridStyleWebGL#onUpdateWebGL#updateWebGL#onBeforeDrawWebGL#onAfterDrawWebGL#SizeWebGL#addWebGL#BackgroundWebGL#removeWebGL#animateWebGL#startRectangleVectorFrameBoundsRenderableGameImageVectorsubaddmultabsdivroundfloorceilnegequalstrig_distance_xyrandomizerotationalSpeedPointangleBetweenWebGLInputEventKeyboardEventGamepadEventBoolEventOnCallFrameSoundAnimationFrame#createColorMapinit_singleFrameonRunonCompleteReverseFramesSingleFramegetCurrentPixelMapsetFramerunanimateengageSpriteonLoadCloneAddLifeinitaddInitializerget_idcreate_idgetSizeByMaxSingleFrameLifeSpanLifeisDeaddieonScreenupdatedef_updateonUpdatetravelLineOnLoophasPixelCollisionhasBoxCollisionshootsubspriteanimateonAnimationCompleteaccelYaccelXdecelYdecelXacceldecelSmoothMotionSmoothRotatecenteroverlap_xoverlap_ycollide_stop_xcollide_stopcollide_stop_toprestoreFromSpriteArray#onLoadSpritesShotProjectileonComplete WebGL WebGL Creates a GameWindow object. Constructor new WebGL(canvas, drawables)  {GameWindow} Parameters: Name Type Description canvas Object the canvas element for this gameWindow. --GameWindow's if not supplied, the constructor will create a full-screen canvas, if a canvas. drawables Object the drawable objects to be drawn. --Drawables can also be added after constructor call. Source: spritebox.js, line 3450  Search results Close Documentation generated by JSDoc 3.5.5 "},"InputEvent.html":{"id":"InputEvent.html","title":"InputEvent","body":" InputEvent - Documentation GamestackJs Documentation ClassesCameraGameWindowgetCanvascenterGridStyleonUpdateupdateonBeforeDrawonAfterDrawSizeaddBackgroundremoveanimatestartWebGL#getCanvasWebGL#centerWebGL#GridStyleWebGL#onUpdateWebGL#updateWebGL#onBeforeDrawWebGL#onAfterDrawWebGL#SizeWebGL#addWebGL#BackgroundWebGL#removeWebGL#animateWebGL#startRectangleVectorFrameBoundsRenderableGameImageVectorsubaddmultabsdivroundfloorceilnegequalstrig_distance_xyrandomizerotationalSpeedPointangleBetweenWebGLInputEventKeyboardEventGamepadEventBoolEventOnCallFrameSoundAnimationFrame#createColorMapinit_singleFrameonRunonCompleteReverseFramesSingleFramegetCurrentPixelMapsetFramerunanimateengageSpriteonLoadCloneAddLifeinitaddInitializerget_idcreate_idgetSizeByMaxSingleFrameLifeSpanLifeisDeaddieonScreenupdatedef_updateonUpdatetravelLineOnLoophasPixelCollisionhasBoxCollisionshootsubspriteanimateonAnimationCompleteaccelYaccelXdecelYdecelXacceldecelSmoothMotionSmoothRotatecenteroverlap_xoverlap_ycollide_stop_xcollide_stopcollide_stop_toprestoreFromSpriteArray#onLoadSpritesShotProjectileonComplete InputEvent InputEvent Creates an instance of InputEvent Gamestack.InputEvent runs a callback function when a specified input is triggered Instead of calling Constructor new InputEvent(args)  {Gamestack.InputEvent} Parameters: Name Type Description args Object object of arguments Properties Name Type Description btnix number the index of controller-button to be applied gpix number the index of pc-gamepad --the 1st gamepad will have index 0 stickix number the controller-stick-index to be applied keys Array array of strings for keys to be applied callback function the function to call when InputEvent is triggered Source: spritebox.js, line 4374  Search results Close Documentation generated by JSDoc 3.5.5 "},"KeyboardEvent.html":{"id":"KeyboardEvent.html","title":"KeyboardEvent","body":" KeyboardEvent - Documentation GamestackJs Documentation ClassesCameraGameWindowgetCanvascenterGridStyleonUpdateupdateonBeforeDrawonAfterDrawSizeaddBackgroundremoveanimatestartWebGL#getCanvasWebGL#centerWebGL#GridStyleWebGL#onUpdateWebGL#updateWebGL#onBeforeDrawWebGL#onAfterDrawWebGL#SizeWebGL#addWebGL#BackgroundWebGL#removeWebGL#animateWebGL#startRectangleVectorFrameBoundsRenderableGameImageVectorsubaddmultabsdivroundfloorceilnegequalstrig_distance_xyrandomizerotationalSpeedPointangleBetweenWebGLInputEventKeyboardEventGamepadEventBoolEventOnCallFrameSoundAnimationFrame#createColorMapinit_singleFrameonRunonCompleteReverseFramesSingleFramegetCurrentPixelMapsetFramerunanimateengageSpriteonLoadCloneAddLifeinitaddInitializerget_idcreate_idgetSizeByMaxSingleFrameLifeSpanLifeisDeaddieonScreenupdatedef_updateonUpdatetravelLineOnLoophasPixelCollisionhasBoxCollisionshootsubspriteanimateonAnimationCompleteaccelYaccelXdecelYdecelXacceldecelSmoothMotionSmoothRotatecenteroverlap_xoverlap_ycollide_stop_xcollide_stopcollide_stop_toprestoreFromSpriteArray#onLoadSpritesShotProjectileonComplete KeyboardEvent KeyboardEvent new KeyboardEvent(keys, callback)  {Gamestack.KeyboardEvent} Parameters: Name Type Description keys Array | string the Array of keys or single string-key for this event callback function the callback-function to be called when this event is triggered Source: spritebox.js, line 4433 Extends InputEvent  Search results Close Documentation generated by JSDoc 3.5.5 "},"GamepadEvent.html":{"id":"GamepadEvent.html","title":"GamepadEvent","body":" GamepadEvent - Documentation GamestackJs Documentation ClassesCameraGameWindowgetCanvascenterGridStyleonUpdateupdateonBeforeDrawonAfterDrawSizeaddBackgroundremoveanimatestartWebGL#getCanvasWebGL#centerWebGL#GridStyleWebGL#onUpdateWebGL#updateWebGL#onBeforeDrawWebGL#onAfterDrawWebGL#SizeWebGL#addWebGL#BackgroundWebGL#removeWebGL#animateWebGL#startRectangleVectorFrameBoundsRenderableGameImageVectorsubaddmultabsdivroundfloorceilnegequalstrig_distance_xyrandomizerotationalSpeedPointangleBetweenWebGLInputEventKeyboardEventGamepadEventBoolEventOnCallFrameSoundAnimationFrame#createColorMapinit_singleFrameonRunonCompleteReverseFramesSingleFramegetCurrentPixelMapsetFramerunanimateengageSpriteonLoadCloneAddLifeinitaddInitializerget_idcreate_idgetSizeByMaxSingleFrameLifeSpanLifeisDeaddieonScreenupdatedef_updateonUpdatetravelLineOnLoophasPixelCollisionhasBoxCollisionshootsubspriteanimateonAnimationCompleteaccelYaccelXdecelYdecelXacceldecelSmoothMotionSmoothRotatecenteroverlap_xoverlap_ycollide_stop_xcollide_stopcollide_stop_toprestoreFromSpriteArray#onLoadSpritesShotProjectileonComplete GamepadEvent GamepadEvent new GamepadEvent(gamepadKeys, callback)  {Gamestack.GamepadEvent} Parameters: Name Type Description gamepadKeys Array | string the Array of gamepadKeys or single string-key, representing gamepad-buttons or gamepad-sticks for this event callback function the callback-function to be called when this event is triggered Source: spritebox.js, line 4490 Extends InputEvent  Search results Close Documentation generated by JSDoc 3.5.5 "},"BoolEvent.html":{"id":"BoolEvent.html","title":"BoolEvent","body":" BoolEvent - Documentation GamestackJs Documentation ClassesCameraGameWindowgetCanvascenterGridStyleonUpdateupdateonBeforeDrawonAfterDrawSizeaddBackgroundremoveanimatestartWebGL#getCanvasWebGL#centerWebGL#GridStyleWebGL#onUpdateWebGL#updateWebGL#onBeforeDrawWebGL#onAfterDrawWebGL#SizeWebGL#addWebGL#BackgroundWebGL#removeWebGL#animateWebGL#startRectangleVectorFrameBoundsRenderableGameImageVectorsubaddmultabsdivroundfloorceilnegequalstrig_distance_xyrandomizerotationalSpeedPointangleBetweenWebGLInputEventKeyboardEventGamepadEventBoolEventOnCallFrameSoundAnimationFrame#createColorMapinit_singleFrameonRunonCompleteReverseFramesSingleFramegetCurrentPixelMapsetFramerunanimateengageSpriteonLoadCloneAddLifeinitaddInitializerget_idcreate_idgetSizeByMaxSingleFrameLifeSpanLifeisDeaddieonScreenupdatedef_updateonUpdatetravelLineOnLoophasPixelCollisionhasBoxCollisionshootsubspriteanimateonAnimationCompleteaccelYaccelXdecelYdecelXacceldecelSmoothMotionSmoothRotatecenteroverlap_xoverlap_ycollide_stop_xcollide_stopcollide_stop_toprestoreFromSpriteArray#onLoadSpritesShotProjectileonComplete BoolEvent BoolEvent returns BoolEvent --allows code to run whenever a conditional-function returns true Constructor new BoolEvent(onBool, call)  {BoolEvent} Parameters: Name Type Description onBool onBool the function to be tested each update call call the function to be called when onBool returns true; Source: spritebox.js, line 4595 Methods On(boolFunction)  {BoolEvent} applies a boolFunction to be tested for true each update Parameters: Name Type Description boolFunction boolFunction the function to be tested each update --replaces the value of boolEvent.onBool Source: spritebox.js, line 4620 Call(callbackFunction)  {BoolEvent} applies a callback to be called whenever the onBool function returns true Parameters: Name Type Description callbackFunction callbackFunction the function to be called --replaces the value of boolEvent.callback Source: spritebox.js, line 4637  Search results Close Documentation generated by JSDoc 3.5.5 "},"Frame.html":{"id":"Frame.html","title":"Frame","body":" Frame - Documentation GamestackJs Documentation ClassesCameraGameWindowgetCanvascenterGridStyleonUpdateupdateonBeforeDrawonAfterDrawSizeaddBackgroundremoveanimatestartWebGL#getCanvasWebGL#centerWebGL#GridStyleWebGL#onUpdateWebGL#updateWebGL#onBeforeDrawWebGL#onAfterDrawWebGL#SizeWebGL#addWebGL#BackgroundWebGL#removeWebGL#animateWebGL#startRectangleVectorFrameBoundsRenderableGameImageVectorsubaddmultabsdivroundfloorceilnegequalstrig_distance_xyrandomizerotationalSpeedPointangleBetweenWebGLInputEventKeyboardEventGamepadEventBoolEventOnCallFrameSoundAnimationFrame#createColorMapinit_singleFrameonRunonCompleteReverseFramesSingleFramegetCurrentPixelMapsetFramerunanimateengageSpriteonLoadCloneAddLifeinitaddInitializerget_idcreate_idgetSizeByMaxSingleFrameLifeSpanLifeisDeaddieonScreenupdatedef_updateonUpdatetravelLineOnLoophasPixelCollisionhasBoxCollisionshootsubspriteanimateonAnimationCompleteaccelYaccelXdecelYdecelXacceldecelSmoothMotionSmoothRotatecenteroverlap_xoverlap_ycollide_stop_xcollide_stopcollide_stop_toprestoreFromSpriteArray#onLoadSpritesShotProjectileonComplete Frame Frame Creates an instance of Frame Gamestack.Frame is called automatically by Gamestack.Sprite and Gamestack.Animation. Gamestack.Frame does not take arguments. It is instantiated, then initilized with chainable function-calls. Constructor new Frame()  {Frame} Source: spritebox.js, line 4683 Example var selected_frame = new Gamestack.Frame().Image(gameImage).Size(frameSizeVector);  Search results Close Documentation generated by JSDoc 3.5.5 "},"Animation.html":{"id":"Animation.html","title":"Animation","body":" Animation - Documentation GamestackJs Documentation ClassesCameraGameWindowgetCanvascenterGridStyleonUpdateupdateonBeforeDrawonAfterDrawSizeaddBackgroundremoveanimatestartWebGL#getCanvasWebGL#centerWebGL#GridStyleWebGL#onUpdateWebGL#updateWebGL#onBeforeDrawWebGL#onAfterDrawWebGL#SizeWebGL#addWebGL#BackgroundWebGL#removeWebGL#animateWebGL#startRectangleVectorFrameBoundsRenderableGameImageVectorsubaddmultabsdivroundfloorceilnegequalstrig_distance_xyrandomizerotationalSpeedPointangleBetweenWebGLInputEventKeyboardEventGamepadEventBoolEventOnCallFrameSoundAnimationFrame#createColorMapinit_singleFrameonRunonCompleteReverseFramesSingleFramegetCurrentPixelMapsetFramerunanimateengageSpriteonLoadCloneAddLifeinitaddInitializerget_idcreate_idgetSizeByMaxSingleFrameLifeSpanLifeisDeaddieonScreenupdatedef_updateonUpdatetravelLineOnLoophasPixelCollisionhasBoxCollisionshootsubspriteanimateonAnimationCompleteaccelYaccelXdecelYdecelXacceldecelSmoothMotionSmoothRotatecenteroverlap_xoverlap_ycollide_stop_xcollide_stopcollide_stop_toprestoreFromSpriteArray#onLoadSpritesShotProjectileonComplete Animation Animation Creates an instance of Animation with one or more Frames. Constructor new Animation(srcopt, gameImageopt, animeopt)  {Animation} Parameters: Name Type Attributes Description src string &lt;optional&gt; the src/file-path for this Animation gameImage GameImage | HTMLImageElement &lt;optional&gt; the existing GameImage to be applied anime Object | Animation &lt;optional&gt; the existing Animation-data to be returned as fully unique instance Source: spritebox.js, line 5692 Examples //constructor call: Creates a single-frame Animation from src var singleFrameAnime = new Animation('directory/myFile.png'); //constructor call with chainable function-calls: Creates multi-frame Animation from src, then sets properties with chainable-function-calls. var multiFrameAnime = new Gamestack.Animation('../images/characters/full/spaceman1.png') //constructor is called .FrameSize(130, 130) .FrameBounds(new Gamestack.Vector(9, 0), new Gamestack.Vector(23, 0), new Gamestack.Vector(23, 0)) .Seesaw() //The Animation will play back-and-forth repeatedly (cycle through frames forwards, then backwards and so on. .Duration(900); //Animation lasts 900 millis OR just under 1 second Methods (static) Frame#createColorMap(unitDimen) Creates and returns a ColorMap for this animation, allowing opacity-based pixel-collision. Parameters: Name Type Description unitDimen number a Colormap grid-unit-size --A larger unitDimen decreases accuracy, and results in faster-processing. Source: spritebox.js, line 4824 init_singleFrame() sets this Animation to a single-frame-animation, from existing image Source: spritebox.js, line 5832 onRun() Provides a function to be called whenever this Animation starts. Function should run every time the Animation reaches frame-index 0 Source: spritebox.js, line 5865 onComplete() Provides a function to be called whenever this Animation completes. Function should run every time the Animation reaches it's last frame-index. Source: spritebox.js, line 5881 ReverseFrames() Reverses all frames of the animation. Frames are then expected to run backwards. Source: spritebox.js, line 5962 SingleFrame(frameSize) Declares the animation a a single frame / full-image. Parameters: Name Type Description frameSize Vector optional size param Source: spritebox.js, line 5976 getCurrentPixelMap() Returns the existing ColorMap for this animation. Source: spritebox.js, line 6140 setFrame(ix) Sets the frame to a specific array-index. Parameters: Name Type Description ix number the frame-index to apply. Source: spritebox.js, line 6178 run() Applies a continuous animation. Use this in parent-sprite's update if continuous animation is required. Also works as a single call at any time during game-update. Source: spritebox.js, line 6208 animate() animate():: same as run() Source: spritebox.js, line 6235 engage(duration) Engages, or updates the animation for a one full frame-cycle. Parameters: Name Type Description duration number the number of milliseconds the animation should take. Source: spritebox.js, line 6263  Search results Close Documentation generated by JSDoc 3.5.5 "},"Sound.html":{"id":"Sound.html","title":"Sound","body":" Sound - Documentation GamestackJs Documentation ClassesCameraGameWindowgetCanvascenterGridStyleonUpdateupdateonBeforeDrawonAfterDrawSizeaddBackgroundremoveanimatestartWebGL#getCanvasWebGL#centerWebGL#GridStyleWebGL#onUpdateWebGL#updateWebGL#onBeforeDrawWebGL#onAfterDrawWebGL#SizeWebGL#addWebGL#BackgroundWebGL#removeWebGL#animateWebGL#startRectangleVectorFrameBoundsRenderableGameImageVectorsubaddmultabsdivroundfloorceilnegequalstrig_distance_xyrandomizerotationalSpeedPointangleBetweenWebGLInputEventKeyboardEventGamepadEventBoolEventOnCallFrameSoundAnimationFrame#createColorMapinit_singleFrameonRunonCompleteReverseFramesSingleFramegetCurrentPixelMapsetFramerunanimateengageSpriteonLoadCloneAddLifeinitaddInitializerget_idcreate_idgetSizeByMaxSingleFrameLifeSpanLifeisDeaddieonScreenupdatedef_updateonUpdatetravelLineOnLoophasPixelCollisionhasBoxCollisionshootsubspriteanimateonAnimationCompleteaccelYaccelXdecelYdecelXacceldecelSmoothMotionSmoothRotatecenteroverlap_xoverlap_ycollide_stop_xcollide_stopcollide_stop_toprestoreFromSpriteArray#onLoadSpritesShotProjectileonComplete Sound Sound Creates a Sound instance. Implements HTML5-Audio object --DevTODO : complete docs for the Sound class Constructor new Sound(src)  {Sound} Parameters: Name Type Description src string the source-path of the targeted sound-file Source: spritebox.js, line 5300  Search results Close Documentation generated by JSDoc 3.5.5 "},"Sprite.html":{"id":"Sprite.html","title":"Sprite","body":" Sprite - Documentation GamestackJs Documentation ClassesCameraGameWindowgetCanvascenterGridStyleonUpdateupdateonBeforeDrawonAfterDrawSizeaddBackgroundremoveanimatestartWebGL#getCanvasWebGL#centerWebGL#GridStyleWebGL#onUpdateWebGL#updateWebGL#onBeforeDrawWebGL#onAfterDrawWebGL#SizeWebGL#addWebGL#BackgroundWebGL#removeWebGL#animateWebGL#startRectangleVectorFrameBoundsRenderableGameImageVectorsubaddmultabsdivroundfloorceilnegequalstrig_distance_xyrandomizerotationalSpeedPointangleBetweenWebGLInputEventKeyboardEventGamepadEventBoolEventOnCallFrameSoundAnimationFrame#createColorMapinit_singleFrameonRunonCompleteReverseFramesSingleFramegetCurrentPixelMapsetFramerunanimateengageSpriteonLoadCloneAddLifeinitaddInitializerget_idcreate_idgetSizeByMaxSingleFrameLifeSpanLifeisDeaddieonScreenupdatedef_updateonUpdatetravelLineOnLoophasPixelCollisionhasBoxCollisionshootsubspriteanimateonAnimationCompleteaccelYaccelXdecelYdecelXacceldecelSmoothMotionSmoothRotatecenteroverlap_xoverlap_ycollide_stop_xcollide_stopcollide_stop_toprestoreFromSpriteArray#onLoadSpritesShotProjectileonComplete Sprite Sprite Creates an instance of Sprite. Gamestack.Sprite is a container for 2D Animations. -apply Sprite class to create behaviors for an entire 2d-game-entity. Sprites hold reference to their-own Animations and Sounds. Constructor new Sprite(srcopt, animeopt)  {Sprite} Parameters: Name Type Attributes Description src string &lt;optional&gt; the srcPath for the image of the Sprite anime scale &lt;optional&gt; the scale to be applied to width + height of the image Source: spritebox.js, line 6347 Example //Create Sprite using Sprite constructor, with one src argument Methods onLoad(f) runs a function for the onload event of this sprite's image Parameters: Name Type Description f function the function to be called on load Source: spritebox.js, line 6409 Clone(object) Clones a sprite from existing data Parameters: Name Type Description object Object the data to be cloned Source: spritebox.js, line 6571 Add(object) adds an animation to the sprites Parameters: Name Type Description object Object the animation to be added Source: spritebox.js, line 6705 Life(v)  {Sprite} pass argument v to the sprite.life property. Parameters: Name Type Description v number number of render-updates that this Sprite will last. --update occurs 60+ times per second, or less, depending on performance Source: spritebox.js, line 6800 init() initializes sprites. triggers all functions previously passed to the addInitializer function. Use this function when a sprite, instantiated from json-data, carries initializers. --This feature is built for the purpose of data-persistence. --sprites from json-file may carry behaviors onto the scene. Source: spritebox.js, line 6818 addInitializer(fun) extends the init function. Parameters: Name Type Description fun function the function to be passed into the init function of the sprite Source: spritebox.js, line 6830 get_id()  {string} returns the 'id' property of the sprite Source: spritebox.js, line 6852 create_id()  {string} creates a unique string id property for the sprite. Source: spritebox.js, line 6881 getSizeByMax(mx, my)  {Vector} returns a maximum scaled size, according to max dimensions of width and height Parameters: Name Type Description mx number the maximum size.x for the returned size my number the maximum size.y for the returned size Source: spritebox.js, line 6896 SingleFrame() set the 'selected_animation' property to a single-frame-animation Source: spritebox.js, line 6943 LifeSpan() set the 'life' property to a specified integer Source: spritebox.js, line 6986 Life() set the 'life' property to a specified integer Source: spritebox.js, line 6996 isDead() tells if sprite has been taken out of game Source: spritebox.js, line 7007 die() sets life to 0, then ending the sprite Source: spritebox.js, line 7020 onScreen(w, h)  {boolean} indicates if any portion of the sprite is within screen bounds --uses Gamestack.WIDTH, Gamestack.HEIGHT OR any w,h arguments passed to this method Parameters: Name Type Description w number optional screen-width argument, defaults to Gamestack.WIDTH h number optional screen-height argument, defaults to Gamestack.HEIGHT Source: spritebox.js, line 7037 update() the main update for the sprite --applied recursively by GameWindow after gameWindow.start is called Source: spritebox.js, line 7074 def_update() Automatically updates various speed and rotational properties for the Sprite() Source: spritebox.js, line 7100 Examples // applies a constant speed property --speed is Vector(x, y) mySprite.rot_speed = new Gamestack.Vector(3); //def_update() will run automatically with the gamestack update. The above sprite will rotate at a constant speed of 3. // how to reset to nothing:: if automatic speed updates are undesired, replace the def_update() function with a 'do nothing' function. mySprite.def_update = function() { //do nothing }; onUpdate(fun) extends the update of this sprite with a new function to be called during the update --repeated calls will extend, (not replace) the update --Allows multiple extensions of the update Parameters: Name Type Description fun function the function to be appended to sprite.update @example // extend the behavior of your sprite mySprite.onUpdate(function(spr) console.log('extended update'); //runs automatically whenever sprite.update runs }); Source: spritebox.js, line 7203 travelLineOnLoop() the sprite travels one line in a looping motion --useful for traveling Square, Circle, or other enclosed Lines. #Dev-todo:MORE ON THIS Source: spritebox.js, line 7301 hasPixelCollision(spr)  {boolean} returns a true || false value for immediate color-collision --non-transparent-pixels --between colored-pixels of this sprite and the sprite argument Parameters: Name Type Description spr Sprite the sprite object to be collided Source: spritebox.js, line 7361 hasBoxCollision(sprite)  {boolean} returns a true || false value for immediate box-collision --between this sprite and the sprite argument Parameters: Name Type Description sprite Sprite the alternate Sprite for collision detection Source: spritebox.js, line 7477 shoot(options, animation, speed, position, size, rot_offset) fire a Shot, or bullet-Sprite from the Sprite Parameters: Name Type Description options Object an object of arguments animation Gamestack.Animation the animation to fire from the Sprite speed number the speed of the shot that is projected position Gamestack.Vector the initial position of the shot: defaults to current Sprite position size Gamestack.Vector the Vector size of the shot rot_offset Gamestack.Vector the rotational offset to apply: controls direction of the shot Source: spritebox.js, line 7514 subsprite(options, animation, speed, position, size, offset)  {Sprite} create a sub-sprite belonging to the current sprite Parameters: Name Type Description options Object an object of arguments animation Animation the animation to fire from the Sprite speed number the speed of the shot that is projected position Vector the initial position of the shot: defaults to current Sprite position size Vector the Vector size of the shot offset Vector the positional offset to apply Source: spritebox.js, line 7622 animate(animation) switch to the next frame on sprite.selected_animation Parameters: Name Type Description animation Animation the optional animation to switch to before animate is called, defaults to the existing sprite.selected_animation Source: spritebox.js, line 7677 onAnimationComplete(fun) run a function when the sprite.selected_animation is complete Parameters: Name Type Description fun function the function to call when the animation is complete Source: spritebox.js, line 7700 accelY(accel, max) accelerate speed on the y-axis Parameters: Name Type Description accel number the increment of acceleration max number the maximum for speed Source: spritebox.js, line 7722 accelX(accel, max) accelerate speed on the x-Axis Parameters: Name Type Description accel number the increment of acceleration max number the maximum for speed Source: spritebox.js, line 7767 decelY(amt) decelerate speed on the x-Axis, toward zero Parameters: Name Type Description amt number the increment of deceleration, negatives ignored Source: spritebox.js, line 7809 decelX(amt) decelerate speed on the x-Axis, toward zero Parameters: Name Type Description amt number the increment of deceleration, negatives ignored Source: spritebox.js, line 7841 accel(prop, key, accel, max) accelerate toward a max value on any object-property Parameters: Name Type Description prop Object The object to control key string the target property-key for object argument accel number the additive increase to the property on each call max number the max value to accelerate towards Source: spritebox.js, line 7873 decel(prop, key, decel, max) decelerate toward a max value on any object-property Parameters: Name Type Description prop Object the object to control key string the property-key for targeted property of prop argument decel number the increment of deceleration max number the max value to decelerate towards Source: spritebox.js, line 7924 SmoothMotion(x, y, duration) A generic 'smooth motion', adds to position.x and position.y with smooth acceleration and deceleration --uses quadratic-easing of the TWEEN.js library Parameters: Name Type Description x number The x to be added to Sprite().positon.x over the course of the SmoothMotion --use negative for subtractive motion y number The y to be added to Sprite().positon.y over the course of the SmoothMotion- -use negative for subtractive motion duration number the amount of time taken to complete this motion Source: spritebox.js, line 7986 SmoothRotate(r, duration) A generic 'smooth rotate', adds to rotation.x with smooth acceleration and deceleration --uses quadratic-easing of the TWEEN.js library Parameters: Name Type Description r number The numeric value to be added to Sprite().rotation.x over the course of the SmoothRotate --use negative for subtractive rotation duration number the amount of time taken to complete this rotation Source: spritebox.js, line 8030 center() get the vector-position at the center of the sprite, based on its current position and size Source: spritebox.js, line 8066 overlap_x(item, padding)  {boolean} determine if sprite overlaps on x-axis with another sprite Parameters: Name Type Description item Sprite the Sprite to compare with padding number the 0-1.0 float value of padding to use on self when testing overlap Source: spritebox.js, line 8132 overlap_y(item, padding)  {boolean} determine if sprite overlaps on y-axis with another sprite Parameters: Name Type Description item Sprite the Sprite to compare with padding number the 0-1.0 float value of padding to use on self when testing overlap Source: spritebox.js, line 8167 collide_stop_x(item) stop collision on x-axis with another sprite Parameters: Name Type Description item Sprite the Sprite with which to collide-stop on the x-axis Source: spritebox.js, line 8199 collide_stop(item) Trigger a fourway collision-stop between this and another Sprite :: objects will behave clastically and resist passing through one-another Parameters: Name Type Description item Sprite the Sprite to collide with Source: spritebox.js, line 8250 collide_stop_top(item) collide-stop only from the top (of the sprite passed as argument) :: Parameters: Name Type Description item Sprite the Sprite to collide with Source: spritebox.js, line 8328 restoreFrom() restore a sprite from existing json-data --applies to data-persistence Source: spritebox.js, line 8363 (static) SpriteArray#onLoadSprites() runs a function when the sprite's image has loaded Source: spritebox.js, line 9533  Search results Close Documentation generated by JSDoc 3.5.5 "},"Shot.html":{"id":"Shot.html","title":"Shot","body":" Shot - Documentation GamestackJs Documentation ClassesCameraGameWindowgetCanvascenterGridStyleonUpdateupdateonBeforeDrawonAfterDrawSizeaddBackgroundremoveanimatestartWebGL#getCanvasWebGL#centerWebGL#GridStyleWebGL#onUpdateWebGL#updateWebGL#onBeforeDrawWebGL#onAfterDrawWebGL#SizeWebGL#addWebGL#BackgroundWebGL#removeWebGL#animateWebGL#startRectangleVectorFrameBoundsRenderableGameImageVectorsubaddmultabsdivroundfloorceilnegequalstrig_distance_xyrandomizerotationalSpeedPointangleBetweenWebGLInputEventKeyboardEventGamepadEventBoolEventOnCallFrameSoundAnimationFrame#createColorMapinit_singleFrameonRunonCompleteReverseFramesSingleFramegetCurrentPixelMapsetFramerunanimateengageSpriteonLoadCloneAddLifeinitaddInitializerget_idcreate_idgetSizeByMaxSingleFrameLifeSpanLifeisDeaddieonScreenupdatedef_updateonUpdatetravelLineOnLoophasPixelCollisionhasBoxCollisionshootsubspriteanimateonAnimationCompleteaccelYaccelXdecelYdecelXacceldecelSmoothMotionSmoothRotatecenteroverlap_xoverlap_ycollide_stop_xcollide_stopcollide_stop_toprestoreFromSpriteArray#onLoadSpritesShotProjectileonComplete Shot Shot Creates an instance of Shot. Shot object fires a moving-animation from a sprite Constructor new Shot(name, imageOrAnimation)  {Shot} Parameters: Name Type Description name string the name of this Shot imageOrAnimation GameImage | Animation the GameImage or Animation to apply for this Shot Source: spritebox.js, line 8645  Search results Close Documentation generated by JSDoc 3.5.5 "},"Projectile.html":{"id":"Projectile.html","title":"Projectile","body":" Projectile - Documentation GamestackJs Documentation ClassesCameraGameWindowgetCanvascenterGridStyleonUpdateupdateonBeforeDrawonAfterDrawSizeaddBackgroundremoveanimatestartWebGL#getCanvasWebGL#centerWebGL#GridStyleWebGL#onUpdateWebGL#updateWebGL#onBeforeDrawWebGL#onAfterDrawWebGL#SizeWebGL#addWebGL#BackgroundWebGL#removeWebGL#animateWebGL#startRectangleVectorFrameBoundsRenderableGameImageVectorsubaddmultabsdivroundfloorceilnegequalstrig_distance_xyrandomizerotationalSpeedPointangleBetweenWebGLInputEventKeyboardEventGamepadEventBoolEventOnCallFrameSoundAnimationFrame#createColorMapinit_singleFrameonRunonCompleteReverseFramesSingleFramegetCurrentPixelMapsetFramerunanimateengageSpriteonLoadCloneAddLifeinitaddInitializerget_idcreate_idgetSizeByMaxSingleFrameLifeSpanLifeisDeaddieonScreenupdatedef_updateonUpdatetravelLineOnLoophasPixelCollisionhasBoxCollisionshootsubspriteanimateonAnimationCompleteaccelYaccelXdecelYdecelXacceldecelSmoothMotionSmoothRotatecenteroverlap_xoverlap_ycollide_stop_xcollide_stopcollide_stop_toprestoreFromSpriteArray#onLoadSpritesShotProjectileonComplete Projectile Projectile Takes an object of arguments and returns Projectile() object. Projectile fires a shot from the parent sprite, with specified offset, rotation, motion_curve, line_curve Constructor new Projectile(args)  {Projectile} Parameters: Name Type Description args Object object of arguments Properties Name Type Description name string optional description string optional distance string the distance before dissappearance motion_curve TWEEN.Easing.'objectGroup'.'objectMember' the TWEEN.Easing function to be applied for motion/speed (Example: TWEEN.Easing.Quadratic.InOut) @param {TWEEN.Easing.'objectGroup'.'objectMember'} args.line_curve the TWEEN.Easing function to be applied for line (Example: TWEEN.Easing.Quadratic.InOut) Source: spritebox.js, line 9176 Methods onComplete(fun) specify a function to be called when Motion is complete Parameters: Name Type Description fun function the function to be called when complete Source: spritebox.js, line 9247  Search results Close Documentation generated by JSDoc 3.5.5 "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
