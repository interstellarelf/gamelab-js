<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/jquery.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"gamestack.js.html":{"id":"gamestack.js.html","title":"gamestack.js","body":" gamestack.js - Documentation GamestackJs Documentation Examplesspace-gameClassesGameWindowgetCanvascenterGridStyleonUpdateupdateonBeforeDrawonAfterDrawSizeaddBackgroundremoveanimatestartWebGL#getCanvasWebGL#centerWebGL#GridStyleWebGL#onUpdateWebGL#updateWebGL#onBeforeDrawWebGL#onAfterDrawWebGL#SizeWebGL#addWebGL#BackgroundWebGL#removeWebGL#animateWebGL#startCameraSpriteonLoadCloneAddLifeinitaddInitializerget_idcreate_idgetSizeByMaxSingleFrameLifeSpanLifeisDeaddieonScreenupdatedef_updateonUpdatetravelLineOnLoophasPixelCollisionhasBoxCollisionshootsubspriteanimateonAnimationCompleteaccelYaccelXdecelYdecelXacceldecelSmoothMotionSmoothRotatecenteroverlap_xoverlap_ycollide_stop_xcollide_stopcollide_stop_toprestoreFromSpriteArray#onLoadSpritesAnimationFrame#createColorMapinit_singleFrameonRunonCompleteReverseFramesSingleFramegetCurrentPixelMapsetFramerunanimateengageFrameSoundGamepadEventInputEventRenderableRectangleShotProjectileonCompleteKeyboardEventVectorFrameBoundsGameImageVectorsubaddmultabsdivroundfloorceilnegequalstrig_distance_xyrandomizerotationalSpeedPointangleBetweenWebGLBoolEventOnCall gamestack.js /**@author Jordan Blake * */ /**@copyright Copyright 2018 **/ /** * Main module-object; references all Gamestack classes. * */ console.dev = function(tag, object) { var psuedoType = \"--unknown\"; switch (typeof object) { case \"string\": case \"number\": case \"boolean\": case \"null\": psuedoType = typeof object; default: { if (typeof object == 'object') psuedoType = object.constructor.name; } } if (Gamestack.DEV) console.info('gamestack::', tag, { data_type: psuedoType, object: object }); }; let delay = function(f, duration) { setTimeout(f, duration); } let repeat = function(f, duration) { setInterval(f, duration); } //Gamestack: the main module object: let Gamestack_Module = function() { var module = { settings: { DEBUG: false, gui_mode: true, recursionCount: 0, errorLimit: 20 }, errors: 0, stopDraw:false, defSize() { if (this.WIDTH == 0) { this.WIDTH = document.body.clientWidth; } if (this.HEIGHT == 0) { this.HEIGHT = document.body.clientHeight; } }, getGameWindow(ix = 0) { return this.game_windows[0] }, WIDTH: 0, HEIGHT: 0, game_windows: [], gs_renderables: [], gs_events: [], spriteTypes: [], systemSpriteTypes: ['player', 'enemy', 'background', 'interactive', 'terrain', 'weapon', 'subsprite'], __gameWindowList: [], all: function() { var all_objects = []; this.game_windows.forEach(function(item) { all_objects = all_objects.concat(item.drawables); }); console.info('Gamestack.all():', all_objects); return all_objects; }, init: function() { this.testSquare = new Gamestack.Sprite(); }, objectDestroyed(obj) { var dead = true; for (var x in this.game_windows) { let gw = this.game_windows[x]; for (var y in gw.objects) { if (gw.objects[y] === obj) dead = false; } } return dead; }, getObjectById(id) { for (var x = 0; x &lt; this.all_objects.length; x++) { if (this.all_objects[x].id == id) { return this.all_objects[x]; } } }, interlog: function(message, div) //recursive safe :: won't go crazy with recursive logs :: log message every x times this is called { this.recursionCount++; if (!isNaN(div) &amp;&amp; this.settings.recursionCount % div == 0) { // console.log('Interval Log:'+ message); } }, create_id: function() { var S4 = function() { return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1); }; return (S4() + S4() + \"-\" + S4() + \"-\" + S4() + \"-\" + S4() + \"-\" + S4() + S4() + S4()); }, error: function(quit, message) { if (quit) { throw new Error(message); } else { console.error('E!' + message); } }, info: function(m) { if (Gamestack.DEBUG) { console.info('Info:' + m); } }, log: function(m) { if (Gamestack.DEBUG) { console.log('Gamestack:' + m); } }, initializers: [], addInitializer: function(i) { this.initializers.push(i); }, Collision: { boxesCollide(pos1, size1, pos2, size2) { return pos1.x &gt;= pos2.x - size1.x &amp;&amp; pos1.x &lt;= pos2.x + size2.x &amp;&amp; pos1.y &gt;= pos2.y - size1.y &amp;&amp; pos1.y &lt;= pos2.y + size2.y; }, spriteBoxesCollide(obj1, obj2, gw) { gw = gw || Gamestack.game_windows[0]; var camPos = new Gamestack.Vector(0, 0, 0); obj1.padding = obj1.padding || new Gamestack.Vector(0, 0, 0); var paddingX = Math.round(obj1.padding.x * obj1.size.x), paddingY = Math.round(obj1.padding.y * obj1.size.y), left = obj1.position.x + paddingX + camPos.x, right = obj1.position.x + obj1.size.x - paddingX + camPos.x, top = obj1.position.y + camPos.y + paddingY, bottom = obj1.position.y + obj1.size.y - paddingY + camPos.y; if (right &gt; obj2.position.x &amp;&amp; left &lt; obj2.position.x + obj2.size.x &amp;&amp; bottom &gt; obj2.position.y &amp;&amp; top &lt; obj2.position.y + obj2.size.y) { return true; } }, spriteBoxesCollideTop(obj1, obj2, gw) { gw = gw || Gamestack.game_windows[0]; var camPos = new Gamestack.Vector(0, 0, 0); obj1.padding = obj1.padding || new Gamestack.Vector(0, 0, 0); var paddingX = Math.round(obj1.padding.x * obj1.size.x), paddingY = Math.round(obj1.padding.y * obj1.size.y), left = obj1.position.x + paddingX + camPos.x, right = obj1.position.x + obj1.size.x - paddingX + camPos.x, top = obj1.position.y + camPos.y + paddingY, bottom = obj1.position.y + obj1.size.y - paddingY + camPos.y; if (right &gt; obj2.position.x &amp;&amp; left &lt; obj2.position.x + obj2.size.x &amp;&amp; bottom &gt; obj2.position.y &amp;&amp; top &lt; obj2.position.y + obj2.size.y ) { return true; } }, /* * * ##Not known to be working --&gt;&gt; Below function * * */ pixelsCollide(sourceSprite, targetSprite, gw) { gw = gw || Gamestack.game_windows[0]; var camPos = new Gamestack.Vector(0, 0, 0); /* Box model detection, return true on collision */ function hitBox(source, target) { /* Source and target objects contain x, y and width, height */ return !( ((source.y + source.height) &lt; (target.y)) || (source.y &gt; (target.y + target.height)) || ((source.x + source.width) &lt; target.x) || (source.x &gt; (target.x + target.width)) ); } var source = { position: sourceSprite.position, pixelMap: sourceSprite.selected_animation.pixelMap }, target = { position: targetSprite.position, pixelMap: targetSprite.selected_animation.pixelMap }; // Loop through all the pixels in the source image for (var s = 0; s &lt; source.pixelMap.length; s++) { var sourcePixel = source.pixelMap[s]; // Add positioning offset var sourceArea = { x: sourcePixel.x + sourceSprite.position.x, y: sourcePixel.y + sourceSprite.position.y, width: 1, height: 1 }; var relatedPixel; // Loop through all the pixels in the target image for (var t = 0; t &lt; target.pixelMap.length; t++) { var targetPixel = target.pixelMap[t]; // Add positioning offset var targetArea = { x: targetPixel.x + targetSprite.position.x, y: targetPixel.y + targetSprite.position.y, width: 1, height: 1 }; /* Use the earlier aforementioned hitbox function */ if (hitBox(sourceArea, targetArea)) { return true; } } } } }, _gameWindow: {}, setGameWindow: function(gameWindow) { this._gameWindow = gameWindow; }, ExtendEvents: function(extendedObject, extendedKey, extendor, extendorKey) { var evtLink = new GSEventLink(extendedObject, extendedKey, extendor, extendorKey); this.all_objects.push(new GSEventLink(extendedObject, extendedKey, extendor, extendorKey)); var parent = extendedObject; // console.log(parent); if (parent) { console.log('Gamestack:EXTENDING EVENTS:' + extendedKey + \":\" + extendorKey); if (parent.onRun) //Any extendable object has an onRun ... OR { parent.onRun(extendor, extendorKey); } if (parent.onComplete) //object has an onComplete { parent.onComplete(extendor, extendorKey); } } }, assignAll: function(object, args, keys) { __gamestackInstance.each(keys, function(ix, item) { object[ix] = args[ix]; }); }, each: function(list, onResult, onComplete) { for (var i in list) { onResult(i, list[i]); } if (typeof(onComplete) === 'function') { onComplete(false, list) }; }, ready_callstack: [], ready: function(callback) { this.ready_callstack.push(callback); }, reload: function() { this.callReady(); }, callReady: function() { var funx = this.ready_callstack; var gameWindow = this.game_windows[0], module = this; //call every function in the ready_callstack this.each(funx, function(ix, call) { call(module, gameWindow); }); this.InputSystem.init(); this.__running = true; }, getArg: function(args, keys, fallback) { if (typeof(keys) == 'string') { keys = [keys]; //always array } for (var x = 0; x &lt; keys.length; x++) { var k = keys[x]; if (args &amp;&amp; args.hasOwnProperty(k)) { return args[k]; //return first argument match } } return fallback; }, normalArgs: function(args) { var a = {}; function normal(str) { return str.toLowerCase().replace('-', '').replace(' ', '').replace('_', '') }; for (var x in args) { a[normal(x)] = args[x]; } return a; }, isNormalStringMatch: function(str1, str2) { return str1.toLowerCase().replace(' ', '') == str2.toLowerCase().replace(' ', ''); }, instance_type_pairs: function() { //get an array of all instance/type pairs added to the library //example : [ {constructor_name:Sprite, type:enemy_basic}, {constructor_name:Animation, type:enemy_attack} ]; var objectList = []; this.each(this.all_objects, function(ix, item) { objectList.push({ constructor_name: item.constructor.name, type: item.type }); }); return objectList; }, getById: function(id) { for (var x in this.all_objects) { if (this.all_objects[x].id == id) { return this.all_objects[x]; } } }, select: function(constructor_name, name, group /*ignoring spaces and CAPS/CASE on type match*/ ) { var query = []; var __inst = this; this.each(Gamestack.all(), function(ix, item) { if (constructor_name == '*' || item.constructor.name == constructor_name) { if (group == '*' || __inst.isNormalStringMatch(group, item.group)) { if (name == '*' || __inst.isNormalStringMatch(name, item.name)) { query.push(item); } } } }); return query; } } return module; }; let GamestackApi = { get: function() { }, post: function(object) { //TODO decycle the object before saving if (!object.id) { object.id = Gamestack.create_id(); } var name = object.name, type = object.constructor.name, contents = jstr(object), id = object.id; } }; class GSO //Gamestack-Overrideable { constructor(args = {}) { this.run_ext = args.run_ext || []; this.complete_ext = args.complete_ext || []; } /***** * Overridable / Extendable functions * -allows stacking of external object-function calls ******/ onRun(caller, callkey) { this.run_ext = this.run_ext || []; if (this.run_ext.indexOf(caller[callkey]) == -1) { this.run_ext.push({ caller: caller, callkey: callkey }); } } onComplete(caller, callkey) { this.complete_ext = this.complete_ext || []; if (this.complete_ext.indexOf(caller[callkey]) == -1) { this.complete_ext.push({ caller: caller, callkey: callkey }); } } call_on_run() { //call any function extension that is present for (var x = 0; x &lt; this.run_ext.length; x++) { this.run_ext[x].caller[this.run_ext[x].callkey](); } } call_on_complete() { //call any function extension that is present for (var x = 0; x &lt; this.complete_ext.length; x++) { this.complete_ext[x].caller[this.complete_ext[x].callkey](); } } } let Gamestack = Gamestack_Module(); Gamestack.DEV = true; if (typeof module !== 'undefined' &amp;&amp; module.exports) { //This library is being instaniated via require() aka node.js require or similar library loader module.exports = Gamestack; } else { } /*************** * TODO : fix the above duplicate references, which exist now for backward compatibility with previouslyh authored code * -apply find and replace accross the codebase * ****************/ /******** * jstr() : public function for stringifying objects and arrays (uses pretty print style) * *********/ function jstr(obj) { return JSON.stringify(obj); }; Gamestack.jstr = jstr; /********** * $Q : Selector Function * -allows string-based-selection of game-objects. * **********/ function $Q(selector) { //declare events: console.log(selector); var query = []; //handle selector / selection of objects: if (typeof selector !== 'string') { if (selector instanceof Array) { } else { } } else { if (selector &amp;&amp; selector !== '*') { var s = selector || ''; console.info('selector:' + s); var mainSelector = $Q.before('[', s).trim(), msfChar = mainSelector.substring(0, 1); var __targetClassName = \"*\"; var output = []; var cleanSelectorString = function(str) { return str.replace(\",\", \"\"); }; switch (msfChar.toLowerCase()) { case \".\": console.info('Selecting by \".\" or class'); __targetClassName = cleanSelectorString($Q.after('.', mainSelector)); console.info('Target class is:' + __targetClassName); break; case \"*\": console.info('Selecting by \"*\" or ANY object in the library instance'); __targetClassName = \"*\"; break; } var criterion = $Q.between('[', ']', s), cparts = criterion.split('='); var __targetGroup = \"*\", __targetName = \"*\"; var getParts = function() { if (cparts.length &gt;= 2) { switch (cparts[0].toLowerCase()) { case \"name\": //get all objects according to name=name console.log('Q():Detected parts in selector:' + jstr(cparts)); __targetName = cleanSelectorString(cparts[1]); break; case \"group\": console.log('Q():Detected parts in selector:' + jstr(cparts)); __targetGroup = cleanSelectorString(cparts[1]); break; } } if (cparts.length &gt;= 4) { cparts[2] = cparts[2].replace(\",\", \"\"); switch (cparts[2].toLowerCase()) { case \"name\": //get all objects according to name=name console.log('Q():Detected parts in selector:' + jstr(cparts)); __targetName = cleanSelectorString(cparts[3]); break; case \"group\": console.log('Q():Detected parts in selector:' + jstr(cparts)); __targetGroup = cleanSelectorString(cparts[3]); break; } } }; getParts(cparts); query = Gamestack.select(__targetClassName, __targetName, __targetGroup); } else if (selector == '*') { query = Gamestack.all(); } } query.each = function(callback) { var objects = []; for (var x = 0; x &lt; this.length; x++) { if (typeof x == 'number') { callback(x, this[x]); } } }; query.on = function(evt_key, selectorObject, controller_ix, callback) //handle each event such as on('collide') OR on('stick_left_0') &lt;&lt; first controller stick_left { if (typeof evt_key == 'function' &amp;&amp; typeof selectorObject == 'function') { //this is a special pattern of if(f() == true){ runFunction(); }; var boolTrigger = evt_key, boolCall = selectorObject, boolEvent = new Gamestack.BoolEvent().On(boolTrigger).Call(boolCall); } var criterion = $Q.between('[', ']', evt_key); if (criterion.indexOf('===') &gt;= 0) { criterion = criterion.replace('===', '='); } if (criterion.indexOf('==') &gt;= 0) { criterion = criterion.replace('==', '=').replace('==', 0); } var cparts = criterion.split('='); var __targetGroup = \"*\", __targetName = \"*\"; if (evt_key.indexOf('[') &gt;= 0) { evt_key = $Q.before('[', evt_key).trim(); } var padding = 0; //if controller_ix is function, and callback not present, then controller_ix is the callback aka optional argument if (controller_ix &amp;&amp; typeof controller_ix == 'function' &amp;&amp; !callback) { callback = controller_ix; controller_ix = 0; } //optional argument: if controller_ix is function, and callback not present, then callback is selectorObject if (selectorObject &amp;&amp; typeof selectorObject == 'function' &amp;&amp; !callback) { callback = selectorObject; selectorObject = $Q('*'); controller_ix = 0; }; var evt_profile = {}; //which controller? evt_profile.cix = controller_ix; //Need the control key: 'left_stick', 'button_0', etc.. evt_profile.evt_key = evt_key; if ($Q.contains_any(['stick', 'button', 'click', 'key'], evt_profile.evt_key)) { var button_mode = evt_profile.evt_key.indexOf('button') &gt;= 0; Gamestack.GamepadAdapter.on(evt_profile.evt_key, 0, function(x, y) { callback(x, y); }); console.info('detected input event key in:' + evt_profile.evt_key); console.info('TODO: rig events'); } //TODO: test collision events: else if ($Q.contains_any(['collide', 'collision', 'hit', 'touch'], evt_profile.evt_key)) { // console.info('Rigging a collision event'); // console.info('detected collision event key in:' + evt_profile.evt_key); // console.info('TODO: rig collision events'); this.each(function(ix, item1) { // console.info('Collision Processing 1:' + item1.name); // console.info('Collision Processing 1:' + item1.type); selectorObject.each(function(iy, item2) { // console.info('Collision Processing 2:' + item2.name); // console.info('Collision Processing 2:' + item2.type); if (typeof(item1.onUpdate) == 'function') { var update = function(sprite) { console.log('Box collide::' + jstr([this, item2])); if (this.hasBoxCollision(item2, padding)) { callback(this, item2); }; }; item1.onUpdate(update); } }); }); } else { console.info('Rigging a property event'); //TODO: test property-watch events: console.info('detected property threshhold event key in:' + evt_profile.evt_key); console.info('TODO: rig property events'); var condition = \"_\", key = criterion || evt_profile.evt_key; if (key.indexOf('[') &gt;= 0 || key.indexOf(']') &gt;= 0) { key = $Q.between('[', ']', key); } var evt_parts = []; var run = function() { console.error('Sprite property check was not set correctly'); }; if (key.indexOf('&gt;=') &gt;= 0) { condition = \"&gt;=\"; } else if (key.indexOf('&lt;=') &gt;= 0) { condition = \"&lt;=\"; } else if (key.indexOf('&gt;') &gt;= 0) { condition = \"&gt;\"; } else if (key.indexOf('&lt;') &gt;= 0) { condition = \"&lt;\"; } else if (key.indexOf('=') &gt;= 0) { condition = \"=\"; } evt_parts = key.split(condition); for (var x = 0; x &lt; evt_parts.length; x++) { evt_parts[x] = evt_parts[x].replace('=', '').replace('=', '').trim(); //remove any trailing equals and trim() } var mykey, number; // alert(evt_parts[0]); try { mykey = evt_parts[0]; number = parseFloat(evt_parts[1]); } catch (e) { console.log(e); } console.info('Gamestack:Processing condition with:' + condition); switch (condition) { case \"&gt;=\": run = function(obj, key) { if (obj[key] &gt;= number) { callback(); } }; break; case \"&lt;=\": run = function(obj, key) { if (obj[key] &lt;= number) { callback(); } }; break; case \"&gt;\": run = function(obj, key) { if (obj[key] &gt; number) { callback(); } }; break; case \"&lt;\": run = function(obj, key) { if (obj[key] &lt; number) { callback(); } }; break; case \"=\": run = function(obj, key) { if (obj[key] == number) { callback(); } }; break; } /************ * Attach update to each member * * **************/ var keys = mykey.split('.'), propkey = \"\"; this.each(function(ix, item) { var object = {}; if (keys.length == 1) { object = item; propkey = mykey; } else if (keys.length == 2) { object = item[keys[0]]; propkey = keys[1]; } else if (keys.length == 3) { object = item[keys[0]][keys[1]]; propkey = keys[2]; } else { console.error(\":length of '.' notation out of range. We use max length of 3 or prop.prop.key.\"); } if (typeof item.onUpdate == 'function') { var spr = item; item.onUpdate(function(sprite) { run(object, propkey); }); } }); } }; return query; } $Q.each = function(obj, callback, complete) { for (var x in obj) { callback(obj); } if (typeof(complete) == 'function') { complete(obj); } }; $Q.before = function(c1, test_str) { var start_pos = 0; var end_pos = test_str.indexOf(c1, start_pos); return test_str.substring(start_pos, end_pos); }; $Q.contains = function(c1, test_str) { return test_str.indexOf(c1) &gt;= 0; }; $Q.contains_all = function(cList, test_str) { for (var x = 0; x &lt; cList.length; x++) { if (test_str.indexOf(cList[x]) &lt; 0) { return false; } } return true; }; $Q.contains_any = function(cList, test_str) { for (var x = 0; x &lt; cList.length; x++) { if (test_str.indexOf(cList[x]) &gt;= 0) { return true; } } return false; }; $Q.after = function(c1, test_str) { var start_pos = test_str.indexOf(c1) + 1; var end_pos = test_str.length; return test_str.substring(start_pos, end_pos); }; $Q.between = function(c1, c2, test_str) { var start_pos = test_str.indexOf(c1) + 1; var end_pos = test_str.indexOf(c2, start_pos); return test_str.substring(start_pos, end_pos) }; /**************************************** * Developer's own test-function: * -Q.test_selector_method(): * ***************************************/ $Q.test_selector_method = function() { //leftover method of hand-testing var Q_TestStrings = ['*', '.Sprite', '*[group=\"enemy_type_0\"]', '.Sprite[group=\"enemy_type_0\"]']; for (var x = 0; x &lt; Q_TestStrings.length; x++) { var test = Q_TestStrings[x]; console.info('testing:' + test); $Q(test); } console.log('Testing stick left'); this.on('stick_left_0'); console.log('Testing button'); this.on('button_0'); console.log('Testing collide'); this.on('collide'); console.log('Testing button'); this.on('collide'); console.log('Testing prop'); this.on('health&gt;=0'); }; Gamestack.$Q = $Q; Gamestack.query = $Q; /******************** * Gamestack.InputSystem * Various Keyboard + mouse Input Events ********************/ Gamestack.InputSystem = { //PC input events Mouse: { Position: { x: 0, y: 0 }, Speed: { x: 0, y: 0 }, setPosition(x, y) { this.Speed.x = x - this.Position.x; this.Speed.y = y - this.Position.y; this.Position.x = x; this.Position.y = y; }, isIdle: function() { return this.speed.x == 0 &amp;&amp; this.speed.y == 0; } }, events: { mousemove: [], mousepos: [], leftclick: [], rightclick: [], middleclick: [], wheelup: [], wheelDown: [] }, keymap: {}, keyReplace: function(str) { return str.toLowerCase().replace('space', ' ').replace('left', String.fromCharCode(37)).replace('left', String.fromCharCode(37)).replace('up', String.fromCharCode(38)).replace('right', String.fromCharCode(39)).replace('down', String.fromCharCode(40)); }, extendKey: function(evt_key, callback, onFinish) { evt_key = this.keyReplace(evt_key); Gamestack.InputSystem.keymap[evt_key] = { down: false, callback: function() { callback(evt_key); } }; return Gamestack.InputSystem.keymap[evt_key]; }, extend: function(evt_key, downCall, upCall, onFinish) { evt_key = evt_key.toLowerCase(); //each event-group has object-type Gamestack.InputSystem.events[evt_key] = Gamestack.InputSystem.events[evt_key] || []; Gamestack.InputSystem.events[evt_key].push({ down: downCall, up: upCall }); }, init: function() { var MOUSE = this.Mouse; window.setInterval(function() { Gamestack.each(Gamestack.InputSystem.keymap, function(im, kmapItem) { if (kmapItem.down == true) { kmapItem.callback(); } }); }, 10); document.onkeydown = document.onkeyup = function(e) { e = e || event; // to deal with IE var gs_key_string = 'key_' + String.fromCharCode(e.keyCode), evt_object = Gamestack.InputSystem['keymap'][gs_key_string] || Gamestack.InputSystem['keymap'][gs_key_string.toLowerCase()]; if (evt_object) { evt_object.down = e.type == 'keydown'; } } var canvases = document.querySelectorAll('canvas.gamewindow'); function getMousePos(e, c) { var x; var y; if (e.pageX || e.pageY) { x = e.pageX; y = e.pageY; } else { x = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft; y = e.clientY + document.body.scrollTop + document.documentElement.scrollTop; } x -= c.offsetLeft; y -= c.style.top; return { x: x, y: y }; } let InputSystem = Gamestack.InputSystem; function mouseMoving(event, c) { var pos = getMousePos(event, c); MOUSE.setPosition(pos.x, pos.y); if (InputSystem.events['mousemove']) { Gamestack.each(InputSystem.events['mousemove'], function(ix, el) { el.down(pos.x, pos.y); }); } }; //Interval for mouse-idle time : run mouse move again with same position, no difference setInterval(function() { if (InputSystem.events['mousepos']) { var pos = MOUSE.Position; Gamestack.each(InputSystem.events['mousepos'], function(ix, el) { el.down(pos.x, pos.y); }); } }, 10); for (var x = 0; x &lt; canvases.length; x++) { var c = canvases[x]; function applyMouseMove(e) { mouseMoving(e, c); } console.info('Gamestack-lib-code:main.js: InputSystem applying mousemove'); document.addEventListener(\"mousemove\", applyMouseMove); c.onmousedown = function(e) { // alert(JSON.stringify(Gamestack.InputSystem, true, 2)); var value = e.which; var pos = getMousePos(e, c); var InputSystem = Gamestack.InputSystem; e.preventDefault(); switch (e.which) { case 1: for (var x in InputSystem.events) { if (InputSystem.events[x] instanceof Array &amp;&amp; x == 'leftclick') { Gamestack.each(InputSystem.events[x], function(ix, el) { el.down(pos.x, pos.y); }); } } break; case 2: // alert('Middle Mouse button pressed.'); for (var x in Gamestack.InputSystem.events) { if (InputSystem.events[x] instanceof Array &amp;&amp; x == 'middleclick') { Gamestack.each(InputSystem.events[x], function(ix, el) { el.down(pos.x, pos.y); }); } } break; case 3: // alert('Right Mouse button pressed.'); for (var x in Gamestack.InputSystem.events) { if (InputSystem.events[x] instanceof Array &amp;&amp; x == 'rightclick') { Gamestack.each(InputSystem.events[x], function(ix, el) { el.down(pos.x, pos.y); }); return false; } } break; default: return 0; //alert('You have a strange Mouse!'); } e.preventDefault(); return 0; }; c.onmouseup = function(e) { // alert(JSON.stringify(Gamestack.InputSystem, true, 2)); var value = e.which; var pos = getMousePos(e, c); var InputSystem = Gamestack.InputSystem; e.preventDefault(); switch (e.which) { case 1: for (var x in InputSystem.events) { if (InputSystem.events[x] instanceof Array &amp;&amp; x == 'leftclick') { Gamestack.each(InputSystem.events[x], function(ix, el) { el.up(pos.x, pos.y); }); } } break; case 2: // alert('Middle Mouse button pressed.'); for (var x in Gamestack.InputSystem.events) { if (InputSystem.events[x] instanceof Array &amp;&amp; x == 'middleclick') { Gamestack.each(InputSystem.events[x], function(ix, el) { el.up(pos.x, pos.y); }); } } break; case 3: // alert('Right Mouse button pressed.'); for (var x in Gamestack.InputSystem.events) { if (InputSystem.events[x] instanceof Array &amp;&amp; x == 'rightclick') { Gamestack.each(InputSystem.events[x], function(ix, el) { el.up(pos.x, pos.y); }); return false; } } break; default: return 0; //alert('You have a strange Mouse!'); } }; } } }; //Override the existing window.onload function document.addEventListener('DOMContentLoaded', function() { Gamestack.callReady(); }); Gamestack.file_system = { localizedSource: function(src, hostUrl) { hostUrl = hostUrl || \"../\"; var gs_folder_ix = src.indexOf('assets/game'); return hostUrl + src.substring(gs_folder_ix, src.length); }, loadJSON: function(filepath, callback) { function readTextFile(file, callback) { var rawFile = new XMLHttpRequest(); rawFile.open(\"GET\", file, false); rawFile.onreadystatechange = function() { if (rawFile.readyState === 4) { if (rawFile.status === 200 || rawFile.status == 0) { var allText = rawFile.responseText; callback(JSON.stringify(allText)); } } } rawFile.send(null); }; readTextFile('file:///' + filepath, callback); }, loadLevel: function(jsonText, gw, callback) { var data = JSON.parse(jsonText); if (typeof(gw) == 'function' || !gw) { callback = gw || callback || function() {}; gw = Gamestack.game_windows[0]; } $.each(data.sprites, function(ix, xitem) { if (typeof(xitem.src) == 'string') { xitem.src = Gamestack.file_system.localizedSource(xitem.src); } __gamestackInstance.each(xitem, function(iy, yitem) { if (yitem.src) { yitem.src = Gamestack.file_system.localizedSource(yitem.src); } __gamestackInstance.each(yitem, function(iz, zitem) { if (zitem.src) { zitem.src = Gamestack.file_system.localizedSource(zitem.src); } }); }); xitem = new Gamestack.Sprite(xitem); gw.add(xitem); //sprite.image = sprite.selected_animation.image; if (ix &gt;= data.sprites.length - 1) { //last sprite is loaded //WHY DOESN't this work? callback(false, data); } }); }, loadJSONLevel: function(filepath, gw, callback) { if (typeof(gw) == 'function' || !gw) { callback = gw || callback || function() {}; gw = Gamestack.game_windows[0]; } this.loadJSON(filepath, function(data) { //localize .src up to three levels of recursion (.src must be altered to refer locally) $.each(data.sprites, function(ix, xitem) { if (typeof(xitem.src) == 'string') { xitem.src = Gamestack.file_system.localizedSource(xitem.src); } __gamestackInstance.each(xitem, function(iy, yitem) { if (yitem.src) { yitem.src = Gamestack.file_system.localizedSource(yitem.src); } __gamestackInstance.each(yitem, function(iz, zitem) { if (zitem.src) { zitem.src = Gamestack.file_system.localizedSource(zitem.src); } }); }); xitem = new Gamestack.Sprite(xitem); gw.add(xitem); //sprite.image = sprite.selected_animation.image; if (ix &gt;= data.sprites.length - 1) { //last sprite is loaded //WHY DOESN't this work? callback(false, data); } }); }); } }; Gamestack.ready(function(lib) { Gamestack.log('Gamestack: library is ready'); }); /* Screen */ let Screen = { size: function() { return new Gamestack.Vector(Gamestack.WIDTH, Gamestack.HEIGHT); }, center: function() { return new Gamestack.Vector(Gamestack.WIDTH / 2, Gamestack.HEIGHT / 2).round(); } }; ; /************************** EventInterfaceMap: StringKeys: * (must implement without option) @ (may implement optional) *****************************/ let EventInterfaceMap = { //className / must have named functions whyen carrying Symbol of className Sprite: ['@onUpdate', '@onDestroy'], Animation: ['@onRun', '@onComplete', '*onCollide'], Motion: ['@onCommit', '@onComplete', '*onCollide'], Shot: ['@onShoot', '*onCollide', '*onCollide'], Terrain: ['@onCollide'], Interactive: ['@onCollide'], Global: ['@onUpdate'], check: function(instance) { for (var x in this) { if (x == 'check') continue; else { if (this[x] instanceof Array) { this[x].forEach(function(f) { var fkey = f.replace('@', ''); if (!instance.getOwnPropertyNames.indexOf(fkey) &gt;= 0) throw new Error('Object must implement function by name of:' + fkey); }); } } }; } } /************************** ObjectFeatureInterfaceMap: Indicates classNames, and what they must carry as functions *****************************/ let ObjectFeatureMap = { //className / must have named function properties when carrying Symbol of className Sprite: ['@spatial', '@data'], Elipse:['@spatial'], Background: ['@spatial', '@data'], Animation: ['@framedriven', '@effectdriven','@posable', '@data'], Line2d:['@spatial', '@pointarrayflippable', '@selftransposable', '@data'], Text:['@spatial', '@text', '@colored'], Shot:['@spatial', '@data'] }; Gamestack.ObjectFeatureMap = ObjectFeatureMap; let InputIFM = { GamepadButtons: ['@onButton'], GamepadSticks: ['@onStick'], Keyboard: ['@onKey'], MouseMove: ['@onMouseMove'], MouseButton: ['@onMouseButton'], MouseWheel: ['@onMouseWheel'], LeapMotion: ['@onLeapMotion'] }; let UIEditables = { Sprite: ['size', 'position', 'rotation'], Animation: ['frameBounds', 'etc'] }; let UIOption = function(name, hint, script) { return { name, hint, script } }; let UIPrefab = { MainSelect: { Interactive: { name: 'FourwayClasticRect', hint: 'Object is collideable on four rectangular sides', script: '#MY-SCRIPT-PATH' } }, FormEditables: { Interactive: [] } }; let UIPrefabMainSelect = { Background: ['Bound'] }; let getCustomPrefabMeta = function() { //get name and file/data resources for each custom prefab }; /********************************** UIObjectSelectMap: -Just the system default options *********************************/ let UIObjectPrefabs = { Sprite: ['Side-Scroll-Player', 'Collider', 'Spaceship', 'Robot'], }; ;(function() { console.log('Camera class... creating'); /** * Creates a new Camera * @param {number} x=0 position-x * @param {number} y=0 position-y * @param {number} z=0 position-z * @returns {Camera} */ class Camera { constructor(x, y, z) { if (isNaN(x)) { x = 0; } if (isNaN(y)) { y = 0; } if (isNaN(z)) { z = 0; } /** * * @property {Vector} position the Vector position of Camera, having numeric x, y, and z values * @memberof Camera **********/ this.position = new Gamestack.Vector(x, y, z); } } Gamestack.Camera = Camera; })(); ; (function(){ console.log('Line() class... creating'); var Curves = { //ALL HAVE INPUT AND OUTPUT OF: 0-1.0 // no easing, no acceleration linearNone: function (t) { return t }, // accelerating from zero velocity easeInQuadratic: function (t) { return t*t }, // decelerating to zero velocity easeOutQuadratic: function (t) { return t*(2-t) }, // acceleration until halfway, then deceleration easeInOutQuadratic: function (t) { return t&lt;.5 ? 2*t*t : -1+(4-2*t)*t }, // accelerating from zero velocity easeInCubic: function (t) { return t*t*t }, // decelerating to zero velocity easeOutCubic: function (t) { return (--t)*t*t+1 }, // acceleration until halfway, then deceleration easeInOutCubic: function (t) { return t&lt;.5 ? 4*t*t*t : (t-1)*(2*t-2)*(2*t-2)+1 }, // accelerating from zero velocity easeInQuartic: function (t) { return t*t*t*t }, // decelerating to zero velocity easeOutQuartic: function (t) { return 1-(--t)*t*t*t }, // acceleration until halfway, then deceleration easeInOutQuartic: function (t) { return t&lt;.5 ? 8*t*t*t*t : 1-8*(--t)*t*t*t }, // accelerating from zero velocity easeInQuintic: function (t) { return t*t*t*t*t }, // decelerating to zero velocity easeOutQuintic: function (t) { return 1+(--t)*t*t*t*t }, // acceleration until halfway, then deceleration easeInOutQuintic: function (t) { return t&lt;.5 ? 16*t*t*t*t*t : 1+16*(--t)*t*t*t*t } } Gamestack.Curves = Curves; var inOutCurves = { quadratic: function (t) { return t&lt;.5 ? 2*t*t : -1+(4-2*t)*t }, cubic: function (t) { return t&lt;.5 ? 4*t*t*t : (t-1)*(2*t-2)*(2*t-2)+1 }, quartic: function (t) { return t&lt;.5 ? 8*t*t*t*t : 1-8*(--t)*t*t*t }, quintic: function (t) { return t&lt;.5 ? 16*t*t*t*t*t : 1+16*(--t)*t*t*t*t }, linear: function (t) { return t; } //provided for consistency / in case 'linear' is needed }; Gamestack.Curves.Smooth = inOutCurves; Gamestack.Curves.InOut = inOutCurves; })(); ; class Game { constructor(srcFile) { } } Gamestack.Game = Game; ; /** * Creates a new GameWindow * &lt;iframe style='width:400px; height:450px; overflow:hidden;' src='../client/examples/js-class/GameWindow.html'&gt; &lt;/iframe&gt; * @param {Object} canvas the canvas element for this gameWindow. --GameWindow's if not supplied, the constructor will create a full-screen canvas, if a canvas. * @param {Array} drawables=[] a list of drawable objects to be drawn. --Drawables can also be added after constructor call. * @returns {GameWindow} a Gamestack.GameWindow object * */ class GameWindow { constructor(canvas = false, drawables = []) { /** * list of all drawables in the window. * * @property this.drawables * @memberof GameWindow **********/ this.drawables = drawables; this.bool_events = Gamestack.bool_events || []; /** * the html-canvas of the GameWindow. * * @property this.canvas * @memberof GameWindow **********/ this.canvas = canvas || false; if (!canvas) { console.info('GameWindow() had no {canvas:canvas} argument. Creating a new canvas in document.body...'); this.canvas = document.createElement('CANVAS'); this.canvas.setAttribute('class', 'gamewindow'); document.body.append(this.canvas); } this.context = this.canvas.getContext('2d'); document.body.style.position = \"absolute\"; document.body.style.width = \"100%\"; document.body.style.height = \"100%\"; /** * the camera of the GameWindow. --An instance of Gamestack.Camera * * @property this.camera * @memberof GameWindow **********/ this.camera = new Gamestack.Camera(); this.camera.target = false; Gamestack.camera = this.camera; var __inst = this; this.Size(); this.update_ext = []; window.onresize = function() { if (__inst.isAbsoluteSize) return; __inst.Size(); }; this.ctx = this.canvas.getContext('2d'); Gamestack.game_windows.push(this); window.onerror = function(){ Gamestack.errors += 1; console.log('Canvas Error --'); if (Gamestack.errors &gt; Gamestack.settings.errorLimit) { Gamestack.stopDraw = true; var call = call || window.setTimeout(function(){ if(call) { window.clearTimeout(call); } console.log('%cDraw stopped at errorLimit:' + Gamestack.settings.errorLimit, 'color:darkorange;'); }, 200); } } } /** * returns the gameWindow.canvas property, an HTMLCanvasElement * * @function * @memberof GameWindow **********/ getCanvas(){ return this.canvas; } /** * returns a vector(x, y) showing the center of the GameWindow * * @function * @memberof GameWindow **********/ center() { return new Gamestack.Vector(Math.round(this.canvas.width / 2), Math.round(this.canvas.height / 2)); } TrackStat(){ this.__trackStat = true; return this; } GridUnit(x, y, w, h, srcImage_Path){ var size = new Gamestack.Vector(w, h), position = new Gamestack.Vector(x, y); var sprite; if(srcImage_Path) { sprite = new Gamestack.Sprite(srcImage_Path); sprite.Size(size); sprite.Pos(position); Gamestack.game_windows[0].add(sprite); } return { size:size, position:position }; } /** * creates an array of gridUnits * * @function * @memberof GameWindow **********/ GridStyle(total_x, total_y, w, h, srcImage_Path) { if(!(this.grid instanceof Array)) { this.grid = []; } function GridUnit(x, y, w, h, srcImage_Path){ var size = new Gamestack.Vector(w, h), position = new Gamestack.Vector(x, y); var sprite; if(srcImage_Path) { sprite = new Gamestack.Sprite(srcImage_Path); sprite.Size(size); sprite.Pos(position); Gamestack.game_windows[0].add(sprite); } return { size:size, position:position }; }; for(var y = 0; y &lt; total_y; y++) { for(var x = 0; x &lt; total_x; x++) { this.grid.push(new GridUnit(x * w, y * h, w, h, srcImage_Path)); } } return this; } getCanvas(){ return this.canvas; } /** * adds an update to the GameWindow:: update to be called every 20 milliseconds * * @function * @memberof GameWindow **********/ onUpdate(f) { this.update_ext.push(f); } /** * the main update for the GameWindow:: called automatically after call of GameWindow.start() or GameWindow.animate() * * @function * @memberof GameWindow **********/ update() { Gamestack.each(this.drawables, function(ix, item) { if (item &amp;&amp; typeof(item.def_update) == 'function') { item.def_update(item); } if (item &amp;&amp; typeof(item.update) == 'function') { item.update(item); } if (item &amp;&amp; ['SpriteArray', 'RobotixArray', 'RobotixVerticalChain'].indexOf(item.constructor.name) &gt;= 0 &amp;&amp; typeof item.each == 'function') { item.each(function(ix, graphic){ graphic.update(graphic); }); } }); Gamestack.each(this.bool_events, function(ix, item) { if (item &amp;&amp; item.bool()) { item.callback(); } }); for (var x in this.update_ext) { this.update_ext[x](); } } draw() { var __gameWindow = this; if (this.before_draw_ext) { this.before_draw_ext(); } Gamestack.each(this.drawables, function(ix, item) { if(typeof item.draw == 'function') { item.draw(__gameWindow.ctx, __gameWindow.camera); } }); if (this.after_draw_ext) { this.after_draw_ext(); } } /** * adds a call before the GameWindow draw() * * @function * @memberof GameWindow **********/ onBeforeDraw(f) { var boundCall = f.bind(this); if(!this.before_draw_ext) this.before_draw_ext = function(){}; var beforeDraw = this.before_draw_ext.bind(this); this.before_draw_ext = function() { beforeDraw(); boundCall(); }; } /** * adds a call after the GameWindow draw() * * @function * @memberof GameWindow **********/ onAfterDraw(f) { var boundCall = f.bind(this); if(!this.after_draw_ext) this.after_draw_ext = function(){}; var afterDraw = this.after_draw_ext.bind(this); this.after_draw_ext = function() { afterDraw(); boundCall(); }; } /** * sets the size of the GameWindow * * @function * @param {integer} w the width of the GameWindow * @param {integer} h the HEIGHT of the GameWindow * @memberof GameWindow **********/ Size(w, h, isAbsoluteSize) { //call with no args to fill to browser-window-size; w = w || this.canvas.parentNode.clientWidth; h = h || this.canvas.parentNode.clientHeight; var c = this.canvas; if (c) { c.setAttribute('width', w) }; if (c) { c.setAttribute('height', h) }; Gamestack.WIDTH = w; Gamestack.HEIGHT = h; this.canvas.width = w; this.canvas.height = h; this.size = new Gamestack.Vector(w, h); this.isAbsoluteSize = isAbsoluteSize || false; return this; } /** * adds an object to the GameWindow * * @function * @param {Object} obj the object to be added (Sprite) * @param {Boolean} onBottom if true, adds to the bottom of layer-stack in GameWindow * @memberof GameWindow **********/ add(obj, options={}) { var optionsGuide = { obj:'The Object{} being added into play', options:{ position:'The Vector(x, y) offset to use when drawing the obj' } }; console.info('GameWindow.add() --2nd argument options is object of arguments &gt;&gt;&gt;', optionsGuide); var layer = options.layer || this.drawables.length - 1; if(!(typeof layer == 'number' &amp;&amp; layer &gt;= 0)) layer = this.drawables.length; var offset = new Gamestack.Vector(0, 0); if(options.position) offset = options.position; obj.window_offset = offset; //1: if Sprite(), Add object to the existing __gameWindow var __inst = this; if (obj instanceof Gamestack.Camera) { this.camera = obj; } else if (obj instanceof Gamestack.GSEvent) { if (Gamestack.__running) { return console.error('Events can only be added before Gamstack.animate() is called::aka before the main update / loop begins'); } else { obj.apply(); } } else { this.drawables.splice(layer, 0, obj); }; return obj; } /** * set background-color of GameWindow * * @function * @param {string} c the new background-color for GameWindow * @memberof GameWindow **********/ Background(c) { this.canvas.style.background = c; this.canvas.style.backgroundColor = c; return this; } /** * removes an object from the GameWindow * * @function * @param {Object} obj the object to be removed (Sprite) * @memberof GameWindow **********/ remove(obj) { var ix = this.drawables.indexOf(obj); if (ix &gt;= 0) { this.drawables.splice(ix, 1); } } removeDeadObjects() { var $window = this; this.drawables.forEach(function(sprite){ if(sprite.life &lt;= 0) { $window.remove(sprite); } }); } /** * begins the animation-loop of GameWindow. * * @function * @param {number} time optional time parameter for usage with Tween * @memberof GameWindow **********/ animate(time) { var __inst = this; requestAnimationFrame(function() { __inst.animate(); }); if (this.__stats) { this.__stats.begin(); this.__statsMS.begin(); this.__statsMB.update(); } Gamestack.isAtPlay = true; if (window.TWEEN) TWEEN.update(time); __inst.update(); this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); this.draw(); if (this.__stats) { this.__stats.end(); this.__statsMS.end(); } } /** * begins the animation-loop of GameWindow, with performance Stats shown on-screen * * @function * @memberof GameWindow **********/ start() { if (typeof(Stats) == 'function') //Stats library exists { //basic stat animation this.__stats = new Stats(); this.__stats.showPanel(0); // 0: fps, 1: ms, 2: mb, 3+: custom this.__stats.dom.style.left = '10%'; this.__stats.dom.setAttribute('class', 'stat'); this.canvas.parentNode.appendChild(this.__stats.dom); //basic stat animation this.__statsMS = new Stats(); this.__statsMS.showPanel(1); // 0: fps, 1: ms, 2: mb, 3+: custom this.__statsMS.dom.style.left = '10%'; this.__statsMS.dom.style.marginLeft = '90px'; this.__statsMS.dom.setAttribute('class', 'stat'); this.canvas.parentNode.appendChild(this.__statsMS.dom); //basic stat animation this.__statsMB = new Stats(); this.__statsMB.showPanel(2); // 0: fps, 1: ms, 2: mb, 3+: custom this.__statsMB.dom.style.left = '10%'; this.__statsMB.dom.setAttribute('class', 'stat'); this.__statsMB.dom.style.marginLeft = '180px'; this.canvas.parentNode.appendChild(this.__statsMB.dom); } this.animate(); } } Gamestack.GameWindow = GameWindow; ; /** * Creates a new Module * @param {string} uri the uri that the .js file is located at * @param {Function} callback=function(){} The callback to call after the module is loaded * @returns {Module} a Gamestack.Module object * */ console.info('Module class :: keep as public'); class Module{ constructor(uri, callback){ this.load(uri, callback); } load(uri, callback){ var __object = this; callback = callback || function(){}; callback = callback.bind(this); var script = document.createElement('SCRIPT'); script.src = uri; //define onload fxn script.onload = function(){ var construct = window.module.exports; callback(construct); }; //append to the document document.head.appendChild(script); } }; Gamestack.Module = Module; ; /** * Creates an instance of Rectangle. * @param {Gamestack.Vector} min the minimum vector point (x,y) * @param {Gamestack.Vector} max the maximum vector point (x,y) * * @returns {Rectangle} a Rectangle object */ class Rectangle { constructor(min, max) { this.min = new Gamestack.Vector(min); this.max = new Gamestack.Vector(max); } toLine() { } } ; let VectorBounds = Rectangle; Gamestack.VectorBounds =VectorBounds; Gamestack.Rectangle = Rectangle; /** * Takes the min and max vectors plus termPoint ('termination-point'), returns VectorFrameBounds * *use this to define the bounds of an Animation object. * @param {Vector} min the minimum vector point (x,y) * @param {Vector} max the maximum vector point (x,y) * @param {Vector=} termPoint the optional termination vector point (x,y) : defaults to the value of 'max' * -While a min and max Gamestack.Vector(x,y) will describe the grid-size of Animation frames, * the termPoint will indicate the last frame on-grid for this set of frames --Animation may stop early on the 'grid') * @returns {VectorFrameBounds} a VectorFrameBounds object */ class VectorFrameBounds extends Rectangle { constructor(min, max, termPoint) { super(min, max); this.termPoint = termPoint || new Gamestack.Vector(this.max.x, this.max.y, this.max.z); } } ; Gamestack.VectorFrameBounds = VectorFrameBounds; var GeoMath = { rotatePointsXY:function(x,y,angle) { var theta = angle*Math.PI/180; var point = {}; point.x = x * Math.cos(theta) - y * Math.sin(theta); point.y = x * Math.sin(theta) + y * Math.cos(theta); point.z = 0; return point } } Gamestack.GeoMath = GeoMath; ; /** * Renderable : consistent base-type for graphic-objects * @param {Object} args the object of arguments * @returns {Renderable} a Gamestack.Renderable object. * */ class Renderable { constructor(args={}) { // Gamestack.FeatureInject(this, args); } } /** * A game-image object based on HTMLImage element. Creates GameImage, attaches gameImage.domElement --an instance of HTMLImageElement * @param {string} src the sourcePath of the image-file. * @returns {GameImage} a Gamestack.GameImage object. * */ class GameImage extends Renderable { constructor(src={}, onCreate=function(){I('image: applied default arg to onCreate():');}) { super(src); if(typeof src == 'object') { return src; } console.dev('GameImage--', this); this.domElement = document.createElement('IMG'); this.domElement.src = src; this.domElement.onerror = function () { this.__error = true; console.dev('--image error'); }; } }; Gamestack.GameImage = GameImage; ; console.info('Scriptable class :: keep as public'); console.info('Script class :: keep as public'); class Script{ constructor(uri, callback){ this.src = uri || ''; if(uri &amp;&amp; callback) { this.load(uri, callback); } else{ console.info('Created Script() without uri + callback --1st and 2nd arguments. To use object call script.load()'); } } load(uri, callback){ var __object = this; callback = callback || function(){}; callback = callback.bind(this); var script = document.createElement('SCRIPT'); script.src = uri; //define onload fxn script.onload = function(){ var construct = window.module.exports; callback(construct); }; //append to the document document.head.appendChild(script); } }; Gamestack.Script = Script; class Scriptable{ constructor(object, siblings){ this.object = object; this.siblings = siblings; } Object(object) { this.object = object; return this; } load(url, callback){ var __object = this; callback = callback || function(){}; callback = callback.bind(this); var script = document.createElement('SCRIPT'); script.src = url; //define onload fxn script.onload = function(){ var construct = window.module.exports; var MOD = construct(__object.object, __object.siblings); callback.bind(__object).call(MOD, __object.object, __object.siblings); }; //append to the document document.head.appendChild(script); } }; Gamestack.Scriptable = Scriptable; ; class Elipse{ constructor(pos, size){ this.position = new Gamestack.Vector(0, 0, 0); this.size = new Gamestack.Vector(0, 0, 0); this.rotation = new Gamestack.Vector(0, 0, 0); this.Pos(pos); this.Size(size); } draw(){ var halfX = (this.size.x / 2); var halfY = (this.size.y / 2); Gamestack.Canvas.arc(this.position, new Gamestack.Vector(halfX, halfY)); } } Gamestack.Elipse = Elipse; ; var Trigonometry = { rotate_from_xy:function(cx, cy, x, y, angle) { var radians = (Math.PI / 180) * angle, cos = Math.cos(radians), sin = Math.sin(radians), nx = (cos * (x - cx)) + (sin * (y - cy)) + cx, ny = (cos * (y - cy)) - (sin * (x - cx)) + cy; return new Gamestack.Vector(nx, ny); }, find_point_on_circle:function(x, y, radius, degrees){ } }; Gamestack.Trig = Trigonometry; Gamestack.Trigonometry = Trigonometry; ; function Curve_ToComplete(tag){ var log_it = function(sub_tag){ return (function(){ console.info('Curve_ToComplete:' + tag + '.' + sub_tag); })(); }; return { In:log_it('In'), Out:log_it('Out'), Seamless:log_it('Seamless') } }; var linkedCurves = { quadratic: function(t) { return t &lt; .5 ? 2 * t * t : -1 + (4 - 2 * t) * t }, cubic: function(t) { return t &lt; .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1 }, quartic: function(t) { return t &lt; .5 ? 8 * t * t * t * t : 1 - 8 * (--t) * t * t * t }, quintic: function(t) { return t &lt; .5 ? 16 * t * t * t * t * t : 1 + 16 * (--t) * t * t * t * t }, linear: function(t) { return t; } //provided for consistency / in case 'linear' is needed }; let Twix = { Curves:{ //ALL HAVE INPUT AND OUTPUT OF: 0-1.0 // no easing, no acceleration Linear: { None: function(t) { return t; } }, Quadratic: { In: function(t) { return t * t; }, Out: function(t) { return t * (2 - t); }, Seamless: function(t) { return t &lt; .5 ? 2 * t * t : -1 + (4 - 2 * t) * t; } }, Cubic: { In: function(t) { return t * t * t; }, Out: function(t) { return (--t) * t * t + 1; }, Seamless: function(t) { return t &lt; .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1; } }, Quartic: { In: function(t) { return t * t * t * t; }, Out: function(t) { return 1 - (--t) * t * t * t; }, Seamless: function(t) { return t &lt; .5 ? 8 * t * t * t * t : 1 - 8 * (--t) * t * t * t; } }, Quintic: { In: function(t) { return t * t * t * t * t; }, Out: function(t) { return 1 + (--t) * t * t * t * t; }, Seamless: function(t) { return t &lt; .5 ? 16 * t * t * t * t * t : 1 + 16 * (--t) * t * t * t * t; } }, Sine:Curve_ToComplete('Sine'), Cosine:Curve_ToComplete('Cosine'), Tangent:Curve_ToComplete('Tangent'), Exponential:Curve_ToComplete('Exponential'), }, LinkedCurves:linkedCurves }; const TranceCurves = {}; TranceCurves.Exponential = (value, power, min, max) =&gt; { }; TranceCurves.Power = (value, power, min, max) =&gt; { }; const TrigFunctions = {}; TrigFunctions.Sine = {}; TrigFunctions.Cosine = {}; TrigFunctions.Tangent = {}; const SpecialFunctions = {}; SpecialFunctions.Sawtooth = (t) =&gt; { return t &lt;= 1.0 ? t : 0; }; SpecialFunctions.Square = () =&gt; {}; SpecialFunctions.Triangle = () =&gt; {}; SpecialFunctions.Floor = () =&gt; {}; SpecialFunctions.Sign = () =&gt; {}; Gamestack.core = Gamestack.core || {}; Gamestack.core.XYFunctions = {}; Gamestack.core.XYFunctions.SpecialFunctions = SpecialFunctions; const SigmaFunctions = {}; const GammaFunctions = {}; ;(function() { console.log('Vector class... creating'); /** * Creates a Vector object with x, y, and --optional z. * @param {number} x the x coordinate * @param {number} y the y coordinate * @param {number} z the optional z coordinate * @param {number} r the optional r value * @returns {Vector} a Vector object */ class Vector { constructor(x, y, z, r) { var copied = false; if (typeof(x) == 'object' &amp;&amp; x.hasOwnProperty('x') &amp;&amp; x.hasOwnProperty('y')) //optionally pass vector3 { this.x = x.x; this.y = x.y; this.z = x.z || 0; if (this.z == null) { this.z = 0; } this.valid_check(); copied = true; } if (z == null) { z = 0; } if (!copied) { this.x = x; this.y = y; this.z = z; this.r = r; this.valid_check(); } } valid_check() { if (this.x == undefined) { this.x = 0; } if (this.y == undefined) { this.y = 0; } if (this.z == undefined) { this.z = 0; } } /** * Subtracts another Vector from this vector and returns a vector for the resulting difference. * * @function * @param {Vector} v the vector to be subtracted from this vector * @memberof Vector **********/ sub(v) { if (typeof(v) == 'number') { v = { x: v, y: v, z: v }; }; return new Gamestack.Vector(this.x - v.x, this.y - v.y, this.z - v.z); } /** * Adds another Vector to this vector and returns a vector for the resulting sum. * * @function * @param {Vector} v the vector to be added to this vector * @memberof Vector **********/ add(v) { if (typeof(v) == 'number') { v = { x: v, y: v, z: v }; }; return new Gamestack.Vector(this.x + v.x, this.y + v.y, this.z + v.z); } /** * Multiplies another Vector by this vector and returns a vector for the resulting product. * * @function * @param {Vector} v the vector that this vector will by muliplied by * @memberof Vector **********/ mult(v) { if (typeof(v) == 'number') { v = { x: v, y: v, z: v }; }; return new Gamestack.Vector(this.x * v.x, this.y * v.y, this.z * v.z); } /** * Gets vector of absolute values. * * @function * @param {Vector} v the absolute vector * @memberof Vector **********/ abs() { return new Gamestack.Vector(Math.abs(this.x), Math.abs(this.y), Math.abs(this.z)); } /** * Divides another Vector by this vector and returns a vector for the resulting quotient. * * @function * @param {Vector} v the vector for this vector to be divided by * @memberof Vector **********/ div(v) { if (typeof(v) == 'number') { v = { x: v, y: v, z: v }; }; return new Gamestack.Vector(this.x / v.x, this.y / v.y, this.z / v.z); } /** * Rounds this vector to the nearest set of whole numbers and returns the result. * * @function * @memberof Vector * @returns {Vector} a Gamestack.Vector object **********/ round() { return new Gamestack.Vector(Math.round(this.x), Math.round(this.y), Math.round(this.z)); } /** * Floors this vector to the nearest set of whole numbers and returns the result (subtractive-only, an x of 1.7 becomes 1) * * @function * @memberof Vector * @returns {Vector} a Gamestack.Vector object **********/ floor() { return new Gamestack.Vector(Math.floor(this.x), Math.floor(this.y), Math.floor(this.z)); } /** * Ceils this vector to the nearest set of whole numbers and returns the result (additive-only, an x of 1.2 becomes 2) * * @function * @memberof Vector * @returns {Vector} a Gamestack.Vector object **********/ ceil() { return new Gamestack.Vector(Math.ceil(this.x), Math.ceil(this.y), Math.ceil(this.z)); } /** * Creates new vector, with the negated x,y,z values (-x-y-z), returns the resulting vector * * @function * @memberof Vector * @returns {Vector} a Gamestack.Vector object **********/ neg() { return new Gamestack.Vector(-this.x, -this.y, -this.z); } /** * An equals-test for vectors. Returns true OR false. * * @function * @memberof Vector * @returns {boolean} a true OR false value **********/ equals(v) { return this.x == v.x &amp;&amp; this.y == v.y &amp;&amp; this.z == v.z; } /** * Gets the specific distance between this and the argument-vector. --applies to x and y of two vectors. Returns a single number. * * @function * @memberof Vector * @returns {number} the specific distance between this and the argument-vector **********/ trig_distance_xy(v) { var dist = this.sub(v); return Math.sqrt(dist.x * dist.x + dist.y * dist.y); } is_between(v1, v2) { //TODO : overlap vectors return boolean return this.x &gt;= v1.x &amp;&amp; this.x &lt;= v2.x &amp;&amp; this.y &gt;= v1.y &amp;&amp; this.y &lt;= v2.y &amp;&amp; this.z &gt;= v1.z &amp;&amp; this.z &lt;= v2.z; } /** * Returns a vector-multiple: the original-size, multiplied by a random between the minFloat and maxFloat arguments. * * @function * @memberof Vector * @returns {Vector} the resulting vector. **********/ randomize(minFloat, maxFloat) { var random = (Math.random() * (maxFloat - minFloat) + minFloat) * 1000 / 1000; return this.mult(random); } /** * Returns a speed vector, based on rotation. * * @function * @param {number} rotation in degrees, 0-360 * @param {number} speed the level of speed to apply, default being 1 * @returns {Vector} * @memberof Vector **********/ rotationalSpeedPoint(rotation, speed) { var r = rotation; if (isNaN(speed)) { speed = 1; } if (typeof(rotation) == 'object' &amp;&amp; rotation.x) { r = rotation.x; } return new Gamestack.Vector(Math.cos((r) * 3.14 / 180) * speed, Math.sin((r) * 3.14 / 180) * speed); } /** * Returns the right-handed angle of degrees between two two position-vectors. * @memberof Vector * @function * @param {Vector} p1 the 1st vector-argument * @param {Vector} p2 the 2nd vector-argument * @returns {number} the resulting angle in degrees. **********/ angleBetween(p1, p2) { return Math.atan2(p2.y - p1.y, p2.x - p1.x) * 180 / Math.PI; } //apply minimum value to all values min2d() { function minimize(object, key1, key2) { if (object[key1] &lt; object[key2]) object[key2] = object[key1]; if (object[key2] &lt; object[key1]) object[key1] = object[key2]; }; minimize(this, 'x', 'y'); return this; } //apply maximum value to all values max2d() { function maximize(object, key1, key2) { if (object[key1] &gt; object[key2]) object[key2] = object[key1]; if (object[key2] &gt; object[key1]) object[key1] = object[key2]; }; maximize(this, 'x', 'y'); return this; } }; let Vector3 = Vector, Pos = Vector, Size = Vector, Position = Vector, Vector2 = Vector, Rotation = Vector; Gamestack.Vector = Vector; //synonymous w/ Vector:: Gamestack.Vector2d = Vector; Gamestack.Vector2D = Vector; Gamestack.Rotation = Vector; Gamestack.Pos = Vector; Gamestack.Position = Vector; Gamestack.Size = Vector; //The above are a list of synonymous expressions for Vector. All of these do the same thing in this library (store and manipulate x,y,z values) var VectorMath = { rotatePointsXY(x, y, angle) { var theta = angle * Math.PI / 180; var point = {}; point.x = x * Math.cos(theta) - y * Math.sin(theta); point.y = x * Math.sin(theta) + y * Math.cos(theta); point.z = 0; return point } } Gamestack.VectorMath = VectorMath; })(); ; /** * Creates a GameWindow object. * * &lt;iframe style='width:400px; height:450px; overflow:hidden;' src='../client/examples/js-class/GameWindow.html'&gt; &lt;/iframe&gt; * @param {Object} canvas the canvas element for this gameWindow. --GameWindow's if not supplied, the constructor will create a full-screen canvas, if a canvas. * @param {Object} drawables the drawable objects to be drawn. --Drawables can also be added after constructor call. * @returns {GameWindow} a Gamestack.GameWindow object * */ class WebGL { constructor(canvas = false, drawables = []) { if(!THREE) { return console.error('THREE.js required in window'); } document.body.style.position = \"absolute\"; document.body.style.width = \"100%\"; document.body.style.height = \"100%\"; var camera = new THREE.PerspectiveCamera(); var container = document.querySelector('#game-window'); this.renderer = new THREE.WebGLRenderer(); this.renderer.setSize( container.clientWidth, container.clientHeight ); this.scene = new THREE.Scene(); this.camera = new THREE.PerspectiveCamera( 75, container.clientWidth / container.clientHeight, 0.1, 1000 ); //was 1000 last arg container.append( this.renderer.domElement ); this.scene.add(this.camera); this.light = new THREE.AmbientLight( 0x404040 ); // soft white light this.scene.add( this.light ); this.drawables = drawables; this.bool_events = Gamestack.bool_events || []; this.canvas = this.renderer.domElement; this.camera.target = false; var __inst = this; this.update_ext = []; Gamestack.game_windows.push(this); window.onerror = function(){ Gamestack.errors += 1; console.log('Canvas Error --'); if (Gamestack.errors &gt; Gamestack.settings.errorLimit) { Gamestack.stopDraw = true; var call = call || window.setTimeout(function(){ if(call) { window.clearTimeout(call); } console.log('%cDraw stopped at errorLimit:' + Gamestack.settings.errorLimit, 'color:darkorange;'); }, 200); } } } /** * returns the gameWindow.canvas property, an HTMLCanvasElement * * @function * @memberof GameWindow **********/ getCanvas(){ return this.canvas; } /** * returns a vector(x, y) showing the center of the GameWindow * * @function * @memberof GameWindow **********/ center() { return new Gamestack.Vector(Math.round(this.canvas.width / 2), Math.round(this.canvas.height / 2)); } /** * creates an array of gridUnits * * @function * @memberof GameWindow **********/ GridStyle(total_x, total_y, w, h, srcImage_Path) { if(!(this.grid instanceof Array)) { this.grid = []; } function GridUnit(x, y, w, h, srcImage_Path){ var size = new Gamestack.Vector(w, h), position = new Gamestack.Vector(x, y); var sprite; if(srcImage_Path) { sprite = new Gamestack.Sprite(srcImage_Path); sprite.Size(size); sprite.Pos(position); Gamestack.game_windows[0].add(sprite); } return { size:size, position:position }; }; for(var y = 0; y &lt; total_y; y++) { for(var x = 0; x &lt; total_x; x++) { this.grid.push(new GridUnit(x * w, y * h, w, h, srcImage_Path)); } } return this; } getCanvas(){ return this.canvas; } /** * adds an update to the GameWindow:: update to be called every 20 milliseconds * * @function * @memberof GameWindow **********/ onUpdate(f) { this.update_ext.push(f); } /** * the main update for the GameWindow:: called automatically after call of GameWindow.start() or GameWindow.animate() * * @function * @memberof GameWindow **********/ update() { Gamestack.each(this.drawables, function(ix, item) { if (item &amp;&amp; typeof(item.def_update) == 'function') { item.def_update(item); } if (item &amp;&amp; typeof(item.update) == 'function') { item.update(item); } if (item &amp;&amp; ['SpriteArray', 'RobotixArray', 'RobotixVerticalChain'].indexOf(item.constructor.name) &gt;= 0 &amp;&amp; typeof item.each == 'function') { item.each(function(ix, graphic){ graphic.update(graphic); }); } }); Gamestack.each(this.bool_events, function(ix, item) { if (item &amp;&amp; item.bool()) { item.callback(); } }); for (var x in this.update_ext) { this.update_ext[x](); } } draw() { var __gameWindow = this; if (this.before_draw_ext) { this.before_draw_ext(); } Gamestack.each(this.drawables, function(ix, item) { if(typeof item.draw == 'function') { item.draw(__gameWindow.ctx, __gameWindow.camera); } }); if (this.after_draw_ext) { this.after_draw_ext(); } } /** * adds a call before the GameWindow draw() * * @function * @memberof GameWindow **********/ onBeforeDraw(f) { var boundCall = f.bind(this); if(!this.before_draw_ext) this.before_draw_ext = function(){}; var beforeDraw = this.before_draw_ext.bind(this); this.before_draw_ext = function() { beforeDraw(); boundCall(); }; } /** * adds a call after the GameWindow draw() * * @function * @memberof GameWindow **********/ onAfterDraw(f) { var boundCall = f.bind(this); if(!this.after_draw_ext) this.after_draw_ext = function(){}; var afterDraw = this.after_draw_ext.bind(this); this.after_draw_ext = function() { afterDraw(); boundCall(); }; } /** * sets the size of the GameWindow * * @function * @param {integer} w the width of the GameWindow * @param {integer} h the HEIGHT of the GameWindow * @memberof GameWindow **********/ Size(w, h, isAbsoluteSize) { //call with no args to fill to browser-window-size; w = w || this.canvas.parentNode.clientWidth; h = h || this.canvas.parentNode.clientHeight; var c = this.canvas; if (c) { c.setAttribute('width', w) }; if (c) { c.setAttribute('height', h) }; Gamestack.WIDTH = w; Gamestack.HEIGHT = h; this.canvas.width = w; this.canvas.height = h; this.size = new Gamestack.Vector(w, h); this.isAbsoluteSize = isAbsoluteSize || false; return this; } /** * adds an object to the GameWindow * * @function * @param {Object} obj the object to be added (Sprite) * @param {Boolean} onBottom if true, adds to the bottom of layer-stack in GameWindow * @memberof GameWindow **********/ add(obj, options={}) { var optionsGuide = { obj:'The Object{} being added into play', options:{ position:'The Vector(x, y) offset to use when drawing the obj' } }; console.info('GameWindow.add() --2nd argument options is object of arguments &gt;&gt;&gt;', optionsGuide); var layer = options.layer || this.drawables.length - 1; if(!(typeof layer == 'number' &amp;&amp; layer &gt;= 0)) layer = this.drawables.length; var offset = new Gamestack.Vector(0, 0); if(options.position) offset = options.position; obj.window_offset = offset; //1: if Sprite(), Add object to the existing __gameWindow var __inst = this; if (obj instanceof Gamestack.Camera) { this.camera = obj; } else if (obj instanceof Gamestack.GSEvent) { if (Gamestack.__running) { return console.error('Events can only be added before Gamstack.animate() is called::aka before the main update / loop begins'); } else { obj.apply(); } } else { this.drawables.splice(layer, 0, obj); }; return obj; } /** * set background-color of GameWindow * * @function * @param {string} c the new background-color for GameWindow * @memberof GameWindow **********/ Background(c) { this.canvas.style.background = c; this.canvas.style.backgroundColor = c; return this; } /** * removes an object from the GameWindow * * @function * @param {Object} obj the object to be removed (Sprite) * @memberof GameWindow **********/ remove(obj) { var ix = this.drawables.indexOf(obj); if (ix &gt;= 0) { this.drawables.splice(ix, 1); } } /** * begins the animation-loop of GameWindow. * * @function * @param {number} time optional time parameter for usage with Tween * @memberof GameWindow **********/ animate(time) { var __inst = this; requestAnimationFrame(function() { __inst.animate(); }); if (Gamestack.__stats) { Gamestack.__stats.begin(); Gamestack.__statsMS.begin(); Gamestack.__statsMB.update(); } Gamestack.isAtPlay = true; if (window.TWEEN) TWEEN.update(time); __inst.update(); console.log('Rendering'); this.renderer.render(this.scene, this.camera); this.draw(); if (Gamestack.__stats) { Gamestack.__stats.end(); Gamestack.__statsMS.end(); } } /** * begins the animation-loop of GameWindow, with performance Stats shown on-screen * * @function * @memberof GameWindow **********/ start() { if (typeof(Stats) == 'function') //Stats library exists { //basic stat animation Gamestack.__stats = new Stats(); Gamestack.__stats.showPanel(0); // 0: fps, 1: ms, 2: mb, 3+: custom Gamestack.__stats.dom.style.left = '10%'; Gamestack.__stats.dom.setAttribute('class', 'stat'); this.canvas.parentNode.appendChild(Gamestack.__stats.dom); //basic stat animation Gamestack.__statsMS = new Stats(); Gamestack.__statsMS.showPanel(1); // 0: fps, 1: ms, 2: mb, 3+: custom Gamestack.__statsMS.dom.style.left = '10%'; Gamestack.__statsMS.dom.style.marginLeft = '90px'; Gamestack.__statsMS.dom.setAttribute('class', 'stat'); this.canvas.parentNode.appendChild(Gamestack.__statsMS.dom); //basic stat animation Gamestack.__statsMB = new Stats(); Gamestack.__statsMB.showPanel(2); // 0: fps, 1: ms, 2: mb, 3+: custom Gamestack.__statsMB.dom.style.left = '10%'; Gamestack.__statsMB.dom.setAttribute('class', 'stat'); Gamestack.__statsMB.dom.style.marginLeft = '180px'; this.canvas.parentNode.appendChild(Gamestack.__statsMB.dom); } this.animate(); } } Gamestack.WebGL = WebGL; Gamestack.WebGl = WebGL; ;class RGBAColor { constructor(r=0, g=0, b=0, a=0) { this.r = r; this.g = g; this.b = b; this.a = a; } fromString(str){ str = str.replace(/^\\s*#|\\s*$/g, ''); str = str.toLowerCase(); if (ColorStrings[str]) str = ColorStrings[str]; var match; // RGB(A) if ((match = str.match(RE_RGB) || str.match(RE_RGBA))) { console.log('Processing Match::' + jstr(match)); return new Gamestack.RGBAColor( parseInt(match[1], 10), parseInt(match[2], 10), parseInt(match[3], 10), parseFloat(match.length === 4 ? 1 : match[4]) ); } } fromData(data) { return new Gamestack.RGBAColor( parseInt(data[0], 10), parseInt(data[1], 10), parseInt(data[2], 10), parseFloat(data.length === 3 ? 1 : data[3]) ); } distance(color){ var sumOfSquares = 0; sumOfSquares += Math.pow(this.r - color.r, 2); sumOfSquares += Math.pow(this.g - color.g, 2); sumOfSquares += Math.pow(this.b - color.b, 2); return Math.sqrt(sumOfSquares); } match_by_tolerance(color, tolerance) { var matches = { r:color.r, g:color.g, b:color.b }; var total_diff = 0; for(var x in matches) { var diff = Math.abs(color[x] - this[x]); console.log('COLOR-DIFF: --1::' + jstr(this) + ':: --2::' + jstr(color)); total_diff += diff; } return total_diff &lt;= tolerance; } }; Gamestack.RGBAColor = RGBAColor; var ColorStrings = { aliceblue: 'rgb(240, 248, 255)', antiquewhite: 'rgb(250, 235, 215)', aqua: 'rgb(0, 255, 255)', aquamarine: 'rgb(127, 255, 212)', azure: 'rgb(240, 255, 255)', beige: 'rgb(245, 245, 220)', bisque: 'rgb(255, 228, 196)', black: 'rgb(0, 0, 0)', blanchedalmond: 'rgb(255, 235, 205)', blue: 'rgb(0, 0, 255)', blueviolet: 'rgb(138, 43, 226)', brown: 'rgb(165, 42, 42)', burlywood: 'rgb(222, 184, 135)', cadetblue: 'rgb(95, 158, 160)', chartreuse: 'rgb(127, 255, 0)', chocolate: 'rgb(210, 105, 30)', coral: 'rgb(255, 127, 80)', cornflowerblue: 'rgb(100, 149, 237)', cornsilk: 'rgb(255, 248, 220)', crimson: 'rgb(220, 20, 60)', cyan: 'rgb(0, 255, 255)', darkblue: 'rgb(0, 0, 139)', darkcyan: 'rgb(0, 139, 139)', darkgoldenrod: 'rgb(184, 134, 11)', darkgray: 'rgb(169, 169, 169)', darkgreen: 'rgb(0, 100, 0)', darkgrey: 'rgb(169, 169, 169)', darkkhaki: 'rgb(189, 183, 107)', darkmagenta: 'rgb(139, 0, 139)', darkolivegreen: 'rgb(85, 107, 47)', darkorange: 'rgb(255, 140, 0)', darkorchid: 'rgb(153, 50, 204)', darkred: 'rgb(139, 0, 0)', darksalmon: 'rgb(233, 150, 122)', darkseagreen: 'rgb(143, 188, 143)', darkslateblue: 'rgb(72, 61, 139)', darkslategray: 'rgb(47, 79, 79)', darkslategrey: 'rgb(47, 79, 79)', darkturquoise: 'rgb(0, 206, 209)', darkviolet: 'rgb(148, 0, 211)', deeppink: 'rgb(255, 20, 147)', deepskyblue: 'rgb(0, 191, 255)', dimgray: 'rgb(105, 105, 105)', dimgrey: 'rgb(105, 105, 105)', dodgerblue: 'rgb(30, 144, 255)', firebrick: 'rgb(178, 34, 34)', floralwhite: 'rgb(255, 250, 240)', forestgreen: 'rgb(34, 139, 34)', fuchsia: 'rgb(255, 0, 255)', gainsboro: 'rgb(220, 220, 220)', ghostwhite: 'rgb(248, 248, 255)', gold: 'rgb(255, 215, 0)', goldenrod: 'rgb(218, 165, 32)', gray: 'rgb(128, 128, 128)', green: 'rgb(0, 128, 0)', greenyellow: 'rgb(173, 255, 47)', grey: 'rgb(128, 128, 128)', honeydew: 'rgb(240, 255, 240)', hotpink: 'rgb(255, 105, 180)', indianred: 'rgb(205, 92, 92)', indigo: 'rgb(75, 0, 130)', ivory: 'rgb(255, 255, 240)', khaki: 'rgb(240, 230, 140)', lavender: 'rgb(230, 230, 250)', lavenderblush: 'rgb(255, 240, 245)', lawngreen: 'rgb(124, 252, 0)', lemonchiffon: 'rgb(255, 250, 205)', lightblue: 'rgb(173, 216, 230)', lightcoral: 'rgb(240, 128, 128)', lightcyan: 'rgb(224, 255, 255)', lightgoldenrodyellow: 'rgb(250, 250, 210)', lightgray: 'rgb(211, 211, 211)', lightgreen: 'rgb(144, 238, 144)', lightgrey: 'rgb(211, 211, 211)', lightpink: 'rgb(255, 182, 193)', lightsalmon: 'rgb(255, 160, 122)', lightseagreen: 'rgb(32, 178, 170)', lightskyblue: 'rgb(135, 206, 250)', lightslategray: 'rgb(119, 136, 153)', lightslategrey: 'rgb(119, 136, 153)', lightsteelblue: 'rgb(176, 196, 222)', lightyellow: 'rgb(255, 255, 224)', lime: 'rgb(0, 255, 0)', limegreen: 'rgb(50, 205, 50)', linen: 'rgb(250, 240, 230)', magenta: 'rgb(255, 0, 255)', maroon: 'rgb(128, 0, 0)', mediumaquamarine: 'rgb(102, 205, 170)', mediumblue: 'rgb(0, 0, 205)', mediumorchid: 'rgb(186, 85, 211)', mediumpurple: 'rgb(147, 112, 219)', mediumseagreen: 'rgb(60, 179, 113)', mediumslateblue: 'rgb(123, 104, 238)', mediumspringgreen: 'rgb(0, 250, 154)', mediumturquoise: 'rgb(72, 209, 204)', mediumvioletred: 'rgb(199, 21, 133)', midnightblue: 'rgb(25, 25, 112)', mintcream: 'rgb(245, 255, 250)', mistyrose: 'rgb(255, 228, 225)', moccasin: 'rgb(255, 228, 181)', navajowhite: 'rgb(255, 222, 173)', navy: 'rgb(0, 0, 128)', oldlace: 'rgb(253, 245, 230)', olive: 'rgb(128, 128, 0)', olivedrab: 'rgb(107, 142, 35)', orange: 'rgb(255, 165, 0)', orangered: 'rgb(255, 69, 0)', orchid: 'rgb(218, 112, 214)', palegoldenrod: 'rgb(238, 232, 170)', palegreen: 'rgb(152, 251, 152)', paleturquoise: 'rgb(175, 238, 238)', palevioletred: 'rgb(219, 112, 147)', papayawhip: 'rgb(255, 239, 213)', peachpuff: 'rgb(255, 218, 185)', peru: 'rgb(205, 133, 63)', pink: 'rgb(255, 192, 203)', plum: 'rgb(221, 160, 221)', powderblue: 'rgb(176, 224, 230)', purple: 'rgb(128, 0, 128)', red: 'rgb(255, 0, 0)', rosybrown: 'rgb(188, 143, 143)', royalblue: 'rgb(65, 105, 225)', saddlebrown: 'rgb(139, 69, 19)', salmon: 'rgb(250, 128, 114)', sandybrown: 'rgb(244, 164, 96)', seagreen: 'rgb(46, 139, 87)', seashell: 'rgb(255, 245, 238)', sienna: 'rgb(160, 82, 45)', silver: 'rgb(192, 192, 192)', skyblue: 'rgb(135, 206, 235)', slateblue: 'rgb(106, 90, 205)', slategray: 'rgb(112, 128, 144)', slategrey: 'rgb(112, 128, 144)', snow: 'rgb(255, 250, 250)', springgreen: 'rgb(0, 255, 127)', steelblue: 'rgb(70, 130, 180)', tan: 'rgb(210, 180, 140)', teal: 'rgb(0, 128, 128)', thistle: 'rgb(216, 191, 216)', tomato: 'rgb(255, 99, 71)', turquoise: 'rgb(64, 224, 208)', violet: 'rgb(238, 130, 238)', wheat: 'rgb(245, 222, 179)', white: 'rgb(255, 255, 255)', whitesmoke: 'rgb(245, 245, 245)', yellow: 'rgb(255, 255, 0)', yellowgreen: 'rgb(154, 205, 50)', map_orange: 'rgb(255, 106, 0)', map_green: 'rgb(76, 255, 0)', map_red: 'rgb(255, 0, 0)', map_blue: 'rgb(0, 38, 255)', map_darkgreen: 'rgb(38, 127, 0)', map_yellow: 'rgb(255, 216, 0)', map_aqua: 'rgb(0, 255, 255)', map_grey: 'rgb(128, 128, 128)', map_gray: 'rgb(128, 128, 128)', map_darkgrey: 'rgb(64, 64, 64)', map_darkgray: 'rgb(64, 64, 64)', map_black: 'rgb(0, 0, 0)', }; var RE_RGB = /^rgb\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)$/; Gamestack.Colors = {}; Gamestack.PixelMapColors = {}; for(var x in ColorStrings) { if(ColorStrings.hasOwnProperty(x)) { Gamestack.Colors[x] = new Gamestack.RGBAColor().fromString(x); } } ;(function() { console.log('GSEvent class... creating'); class GSEvent { constructor(args = {}) { // Gamestack.Modifiers.informable(this, args); } } class MouseMoveEvent { constructor(callback) { callback = callback || function(x, y) {}; this.Callback(callback); } Callback(cb) { Gamestack.InputSystem.extend('mousemove', function(x, y) { cb(x, y); }); } }; Gamestack.MouseMoveEvent = MouseMoveEvent; class MousePosEvent { constructor(callback) { callback = callback || function(x, y) {}; this.Callback(callback); } Callback(cb) { Gamestack.InputSystem.extend('mousepos', function(x, y) { cb(x, y); }); } }; Gamestack.MousePosEvent = MousePosEvent; class MouseLeftClickEvent { constructor(callback) { callback = callback || function(x, y) {}; this.Callback(callback); } Callback(cb) { Gamestack.InputSystem.extend('leftclick', function(x, y) { cb(x, y); }); } }; Gamestack.MouseLeftClickEvent = MouseLeftClickEvent; class MouseRightClickEvent { constructor(callback) { callback = callback || function(x, y) {}; this.Callback(callback); } Callback(cb) { Gamestack.InputSystem.extend('rightclick', function(x, y) { cb(x, y); }); } }; Gamestack.MouseRightClickEvent = MouseRightClickEvent; function GSEventLink(extendedObject, extendedKey, extendor, extendorKey) { this.parent_id = extendedObject.id, this.child_id = extendor.id, this.parent_key = extendedKey, this.child_key = extendorKey; }; /** * Creates an instance of InputEvent * &lt;info-bit&gt; Gamestack.InputEvent runs a callback function when a specified input is triggered&lt;/info-bit&gt; * * &lt;tip is=\"p\"&gt;Instead of calling * * @param {Object} args object of arguments * @param {number} args.btnix the index of controller-button to be applied * @param {number} args.gpix the index of pc-gamepad --the 1st gamepad will have index 0 * @param {number} args.stickix the controller-stick-index to be applied * @param {Array} args.keys array of strings for keys to be applied * @param {Function} args.callback the function to call when InputEvent is triggered * @returns {Gamestack.InputEvent} a Gamestack.InputEvent object */ class InputEvent extends GSEvent { constructor(args) { super(args); var btnix = args.btnix || args.button_ix || false, gpix = args.gpix || args.gamepad_ix || 0, callback = args.callback || function() { }; var six = args.stickix || args.six || args.stick_ix || false; var inputKey = six !== false ? 'stick_' + six : btnix !== false ? 'button_' + btnix : false; //Keys: var keyboardKeys = Larva.arrayWrap(args.keys || []); //Run the Q() function if (keyboardKeys instanceof Array) { Gamestack.each(keyboardKeys, function(ix, keyitem) { Gamestack.InputSystem.extendKey('key_' + keyitem.toLowerCase(), function() { callback(keyitem.toLowerCase()); }); }); } if (inputKey &amp;&amp; gpix &gt;= 0) { Gamestack.GamepadAdapter.on(inputKey, gpix, function(x, y) { callback(x, y); }); } } }; /** * * @extends InputEvent * * Creates an instance of KeyboardEvent * &lt;info-bit&gt; Gamestack.KeyboardEvent runs a callback function when keyboard-keys are pressed&lt;/info-bit&gt; * @param {Array | string} keys the Array of keys or single string-key for this event * @param {Function} callback the callback-function to be called when this event is triggered * @returns {Gamestack.KeyboardEvent} */ class KeyboardEvent extends InputEvent { constructor(keys = keys instanceof Array ? keys : [keys], callback = function() {}) { super({}); this.keys = keys; this.callback = callback; } init() { var keyboardKeys = this.keys; var __inst = this; if (keyboardKeys instanceof Array) { Gamestack.each(keyboardKeys, function(ix, keyitem) { Gamestack.InputSystem.extendKey('key_' + keyitem.toLowerCase(), function() { __inst.callback(keyitem.toLowerCase()); }); }); } } Keys(keys = []) { this.keys = Larva.arrayWrap(keys) return this; } Call(callback = function() {}) { this.callback = callback; this.init(); return this; } }; /** * * @extends InputEvent * * Creates an instance of GamepadEvent * &lt;info-bit&gt; Gamestack.GamepadEvent runs a callback function when any specified gamepad-buttons or gamepad-sticks are pressed&lt;/info-bit&gt; * @param {Array | string} gamepadKeys the Array of gamepadKeys or single string-key, representing gamepad-buttons or gamepad-sticks for this event * @param {Function} callback the callback-function to be called when this event is triggered * @returns {Gamestack.GamepadEvent} */ class GamepadEvent extends InputEvent { constructor(keys = [], callback = function() {}) { super({}); this.keys = keys; this.callback = callback; } Gamepads(gps = []) { this.gps = gps = Larva.arrayWrap(gps || []); return this; } init() { var gamepadKeys = Larva.arrayWrap(this.keys || []); var __inst = this; Gamestack.GamepadAdapter.on(gamepadKeys, this.gps, function(x, y) { __inst.callback(x, y); }); } Keys(keys = []) { this.keys = Larva.arrayWrap(keys); return this; } Call(callback = function() {}) { this.callback = callback; this.init(); return this; } }; class CollisionEvent extends GSEvent { constructor(args = {}) { super(args); } /** * applies objects and siblings to be compared for the CollisionEvent instance * @memberof CollisionEvent * @param {Array} objects the main-objects for collision processing * @param {Array} siblings the comparable-objects for collision processing * @returns {CollisionEvent} the current instance of CollisionEvent, reference to 'this' keyword */ OnCollision(objects, siblings) { this.objects = Larva.arrayWrap(objects || this.objects || []); this.siblings = Larva.arrayWrap(siblings || this.siblings || []); return this; } /** * applies a callback to be called whenever the onBool function returns true * @memberof CollisionEvent * @param {callbackFunction} callbackFunction the function to be called --replaces the value of collisionEvent.callback * @returns {CollisionEvent} the current instance of CollisionEvent, reference to 'this' keyword */ Call(callbackFunction) { this.callback = callbackFunction || this.callback || function() {}; let $collision = this; this.objects.forEach(function($obj){ $obj.onUpdate(function(){ var $sprite = this; $collision.siblings.forEach(function($sib){ if($sprite.hasBoxCollision($sib)) { $collision.callback($sprite, $sib); } }); }); }); return this; } }; /** * returns BoolEvent --allows code to run whenever a conditional-function returns true * @param {onBool} onBool the function to be tested each update * @param {call} call the function to be called when onBool returns true; * @returns {BoolEvent} a Gamestack.BoolEvent object */ class BoolEvent extends GSEvent { constructor(onBool, callback) { super({}); this.bool = onBool || function() { console.info('CustomBoolEvent():needs .on function(){}. --Add this as 1st argument or via chainable On() function returning bool argument'); } /*Defaults to false to avoid broken code*/ this.callback = callback || function() { console.info('CustomBoolEvent():needs .callback function(){} --Add this as 2nd argument or via chainable Call() function'); }; Gamestack.gs_events.push(this); } /** * applies a boolFunction to be tested for true each update * @param {boolFunction} boolFunction the function to be tested each update --replaces the value of boolEvent.onBool * @returns {BoolEvent} the current instance of BoolEvent, reference to 'this' keyword */ On(boolFunction) { this.bool = boolFunction; return this; } /** * applies a callback to be called whenever the onBool function returns true * @memberof BoolEvent * @param {callbackFunction} callbackFunction the function to be called --replaces the value of boolEvent.callback * @returns {BoolEvent} the current instance of BoolEvent, reference to 'this' keyword */ Call(callbackFunction) { this.callback = callbackFunction || this.callback || function() {}; return this; } }; BoolEvent.Bool = BoolEvent.On; Gamestack.GSEvent = GSEvent; Gamestack.GSEventLink = GSEventLink; Gamestack.InputEvent = InputEvent; Gamestack.GamepadEvent = GamepadEvent; Gamestack.KeyboardEvent = KeyboardEvent; Gamestack.CollisionEvent = CollisionEvent; Gamestack.BoxCollisionEvent = CollisionEvent; Gamestack.BoolEvent = BoolEvent; })(); ;(function () { console.log('Frame class... creating'); /** * Creates an instance of Frame * * &lt;info-bit&gt;Gamestack.Frame is called automatically by Gamestack.Sprite and Gamestack.Animation. * Gamestack.Frame does not take arguments. * It is instantiated, then initilized with chainable function-calls.&lt;/info-bit&gt; * * @returns {Frame} * * @example * * var selected_frame = new Gamestack.Frame().Image(gameImage).Size(frameSizeVector); */ class Frame { constructor() { var __inst = this; this.framePos = new Gamestack.Vector(0, 0); } Image(src) { this.image = new Gamestack.GameImage(src); return this; } onLoad(fxn){ fxn = fxn || function(){}; fxn = fxn.bind(this); this.image.domElement.onload = function(){ fxn(); }; } Size(s) { this.size = new Gamestack.Vector(s, s, s); this.frameSize = new Gamestack.Vector(s, s, s); return this; } Position(p) { this.position = new Gamestack.Vector(p, p, p); this.framePos = new Gamestack.Vector(p, p, p); return this; } FramePos(p) { this.position = new Gamestack.Vector(p, p, p); this.framePos = new Gamestack.Vector(p, p, p); return this; } StoreOffscreen(){ this.offscreen = new Gamestack.OffscreenCanvasRendering(this.image); for(var x in this.offscreen) { if(x == 'ctx' || x == 'canvas') this[x] = this.offscreen[x]; } return this; } getURL(){ this.StoreOffscreen(); return this.offscreen.canvas.toDataURL(); } getColoredPixelGrid(unitSize=5) { var grid = []; let min = this.framePos, max = this.framePos.add(this.frameSize); for (var x = min.x; x &lt;= max.x; x += unitSize) { for (var y = min.y; y &lt;= max.y; y += unitSize) { // Fetch pixel at current position var pixel = this.ctx.getImageData(x, y, 1, 1); // Check that opacity is above zero if (pixel.data[3] != 0) { var vector = new Gamestack.Vector(x, y), gridObject = { position: vector, size: new Gamestack.Vector(unitSize, unitSize), pixel:pixel }; grid.push(gridObject); } } } return grid; } getFullPixelGrid(unitSize=5) { var grid = []; let min = this.framePos, max = this.framePos.add(this.frameSize); for (var x = min.x; x &lt;= max.x; x += unitSize) { for (var y = min.y; y &lt;= max.y; y += unitSize) { // Fetch pixel at current position var pixel = this.ctx.getImageData(x, y, 1, 1); // Check that opacity is above zero var vector = new Gamestack.Vector(x, y), gridObject = { position: vector, size: new Gamestack.Vector(unitSize, unitSize), pixel:pixel }; grid.push(gridObject); } } return grid; } /** * Creates and returns a ColorMap for this animation, allowing opacity-based pixel-collision. * * @function * @param {number} unitDimen a Colormap grid-unit-size --A larger unitDimen decreases accuracy, and results in faster-processing. * @memberof Animation **********/ createColorMap(size, altImage) { if (!(altImage || this.image &amp;&amp; this.image.domElement)) return this; this.StoreOffscreen(); this.colorMap = this.getColoredPixelGrid(size, this.testCtx); return this.colorMap; } createFullPixelMap(size, altImage) { if (!(altImage || this.image &amp;&amp; this.image.domElement)) return this; this.StoreOffscreen(); this.fullPixelMap = this.getFullPixelGrid(size, this.testCtx); return this.fullPixelMap; } } Gamestack.Frame = Frame; })(); ;/** * @ignore * */ class ControllerEventKeys { constructor() { return { left_stick: false, right_stick: false, 0: false, 1: false, 2: false, 3: false, 4: false, 5: false, 6: false, 7: false, 8: false, 9: false, 10: false, 11: false, 12: false, 13: false, 14: false, 15: false, 16: false, 17: false, 18: false, 19: false } } } Gamestack.ControllerEventKeys = ControllerEventKeys; /** * Creates an instance of GamepadAdapter: --instead use the existing: Gamestack.GamepadAdapter, a working instance of this class. * -supports game-controller input for web-games * -accesses live gamepad input from the HTML5 Gamepad Api * @returns {GamepadAdapter} an instance of GamepadAdapter * */ Gamestack.gamepads = Gamestack.gamepads || []; class GamepadAdapter { constructor() { this.__gamepads = []; this.intervals = []; let controller_stack = this; let __gamepadMaster = this; this.events = []; window.addEventListener(\"gamepadconnected\", function (e) { console.log(\"Gamepad connected at index %d: %s. %d buttons, %d axes.\", e.gamepad.index, e.gamepad.id, e.gamepad.buttons.length, e.gamepad.axes.length); if (__gamepadMaster.mainLoop) { window.clearInterval(__gamepadMaster.mainLoop); } __gamepadMaster.mainLoop = window.setInterval(function () { var gps = navigator.getGamepads(); __gamepadMaster.gps = gps; for (var x = 0; x &lt; gps.length; x++) { var events = __gamepadMaster.__gamepads[x] ? __gamepadMaster.__gamepads[x] : {}; __gamepadMaster.process(__gamepadMaster.gps[x], events); } }, 20); }); } gamepads() { return navigator.getGamepads(); } disconnect_all() { for (var x = 0; x &lt; this.intervals.length; x++) { window.clearInterval(this.intervals[x]); } } disconnect_by_index(game_pad_index) { window.clearInterval(this.intervals[game_pad_index]); } hasAnyPad() { return \"getGamepads\" in navigator; } Event(key, game_pad, callback) { return { key: key, game_pad: game_pad, callback: callback } } GamepadEvents(args) { var gp = {}; gp.stick_left = args.stick_left || function (x, y) { // console.log('Def call'); } gp.stick_right = args.stick_right || function (x, y) { } gp.buttons = []; gp.extendFunc = function (f1, f2) { var fc = f2; return function (x, y) { f2(x, y); f1(x, y); } }; gp.on = function (key, callback) { if (this[key] &amp;&amp; key !== \"on\") { var current_cb = typeof(this[key]) == 'function' ? this[key] : function (x, y) { }; this[key] = this.extendFunc(callback, current_cb); } else if (key.indexOf('button') &gt;= 0 &amp;&amp; key.indexOf('_') &gt;= 0) { var parts = key.split('_'); var number; try { number = parseInt(parts[1]); var current_cb = typeof(this['buttons'][number]) == 'function' ? this['buttons'][number] : function (x, y) { }; this['buttons'][number] = this.extendFunc(callback, current_cb); } catch (e) { console.error('could not parse \"on\" event with ' + key); } } } gp.constructor = {name: \"GamepadEvents\"}; this.__gamepads.push(gp); Gamestack.gamepads = this.__gamepads; return gp; } getGamepads() { return Gamestack.gamepads; } process(gp, gpEvents) { this.process_buttons(gp, gpEvents); this.process_axes(gp, gpEvents); } process_axes(gp, events) { if (!gp || !gp['axes']) { return false; } for (var i = 0; i &lt; gp.axes.length; i += 2) { var axis1 = gp.axes[i], axia2 = gp.axes[i + 1]; var ix = (Math.ceil(i / 2) + 1), x = gp.axes[i], y = gp.axes[i + 1]; if (ix == 1 &amp;&amp; events.stick_left) { events.stick_left(x, y); } if (ix == 2 &amp;&amp; events.stick_right) { events.stick_right(x, y); } if (this.events &amp;&amp; this.events['stick_' + i] &amp;&amp; typeof(this.events['stick_' + i].callback) == 'function') { this.events['stick_' + i].callback(); } } } process_buttons(gp, events) { if (!gp || !gp['buttons']) { return false; } for (var i = 0; i &lt; gp.buttons.length; i++) { if (!events.buttons) break; else if (events.buttons.length &gt; i &amp;&amp; typeof(events.buttons[i]) == 'function') { events.buttons[i](gp.buttons[i].pressed); } else if (events.buttons.length &gt; i &amp;&amp; typeof(events.buttons[i]) == 'object' &amp;&amp; typeof(events.buttons[i].update) == 'function') { events.buttons[i].update(events.buttons[i].pressed); } var clearance_1 = this.events &amp;&amp; this.events[i], gpc, bkey = \"button_\" + i; if (clearance_1) { gpc = this.events[bkey] &amp;&amp; !isNaN(this.events[bkey].game_pad) ? this.gamepads[this.events[bkey].game_pad] : this.events[bkey].game_pad; } ; if (clearance_1 &amp;&amp; gpc &amp;&amp; typeof(this.events[bkey].callback) == 'function') { //call the callback this.events[i].callback(); } } } on(key, gpix, callback) { var keys = Larva.arrayWrap(key || []), gps = Larva.arrayWrap(gpix || []);; for(var x in keys) { for(var y in gps) { if (gps[y] &gt;= this.__gamepads.length) { this.__gamepads.push(this.GamepadEvents({})); } this.__gamepads[y].on(keys[x], callback); } } } } /********** * NOTE: here we bind the instance, and NOT the instantiator. * * *********/ if (!Gamestack.GamepadAdapter) { Gamestack.GamepadAdapter = new GamepadAdapter(); // __gameInstance.gamepads.push(gamepad); } ;class Line2d extends Scriptable { constructor() { super(); this.Object(this); this.points = []; this.position = new Gamestack.Vector(0, 0); this.size = new Gamestack.Vector(0, 0); this.index = 0; this.call = function() {}; } StepFunction(call) { this.call = call; return this; } next() { this.index += 1; return this.points[this.index % this.points.length]; } Color(c) { this.color = c; return this; } Fill() { for (var x = 1; x &lt;= this.size.x; x++) { var x_total = this.size.x; var out_of_1 = x / x_total; var next_x = this.position.x + x; console.log('using x portion::' + out_of_1); var next_y = this.position.y + (this.size.y * this.call(out_of_1, 1.0)), next_point = new Gamestack.Vector(next_x, next_y); this.points.push(next_point); } return this; } getOffsetPos(pos){ var offset = this.window_offset || new Gamestack.Vector(0, 0); return pos.add(offset); } draw(ctx, camera) { ctx = ctx || Gamestack.game_windows[0].ctx; camera = camera || Gamestack.game_windows[0].camera; var points = this.points; ctx.save(); ctx.strokeStyle = this.color; ctx.beginPath(); if (points instanceof Array) { for (var x = 0; x &lt; points.length; x++) { var p = points[x]; var position = p.position || p; var real_pos = this.getOffsetPos(position); if (real_pos.hasOwnProperty('x') &amp;&amp; real_pos.hasOwnProperty('y')) { if (x == 0) ctx.moveTo(real_pos.x, real_pos.y) else { ctx.lineTo(real_pos.x, real_pos.y); } } } } ctx.stroke(); ctx.restore(); } } Gamestack.Line2d = Line2d; Gamestack.Line2D = Line2d; ; /** * Creates a Sound instance. Implements HTML5-Audio object * --DevTODO : complete docs for the Sound class * * @param {string} src the source-path of the targeted sound-file * @returns {Sound} instance of Gamestack.Sound * */ class Sound { constructor(src, data) { if (typeof(src) == 'object') { this.sound = document.createElement('audio'); this.sound.src = src.src; this.src = src.src; } else if (typeof(src) == 'string') { this.sound = document.createElement('audio'); this.sound.src = src; this.src = src; } if(typeof(data)=='object') { for (var x in data) { if (x !== 'sound') { this[x] = data[x]; } } } this.onLoad = this.onLoad || function () { }; if (typeof(this.onLoad) == 'function') { this.onLoad(this.sound); } } Loop(loop) { this.sound.loop = loop || true; return this; } loop(loop) //same as Loop() { this.sound.loop = loop || true; return this; } Volume(val) { this.sound.volume = val; return this; } volume(val) //same as Volume() { this.sound.volume = val; return this; } Play() { if (typeof(this.sound) == 'object' &amp;&amp; typeof(this.sound.play) == 'function') { this.sound.play(); } return this; } play() { //same as Play() if (typeof(this.sound) == 'object' &amp;&amp; typeof(this.sound.play) == 'function') { this.sound.play(); } return this; } } class SoundList{ constructor(list) { this.cix = 1; this.sounds = []; if(list instanceof Array) { for(var x in list) { if(list[x].src) { this.sounds.push(new Sound(list[x].src, list[x])); } else if(typeof(list[x]) == 'string') { this.sounds.push(new Sound(list[x])); } } } } add(src, name) { if(typeof(src) == 'object' &amp;&amp; src.src) { this.sounds.push(new Sound(src.src, src)); } else if(typeof(src) == 'string') { var data = {}; if(name) { data.name = name; } this.sounds.push(new Sound(list[x], data)); } } Volume(v) { for(var x = 0; x &lt; this.sounds.length;x++) { this.sounds[x].volume(v); } return this; } volume(v) { for(var x = 0; x &lt; this.sounds.length;x++) { this.sounds[x].volume(v); } return this; } PlayNext() { this.sounds[this.cix % this.sounds.length].play(); this.cix += 1; } Play() { this.sounds[this.cix % this.sounds.length].play(); this.cix += 1; } playNext() //same as PlayNext() { this.sounds[this.cix % this.sounds.length].play(); this.cix += 1; } play() //same as Play() { this.sounds[this.cix % this.sounds.length].play(); this.cix += 1; } } Gamestack.Sound = Sound; Gamestack.SoundList = SoundList; ; var THREE_EXT = { defaults:{ DodecahedronGeometry:{radius:1, detail:0}, SphereGeometry:{radius:5, widthSegments:32, heightSegments:32}, BoxGeometry:{ width:20, height:20, depth:20 }, CylinderGeometry:{radiusTop:5, radiusBottom:5, height:20, heightSegments:32}, TorusGeometry:{radius:10, tube:3, radialSegments:16, tubularSegments:100 } } } class Three //dependency: THREE.js { constructor(args={}) { if(!THREE) //THREE.js library must be loaded { return console.error('ThreeJSObject():Library: Three.js is required for this object.'); } this.scene = new THREE.Scene(); if(args.geometry instanceof String &amp;&amp; THREE[args.geometry]) { this.geometry = new THREE[args.geometry](); } else { this.geometry = args.geometry || new THREE.TorusGeometry(50, 10, 16, 100); } this.scene.add( new THREE.AmbientLight( 0xffffff, 1.0 ) ); this.renderer = Gamestack.renderer || new THREE.WebGLRenderer({ preserveDrawingBuffer: true, alpha:true }); this.renderer.setSize(1000, 1000); this.camera = new THREE.PerspectiveCamera(70, 1, 1, 1000); this.camera.position.z = 1000 / 8; var __inst = this; var src = args.src || \"../assets/game/image/tiles/perlin_3.png\"; __inst.loader = new THREE.TextureLoader(); __inst.loader.load( src, function ( texture ) { __inst.material = args.material || new THREE.MeshPhongMaterial({ map: texture }); if(!__inst.__init) { __inst.mesh = new THREE.Mesh(__inst.geometry, __inst.material); __inst.scene.add(__inst.mesh); __inst.__init = true; } //__inst.mesh.size.set(__inst.size); __inst.renderer.render(__inst.scene, __inst.camera); __ServerSideFile.file_upload('test.png', __inst.renderer.domElement.toDataURL('image/png'), function(relpath, content){ relpath = relpath.replace('client/', '../'); __inst.selected_animation = new Animation({src:relpath, frameSize:new Vector(1000, 1000), frameBounds:new VectorFrameBounds(new Vector(0, 0, 0), new Vector(0, 0, 0),new Vector(0, 0, 0))}).singleFrame(); __inst.selected_animation.image.domElement.onload = function() { __inst.setSize(new Vector(__inst.selected_animation.image.domElement.width, __inst.selected_animation.image.domElement.height)); __inst.selected_animation.animate(); console.log(jstr(__inst.selected_animation.frames)); }; }); } ); } three_update() { console.log('THREE --GS-Object UPDATE'); this.mesh.rotation.y += 0.05; this.renderer.clear(); this.renderer.setSize(this.size.x, this.size.y); var pixels = new Uint8Array(this.size.x * this.size.y * 4); this.renderer.render(this.scene, this.camera); var gl = this.renderer.getContext(); gl.readPixels( 0, 0, this.size.x, this.size.y, gl.RGBA, gl.UNSIGNED_BYTE, pixels ); this.selected_animation.selected_frame = {image:{}}; this.selected_animation.selected_frame.image.data = new ImageData(new Uint8ClampedArray(pixels), this.size.x, this.size.y); } applyAnimativeState() { } } ;(function () { console.log('Animation class... creating'); /** * * Creates an instance of Animation with one or more Frames. * * &lt;iframe style='width:400px; height:450px; overflow:hidden;' src='../client/examples/js-class/Animation.html'&gt; &lt;/iframe&gt; * * @param {string=} [src] the src-image-path for this Animation * @returns {Animation} an Animation object * * @example * * //constructor call: Creates a single-frame Animation from src * var singleFrameAnime = new Animation('directory/myFile.png'); * * @example * //constructor call with chainable function-calls: Creates multi-frame Animation from src, then sets properties with chainable-function-calls. * var multiFrameAnime = new Gamestack.Animation('../images/characters/full/spaceman1.png') //constructor is called * .FrameSize(130, 130) * .FrameBounds(new Gamestack.Vector(9, 0), new Gamestack.Vector(23, 0), new Gamestack.Vector(23, 0)) * .Seesaw() //The Animation will play back-and-forth repeatedly (cycle through frames forwards, then backwards and so on. * .Duration(900); //Animation lasts 900 millis OR just under 1 second * * @design * * //single-responsibility : to define a list of frames, then progress that list of frames with a 'selected_frame' property * var singleFrameAnime = new Animation('directory/myFile.png'); */ class Animation { constructor(src={}) { var args = typeof(src) == 'object' ? src : {}; //Gamestack.Modifiers.informable(this, args); if (typeof src == 'string') { this.Src(src, args.frameBounds); } else if(args instanceof Gamestack.GameImage) { console.log('Animation(): args are an instance of GameImage'); this.image = args; } else if(args instanceof HTMLImageElement) { console.log('Animation(): args was an instance of HTMLImageElement'); this.image = new Gamestack.GameImage(args); } else if(args instanceof Gamestack.Animation) { this.image = args.image; } else if(typeof(args)=='object' &amp;&amp; args.src) { this.src = args.src; this.image = new Gamestack.GameImage(args.src); } /** * @property {Vector} frameSize the frameSize of the Animation * @memberof Animation **********/ this.frameSize = this.frameSize || new Gamestack.Vector(args.frameSize || new Gamestack.Vector(0, 0)); if (args.frameBounds &amp;&amp; args.frameBounds.min &amp;&amp; args.frameBounds.max) { /** * @property {VectorFrameBounds} frameBounds the frameBounds of the Animation, has three Vectors * @memberof Animation **********/ this.frameBounds = new Gamestack.VectorFrameBounds(args.frameBounds.min, args.frameBounds.max, args.frameBounds.termPoint); } else { this.frameBounds = new Gamestack.VectorFrameBounds(new Gamestack.Vector(0, 0, 0), new Gamestack.Vector(0, 0, 0), new Gamestack.Vector(0, 0, 0)); } this.frameOffset = this.getArg(args, 'frameOffset', new Gamestack.Vector(0, 0, 0)); this.apply2DFrames(); this.flipX = this.getArg(args, 'flipX', false); this.cix = 0; /** * @property {Frame} selected_frame the selected_frame of the Animation, a Gamestack.Frame * @memberof Animation **********/ this.selected_frame = this.frames[0] || false; this.timer = 0; this.duration = args.duration || 2000; this.seesaw_mode = args.seesaw_mode || false; this.reverse_frames = args.reverse_frames || false; this.run_ext = args.run_ext || []; this.complete_ext = args.complete_ext || []; // this.colorMap = this.createColorMap(5); } Src(src, options={}){ if (typeof src == 'string') { console.log('setting GameImage with string:' + src); this.src = src; this.image = new Gamestack.GameImage(src); } else if(src instanceof GameImage) { console.log('Animation(): args are an instance of GameImage'); this.image = src; } else if(src instanceof HTMLImageElement) { console.log('Animation(): args was an instance of HTMLImageElement'); this.image = new Gamestack.GameImage(src); } if(!options.frameBounds) this.init_singleFrame(); return this; } Image(src){ if (typeof(src) == 'string') { console.log('setting GameImage with string:' + src); this.src = src; this.image = new Gamestack.GameImage(src); } else if(src instanceof Gamestack.GameImage) { console.log('Animation(): args are an instance of GameImage'); this.image = src; } else if(src instanceof HTMLImageElement) { console.log('Animation(): args was an instance of HTMLImageElement'); this.image = new Gamestack.GameImage(src); } this.init_singleFrame(); return this; } /** * sets this Animation to a single-frame-animation, from existing image * @function * @memberof Animation **********/ init_singleFrame() { var __inst = this; this.image.domElement.onload = function () { if(!__inst.__isInit) __inst.FrameSize(__inst.image.domElement.width, __inst.image.domElement.height) .FrameBounds(new Gamestack.Vector(0, 0), new Gamestack.Vector(0, 0)); __inst.run(); }; Gamestack.log('Animation():set single-frame animation'); return this; } /***** * Overridable / Extendable functions * -allows stacking of external object-function calls ******/ /** * Provides a function to be called whenever this Animation starts. Function should run every time the Animation reaches frame-index 0 * * @function * @params {Function} call the function to be called on start * @memberof Animation **********/ onRun(call) { if (this.run_ext.indexOf(call) == -1) { this.run_ext.push(call.bind(this)); } } /** * Provides a function to be called whenever this Animation completes. Function should run every time the Animation reaches it's last frame-index. * * @function * @params {Function} call the function to be called on complete * @memberof Animation **********/ onComplete(call) { if (this.complete_ext.indexOf(call) == -1) { this.complete_ext.push(call.bind(this)); } } call_on_run() { //call any function extension that is present for (var x = 0; x &lt; this.run_ext.length; x++) { this.run_ext[x](this); } } call_on_complete() { //call any function extension that is present for (var x = 0; x &lt; this.complete_ext.length; x++) { this.complete_ext[x](this); } } FrameSize(w, h) { this.frameSize = new Gamestack.Vector(w, h); this.__isInit = true; this.run(); return this; } Hang(){ this._hang = true; return this; } FrameBounds(minVector, maxVector, termVector) { this.frameBounds = new Gamestack.VectorFrameBounds(minVector, maxVector, termVector); this.__isInit = true; this.run(); return this; } FrameOffset(x, y){ this.frameOffset = new Gamestack.Vector(x, y); return this; } Seesaw() { if(!this.seesaw_mode) { this.seesaw_mode = true; } return this; } Duration(millis) { this.duration = millis; return this; } /** * Reverses all frames of the animation. Frames are then expected to run backwards. * * @function * @memberof Animation **********/ ReverseFrames() { this.reverse_frames = true; return this; } /** * Declares the animation a a single frame / full-image. * * @function * @param {Vector} frameSize optional size param * @memberof Animation **********/ SingleFrame() { this.__frametype = 'single'; this.frameSize = new Gamestack.Vector(this.image.domElement.width, this.image.domElement.height); this.frameBounds = false; this.selected_frame = new Gamestack.Frame().Image(this.image).Size(this.frameSize); this.frames = []; this.frames[0] = this.selected_frame; return this; } getArg(args, key, fallback) { if (args.hasOwnProperty(key)) { return args[key]; } else { return fallback; } } init(){ this.apply2DFrames(); return this; } apply2DFrames() { this.frames = []; var fcount = 0; var quitLoop = false; for (let y = this.frameBounds.min.y; y &lt;= this.frameBounds.max.y; y++) { for (let x = this.frameBounds.min.x; x &lt;= this.frameBounds.max.x; x++) { let framePos = { x: x * this.frameSize.x + this.frameOffset.x, y: y * this.frameSize.y + this.frameOffset.y }; var f = new Gamestack.Frame().Image(this.image).Size(this.frameSize).Position(framePos); this.frames.push(f); if (x &gt;= this.frameBounds.termPoint.x &amp;&amp; y &gt;= this.frameBounds.termPoint.y) { quitLoop = true; break; } fcount += 1; if (quitLoop) break; } } this.frames[0] = this.selected_frame = this.frames[0] || new Gamestack.Frame().Image(this.image).Size(this.frameSize); if (this.seesaw_mode) { // console.log('Animation: applying seesaw'); var frames_reversed = this.frames.slice().reverse(); this.frames.pop(); this.frames = this.frames.concat(frames_reversed); } if (this.reverse_frames) { this.frames.reverse(); } } scaleOf(sized_Object) { var s = Larva.getPreferredPropertyByKey(sized_Object, 'size', 'argument had nested size variable. Using this instead.'); return s.div(this.frameSize); } init_colorMap() { Larva.info('init_colorMap()'); if(!Larva.allDefined([this.image, this.image.domElement])) return []; this.canvasObject = this.canvasObject || new Gamestack.OffscreenCanvasRendering(this.image); this.colorMap = this.colorMap || this.ColoredPixelGrid(); return this.colorMap; } ColoredPixelGrid() { I('ColoredPixelGrid()'); var image = this.image.domElement, ctx = this.canvasObject.ctx, grid = [], frameSizeDiv = this.selected_frame.frameSize.div(12).round(); for (var x = 0; x &lt;= image.width; x+= frameSizeDiv.x) { for (var y = 0; y &lt;= image.height; y+= frameSizeDiv.y) { // Fetch pixel at current position var pixel = ctx.getImageData(x, y, 1, 1); // Check that opacity is above zero if (pixel.data[3] != 0) { var vector = new Gamestack.Vector(x, y), gridObject = { position:vector, size:frameSizeDiv }; grid.push(gridObject); } } } return grid; } /** * Returns the existing ColorMap for this animation. * * @function * @memberof Animation **********/ getCurrentPixelMap() { Larva.info('getCurrentPixelMap()'); var map = []; var frame = this.selected_frame; let __inst = this; this.colorMap = this.init_colorMap(); for(var x in this.colorMap) { var c = this.colorMap[x]; if(Gamestack.Collision.boxesCollide(frame.framePos, frame.frameSize, c.position, c.size)) { map.push(c); } } return map; } /** * Sets the frame to a specific array-index. * * @function * @param {number} ix the frame-index to apply. * @memberof Animation **********/ setFrame(ix) { this.selected_frame = this.frames[ix]; } update() { if(this._hang &amp;&amp; this.cix &gt;= this.frames.length - 1) { this.cix = this.frames.length - 1 } this.selected_frame = this.frames[Math.round(this.cix) % this.frames.length]; } reset() { this.apply2DFrames(); this.cix = 0; } /** * Applies a continuous animation. Use this in parent-sprite's update if continuous animation is required. * Also works as a single call at any time during game-update. * * @function * @memberof Animation **********/ run() { if (this.__frametype == 'single') { return 0; } this.apply2DFrames(); //update once: this.update(); if (this.cix == 0) { this.engage(); } } /** * animate():: same as run() * * @function * @memberof Animation **********/ animate() { if (this.__frametype == 'single') { return 0; } this.apply2DFrames(); //update once: this.update(); if (this.cix == 0) { this.engage(); } } /** * Engages, or updates the animation for a one full frame-cycle. * * @function * @param {number} duration the number of milliseconds the animation should take. * @memberof Animation **********/ engage(duration) { this.call_on_run(); duration = duration || this.duration || this.frames.length * 20; if (this.__frametype == 'single') { return 0; } let __inst = this; //we have a target this.tween = new TWEEN.Tween(this) .easing(__inst.curve || TWEEN.Easing.Linear.None) .to({cix: __inst.frames.length - 1}, duration) .onUpdate(function () { //console.log(objects[0].position.x,objects[0].position.y); // __inst.cix = Math.ceil(__inst.cix); __inst.update(); }) .onComplete(function () { //console.log(objects[0].position.x, objects[0].position.y); __inst.cix = 0; __inst.call_on_complete(); __inst.isComplete = true; }); if(this.cix == 0) this.tween.start(); if(this.cix &gt;= this.frames.length &amp;&amp; !this._hang) { this.cix = 0; } } } ; /** @memberof Gamestack */ Gamestack.Animation = Animation; Gamestack.Animation.continuous = Gamestack.Animation.run; //'continuous is an alternate reference to 'run'.' Gamestack.Animation.continue = Gamestack.Animation.run; //'continue is an alternate reference to 'run'.' Gamestack.Animation.animate = Gamestack.Animation.run; //'animate is an alternate reference to 'run'.' })(); ; class Construct3D{ constructor(name, value){ this.name = name; this.value = value; this.message= 'just-testing'; } } Gamestack.Construct3D = Construct3D; ;/** * Creates a new Sprite. * * &lt;info-bit&gt;Gamestack.Sprite is a container for 2D Animations. * -apply Sprite class to create a 2D game-object. * * Sprites hold reference to their-own Animations and Sounds.&lt;/info-bit&gt; * &lt;iframe style='width:400px; height:450px; overflow:hidden;' src='../client/examples/js-class/Sprite.html'&gt; &lt;/iframe&gt; * @param {string} src the srcPath for the image of the Sprite * @param {number} scale=1.0 the scale to be applied to size of each animation-frame * * @returns {Sprite} a Gamestack.Sprite object * * * */ class Sprite extends Scriptable { constructor(src = {}, scale = 1.0) { super(); this.Object(this); var args = typeof src == 'object' ? src : {}; if (args instanceof Gamestack.Animation) //instantiate from animation { console.dev('args was Gamestack.Animation', args); args = { selected_animation: args, image: args.image, size: new Gamestack.Vector(args.frameSize) }; } //apply image from string 'src' if (typeof src == 'string') { this.src = src; this.selected_animation = new Gamestack.Animation(src); this.image = this.selected_animation.image; this.SingleFrame(); } this.animations = []; //create size property this.size = new Gamestack.Vector(0, 0); if (typeof(scale) == 'number') //image plus 'scale' argument { this.scale = scale || 1.0; } this.active = true; //defaults to active or visible //apply remaining args this.apply_args(args); if (!this.selected_animation) this.SingleFrame(); } static_image_load(img) { this.size = new Gamestack.Vector(img.width * this.scale, img.height * this.scale).round(); } /** * runs a function for the onload event of this sprite's image * * @function * @param {Function} f the function to be called on load * @memberof Sprite **********/ onLoad(f) { var img = this.image.domElement, load = img.onload; f = f || function() {}; f.bind(this); this.load_call = f; var $sprite = this; img.onload = function() { $sprite.load_total += 1; load.bind($sprite).call($sprite); // $sprite.static_image_load(img); $sprite.load_call($sprite); }; img.onerror = function(err) { $sprite.load_call(false, $sprite); }; return this; } /********** * @ignore **********/ apply_args(args = {}) { this.FromData(args, true); //Using a FUNCTIONAL COPY --heavy to process if (args.image instanceof Gamestack.GameImage &amp;&amp; !this.image) { this.image = args.image; } this.name = args.name || \"__blankName\"; this.life = args.life || 999999999999; this.description = args.description || \"__spriteDesc\"; /** * @property {String} id the unique identifier of the Sprite --called automatically on constructor. * @memberof Sprite **********/ this.id = this.create_id(); /** * @property {Array} animations the array of animations attached to the Sprite * @memberof Sprite **********/ this.animations = Gamestack.getArg(args, 'animations', []); /** * @property {Array} scripts the array of scripts attached to the Sprite * @memberof Sprite **********/ this.scripts = Gamestack.getArg(args, 'scripts', []); this.motions = Gamestack.getArg(args, 'motions', []); this.particles = Gamestack.getArg(args, 'particles', []); this.shots = Gamestack.getArg(args, 'shots', []); this.sounds = Gamestack.getArg(args, 'sounds', []); this.init_ext = Gamestack.getArg(args, 'init_ext', []); this.group = Gamestack.getArg(args, 'group', 'one'); this.scrollFactor = args.scrollFactor || 1.0; this.noScroll = args.noScroll || false; if (this.noScroll) { this.scrollFactor = 0; } /** * @property {Vector} speed the speed of the Sprite * @memberof Sprite **********/ this.speed = new Gamestack.Vector(Gamestack.getArg(args, 'speed', new Gamestack.Vector(0, 0))); /** * @property {Vector} size the vector-size of the Sprite * @memberof Sprite **********/ this.size = new Gamestack.Vector(Gamestack.getArg(args, 'size', new Gamestack.Vector(0, 0))); /** * @property {Vector} position the position of the Sprite * @memberof Sprite **********/ this.position = new Gamestack.Vector(Gamestack.getArg(args, 'position', new Gamestack.Vector(0, 0, 0))); this.collision_bounds = Gamestack.getArg(args, 'collision_bounds', new Gamestack.VectorBounds(new Gamestack.Vector(0, 0, 0), new Gamestack.Vector(0, 0, 0))); /** * * * @property {Vector} rotation the rotation of the Sprite * @memberof Sprite **********/ this.rotation = new Gamestack.Vector(Gamestack.getArg(args, 'rotation', new Gamestack.Vector(0, 0, 0))); /** * @property {number} scale the scale of the Sprite, controls draw-size * @memberof Sprite **********/ this.scale = args.scale || 1.0; this.acceleration = Gamestack.getArg(args, 'acceleration', new Gamestack.Vector(0, 0, 0)); this.rot_speed = new Gamestack.Vector(Gamestack.getArg(args, 'rot_speed', new Gamestack.Vector(0, 0))); this.rot_accel = new Gamestack.Vector(Gamestack.getArg(args, 'rot_accel', new Gamestack.Vector(0, 0))); this.padding = Gamestack.getArg(args, 'padding', new Gamestack.Vector(0, 0, 0)); var __inst = this; //Apply / instantiate Sound(), Gamestack.Motion(), and Gamestack.Animation() args... Gamestack.each(this.shots, function(ix, item) { __inst.shots[ix] = new Gamestack.Shot(item); }); Gamestack.each(this.sounds, function(ix, item) { __inst.sounds[ix] = new Gamestack.Sound(item); }); Gamestack.each(this.motions, function(ix, item) { __inst.motions[ix] = new Gamestack.TweenMotion(item); }); Gamestack.each(this.animations, function(ix, item) { __inst.animations[ix] = new Gamestack.Animation(item); }); Gamestack.each(this.particles, function(ix, item) { __inst.particles[ix] = new Gamestack.GSProton(item); }); //Apply initializers: Gamestack.each(this.init_ext, function(ix, item) { __inst.addInitializer(item); }); if (!this.selected_animation &amp;&amp; args.selected_animation) { console.dev('applying animation:' + jstr(args.selected_animation)); this.selected_animation = new Gamestack.Animation(args.selected_animation); } } /** * Clones a sprite from existing data * * @function * @param {Object} object the data to be cloned * @memberof Sprite **********/ Clone(sprite){ console.log('using Clone() function'); var clone = new Gamestack.Sprite(sprite.src); clone.Anime(new Gamestack.Animation(sprite.anime)); clone.apply_args(sprite); return clone; } draw(ctx, camera) { var sprite = this; camera = camera || Gamestack.game_windows[0].camera || { position: new Gamestack.Vector(0, 0, 0) }; if (sprite.active &amp;&amp; (this.DRAWOFFSCREEN || sprite.onScreen(Gamestack.WIDTH, Gamestack.HEIGHT))) { this.draw_current_frame(ctx, camera); } } draw_current_frame(ctx, camera){ var sprite = this; var frame; if (sprite.active) { if (sprite.selected_animation instanceof Object &amp;&amp; sprite.selected_animation.hasOwnProperty('selected_frame')) { frame = sprite.selected_animation.selected_frame; } else { // console.error('Sprite is missing arguments'); //delay the draw return; } var p = sprite.position; var camera_pos = camera.position || { x: 0, y: 0, z: 0 }; if (!sprite.hasOwnProperty('scrollFactor')) { sprite.scrollFactor = 1.0; } var x = p.x, y = p.y, scrollFactor = sprite.scrollFactor &gt;= -1.0 &amp;&amp; sprite.scrollFactor &lt;= 1.0 ? sprite.scrollFactor : 1.0; if (sprite.noScroll) { scrollFactor = 0; } x -= camera_pos.x * scrollFactor || 0; y -= camera_pos.y * scrollFactor || 0; //optional animation : gameSize var targetSize = sprite.size || sprite.selected_animation.size; var realWidth = targetSize.x; var realHeight = targetSize.y; var origin = sprite.origin || new Gamestack.Vector(realWidth / 2, realHeight / 2); //optional animation : offset if (sprite.selected_animation &amp;&amp; sprite.selected_animation.hasOwnProperty('offset')) { x += sprite.selected_animation.offset.x; y += sprite.selected_animation.offset.y; } var rotation; if (typeof(sprite.rotation) == 'object') { rotation = sprite.rotation.x; } else { rotation = sprite.rotation; } var frame = sprite.selected_animation.selected_frame; sprite.realPosition = new Gamestack.Vector(x, y); if (frame &amp;&amp; frame.image &amp;&amp; frame.image.data) { ctx.putImageData(frame.image.data, x, y, 0, 0, sprite.size.x, sprite.size.y); } else { if (!sprite.selected_animation || !sprite.selected_animation.selected_frame.image.domElement) return; if (frame.image.domElement instanceof HTMLImageElement) { Gamestack.Canvas.draw_image_frame(frame.image.domElement, frame.framePos, frame.frameSize, new Gamestack.Vector2D(Math.round(x + (realWidth / 2)), Math.round(y + (realHeight / 2))), new Gamestack.Vector2D(realWidth, realHeight), rotation % 360, ctx, sprite.flipX, sprite.flipY, origin); } } } } /** * adds an animation to the sprites * * @function * @param {Object} object the animation to be added * @memberof Sprite **********/ Add(object) { if (object instanceof Gamestack.Animation) { this.animations.add(object); } return this; } get animation() { return this.selected_animation; } get anime() { return this.selected_animation; } Anime(anime) { if(anime) this.selected_animation = anime; return this; } Animation(anime) { if(anime) this.selected_animation = anime; return this; } FromData(data = {}, fxlCopy = false) { for (var x in data) { if (fxlCopy || typeof(data[x]) !== 'function') this[x] = data[x]; } return this; } /************************************************************** * scales the sprite.size property according to image-size. * @param {number} scaleFloat a 0-1+ value * * @function * @memberof Sprite **************************************************************/ Scale(scaleFloat) { this.scale = scaleFloat; this.size = new Gamestack.Vector(this.image.domElement.width * scaleFloat, this.image.domElement.height * scaleFloat); return this; } /************************************************************** * applies a float value arg to Sprite.scrollFactor * @param {number} s a 0-1+ value * * @function * @memberof Sprite **************************************************************/ ScrollFactor(s) { this.scrollFactor = s; return this; } engage(obj) //engages an object having an engage function { obj.parent = this; if (obj.engage) { obj.engage(); } } /** * pass argument v to the sprite.life property. * @function * @memberof Sprite * @param {number} v number of render-updates that this Sprite will last. --update occurs 60+ times per second, or less, depending on performance * @returns {Sprite} the sprite object --enables chainable function calls **********/ Life(v) { this.life = v; return this; } /** * initializes sprites. triggers all functions previously passed to the addInitializer function. * Use this function when a sprite, instantiated from json-data, carries initializers. * --This feature is built for the purpose of data-persistence. --sprites from json-file may carry behaviors onto the scene. * * @function * @memberof Sprite **********/ init() { } /** * extends the init function. * @function * @memberof Sprite * @param {function} fun the function to be passed into the init function of the sprite **********/ addInitializer(fun) { let boundFun = fun.bind(this) if (this.init_ext.indexOf(boundFun) &lt; 0) { this.init_ext.push(boundFun) }; } /***************************** * Getters ***************************/ /** * returns the 'id' property of the sprite * @function * @memberof Sprite * @returns {string} **********/ get_id() { return this.id; } /********** * @ignore **********/ to_map_object(size, framesize) { this.__mapSize = new Gamestack.Vector(size || this.size); this.frameSize = new Gamestack.Vector(framesize || this.size); return this; } /***************************** * Setters and Creators ***************************/ /** * creates a unique string id property for the sprite. * @function * @memberof Sprite * @returns {string} **********/ create_id() { return Gamestack.create_id(); } /** * returns a maximum scaled size, according to max dimensions of width and height * @param {number} mx the maximum size.x for the returned size * @param {number} my the maximum size.y for the returned size * @function * @memberof Sprite * @returns {Vector} a vector of x,y,z? values **********/ getSizeByMax(mx, my) { var size = new Gamestack.Vector(this.size); var wth = size.y / size.x; var htw = size.x / size.y; if (size.x &gt; mx) { size.x = mx; size.y = size.x * wth; } if (size.y &gt; my) { size.y = my; size.x = size.y * htw; } return size; } /***************************** * assert the existence of a speed{} property * sprite.speed (vector) is created if not existing in sprite * @memberof Sprite ***************************/ assertSpeed() { if (!this.speed) { this.speed = new Gamestack.Vector(0, 0, 0); } } /** * set the 'selected_animation' property to a single-frame-animation * @function * @memberof Sprite **********/ SingleFrame() { if (!this.image || !this.image.domElement) { return this; } var __inst = this, load = this.image.domElement.onload || function() {}; if (this.size &amp;&amp; this.size.x !== 0 &amp;&amp; this.size.y !== 0) return; var _obj = this; this.image.domElement.onload = function() { load(false, __inst); if (_obj.size &amp;&amp; _obj.size.x !== 0 &amp;&amp; _obj.size.y !== 0) { } else{ __inst.size = new Gamestack.Vector(__inst.image.domElement.width, __inst.image.domElement.height); __inst.selected_animation = new Gamestack.Animation(__inst.image).FrameSize(__inst.size); __inst.Scale(__inst.scale || 1.0); } }; Gamestack.log('set single-frame animation'); return this; } /** * set the 'life' property to a specified integer * @function * @memberof Sprite **********/ LifeSpan(value) { this.life = value; } /** * set the 'life' property to a specified integer * @function * @memberof Sprite **********/ Life(value) //same as LifeSpan { this.life = value; } /** * tells if sprite has been taken out of game * @function * @memberof Sprite **********/ isDead(gw) { gw = gw || Gamestack.game_windows[0]; return this.hasOwnProperty('life') &amp;&amp; this.life &lt;= 0; } /** * sets life to 0, then ending the sprite * @function * @memberof Sprite **********/ die(gw) { this.life = 0; return this; } /** * indicates if any portion of the sprite is within screen bounds --uses Gamestack.WIDTH, Gamestack.HEIGHT OR any w,h arguments passed to this method * @function * @memberof Sprite * @param {number} w optional screen-width argument, defaults to Gamestack.WIDTH * @param {number} h optional screen-height argument, defaults to Gamestack.HEIGHT * @returns {boolean} a true or false value to show if any part of the sprite is on-screen **********/ onScreen(w, h, gw) { w = w || Gamestack.WIDTH; h = h || Gamestack.HEIGHT; gw = gw || Gamestack.game_windows[0]; var camera = gw.camera || Gamestack.camera || { position: new Gamestack.Vector(0, 0, 0) }, scrollFactor = this.noScroll ? 0 : this.scrollFactor; var sprite = this, p = sprite.position, camera_pos = camera.position || { x: 0, y: 0, z: 0 }; if (!sprite.hasOwnProperty('scrollFactor')) { sprite.scrollFactor = 1.0; } var x = p.x, y = p.y, scrollFactor = sprite.scrollFactor &gt;= -1.0 &amp;&amp; sprite.scrollFactor &lt;= 1.0 ? sprite.scrollFactor : 1.0; if (sprite.noScroll) { scrollFactor = 0; } x -= camera_pos.x * scrollFactor || 0; y -= camera_pos.y * scrollFactor || 0; return x + sprite.size.x &gt; -1000 - w &amp;&amp; x &lt; w + 1000 &amp;&amp; y + sprite.size.y &gt; 0 - 1000 - h &amp;&amp; y &lt; h + 1000; } /***************************** * Updates ***************************/ /***************************** * update() * -starts empty:: is applied recursively by Gamestack.js as the main sprite-update ***************************/ /** * the main update for the sprite --applied recursively by GameWindow after gameWindow.start is called * @function * @memberof Sprite **********/ update(sprite) {} /***************************** * def_update() * -applies speed and other default factors of movement * -is used by Quick2d.js as the system def_update (default update) ***************************/ /** * Automatically updates various speed and rotational properties for the Sprite() * @function * @memberof Sprite * * @example * // applies a constant speed property --speed is Vector(x, y) * mySprite.rot_speed = new Gamestack.Vector(3); * //def_update() will run automatically with the gamestack update. The above sprite will rotate at a constant speed of 3. * @example * // how to reset to nothing:: if automatic speed updates are undesired, replace the def_update() function with a 'do nothing' function. * mySprite.def_update = function() * { * //do nothing * }; **********/ def_update(sprite) { if (this.hasOwnProperty('life') &amp;&amp; !isNaN(this.life)) { this.life -= 1; }; for (var x in this.speed) { if (this.speed[x] &gt; 0 || this.speed[x] &lt; 0) { this.position[x] += this.speed[x]; } } for (var x in this.acceleration) { if (this.acceleration[x] &gt; 0 || this.acceleration[x] &lt; 0) { this.speed[x] += this.acceleration[x]; } } for (var x in this.rot_speed) { if (this.rot_speed[x] &gt; 0 || this.rot_speed[x] &lt; 0) { this.rotation[x] += this.rot_speed[x]; } } for (var x in this.rot_accel) { if (this.rot_accel[x] &gt; 0 || this.rot_accel[x] &lt; 0) { this.rot_speed[x] += this.rot_accel[x]; } } } /** * extends an existing function, and is applied by Gamestack in addInitializer(); * @ignore * -REMOVED FROM DOCS : SYSTEM USE ONLY **********/ extendFunc(fun, extendedFunc) { console.log('extending func'); var ef = extendedFunc; var __inst = this; return function() { ef(__inst); //any new function comes after fun(__inst); }.bind(this); } /***************************** * onUpdate(fun) * -args: 1 function(sprite){ } //the self-instance/sprite is passed into the function() * -overrides and maintains existing code for update(){} function ***************************/ /** * extends the update of this sprite with a new function to be called during the update * --repeated calls will extend, (not replace) the update --Allows multiple extensions of the update * @function * @memberof Sprite * @param {function} fun the function to be appended to sprite.update * * * @example * // extend the behavior of your sprite * mySprite.onUpdate(function(spr) * * console.log('extended update'); //runs automatically whenever sprite.update runs * * }); * **********/ onUpdate(fun) { var id = this.create_id(); fun = fun.bind(this); let update = this.update.bind(this); let __inst = this; this.update = function(__inst) { update(__inst); fun(__inst); }; } /***************************** * travelLineTwoWay() * -sprite travels line: any Line() or object with property of line ***************************/ /******************************************************************************** * sprite travels on a line in a back-and-forth motion --to the end of the line, and back. * #Dev-todo:MORE ON THIS * @function * @memberof Sprite *********************************************************************************/ travelLineTwoWay(lineObject, speed, curveKey, offset) { speed = speed || 1; var motionCurveOptions = [\"linear\", \"quadratic\", \"cubic\"]; curveKey = curveKey || \"linear\"; var line = lineObject; if (lineObject.line) { line = lineObject.line; } this.__crtLineIx = this.__crtLineIx || 0; var __inst = this, pctFloat = __inst.__crtLineIx % ((line.points.length - 1) / 2) / ((line.points.length - 1) / 2); if (__inst.__crtLineIx &gt;= ((line.points.length - 1) / 2)) { pctFloat = 1.0 - pctFloat; } var ixChange = Gamestack.Curves.InOut[curveKey](pctFloat) * speed * 0.5; if (curveKey == 'linear') { ixChange = speed; } ixChange = Math.ceil(ixChange); if (ixChange &lt; 1) { ixChange = 1; } __inst.position = new Gamestack.Vector(line.points[__inst.__crtLineIx]); //console.log(ixChange); __inst.__crtLineIx += ixChange; if (__inst.__crtLineIx &gt;= line.points.length) { line.points = line.points.reverse(); __inst.__crtLineIx = 0; } if (offset instanceof Gamestack.Vector) { this.position = this.position.add(offset); } } /***************************** * travelLineOnLoop() * -sprite travels line: any Line() or object with property of line ***************************/ /** * the sprite travels one line in a looping motion --useful for traveling Square, Circle, or other enclosed Lines. * #Dev-todo:MORE ON THIS * @function * @memberof Sprite **********/ travelLineOnLoop(lineObject, speed, curveKey, offset) { speed = speed || 1; var motionCurveOptions = [\"linear\", \"quadratic\", \"cubic\"]; curveKey = curveKey || \"linear\"; var line = lineObject; if (lineObject.line) { line = lineObject.line; } this.__crtLineIx = this.__crtLineIx || 0; var __inst = this, pctFloat = __inst.__crtLineIx % ((line.points.length - 1) / 2) / ((line.points.length - 1) / 2); if (__inst.__crtLineIx &gt;= ((line.points.length - 1) / 2)) { pctFloat = 1.0 - pctFloat; } var ixChange = Gamestack.Curves.InOut[curveKey](pctFloat) * speed * 0.5; if (curveKey == 'linear') { ixChange = speed; } ixChange = Math.ceil(ixChange); if (ixChange &lt; 1) { ixChange = 1; } __inst.position = new Gamestack.Vector(line.points[__inst.__crtLineIx]); // console.log(ixChange); __inst.__crtLineIx += ixChange; if (__inst.__crtLineIx &gt;= line.points.length) { __inst.__crtLineIx = 0; } if (offset instanceof Gamestack.Vector) { this.position = this.position.add(offset); } } /** * returns a true || false value for immediate color-collision --non-transparent-pixels --between colored-pixels of this sprite and the sprite argument * @function * @memberof Sprite * @param {Sprite} spr the sprite object to be collided * @returns {boolean} a true or false value to show if collision is happening **********/ hasPixelCollision(sprite) { if (!Larva.truthyPropsPerArray([this, sprite], 'selected_animation')) return; if (!Larva.truthyPropsPerArray([this.selected_animation, sprite.selected_animation], 'getCurrentPixelMap')) return; let anime = this.selected_animation, alt_anime = sprite.selected_animation; var grid1 = anime.selectedFramePixelMap = this.selected_animation.getCurrentPixelMap(), grid2 = alt_anime.selectedFramePixelMap = alt_anime.getCurrentPixelMap(); for (var x in grid1) { for (var y in grid2) { if (Gamestack.Collision.boxesCollide(grid1[x].position, grid1[x].size, grid2[y].position, grid2[y].size)) { return true; } } } return false; } init_pixelCollision() { let anime = this.selected_animation; this.selectedFramePixelMap = anime.getCurrentPixelMap(anime.scaleOf(this.size)); this.colliderHighlights = this.colliderHighlights || []; } init_colliderHighlights(unitMarker) { while (this.colliderHighlights.length &lt; 100) { var sprite = new Gamestack.Sprite(unitMarker); this.colliderHighlights.push(sprite); Gamestack.game_windows[0].add(sprite); } } pixelGridOff() { } set_colliderHighlights(hSprite, on) { this.collider_highlightsOn = on || false; this.init_pixelCollision(); this.init_colliderHighlights(hSprite); let anime = this.selected_animation; for (var x in this.colliderHighlights) { this.colliderHighlights[x].active = false; } if (hSprite &amp;&amp; this.collider_highlightsOn) for (var x in this.selectedFramePixelMap) { if (!this.colliderHighlights[x]) { continue; } let gridPiece = this.selectedFramePixelMap[x]; let anime_scale = anime.scaleOf(this.size), real_gridPiece_pos = gridPiece.position.mult(anime_scale), real_gridPiece_size = gridPiece.size.mult(anime_scale); this.colliderHighlights[x].Pos(this.position.add(new Gamestack.Vector(real_gridPiece_pos.x, real_gridPiece_pos.y).sub(anime.selected_frame.framePos.mult(anime_scale)))); this.colliderHighlights[x].Size(real_gridPiece_size); this.colliderHighlights[x].active = true; }; } onPixelCollision(sprite, callback, highlightSprite) { let anime = this.selected_animation; this.onUpdate(function() { var anime = this.selected_animation; if (this.hasPixelCollision(sprite)) { if (!this.colliderHighlights) { } else for (var x in colliderHighlights) { gameWindow.remove(colliderHighlights[x]); }; callback(this, sprite); }; }); } /** * returns a true || false value for immediate box-collision --between this sprite and the sprite argument * @function * @memberof Sprite * @param {Sprite} sprite the alternate Sprite for collision detection * @returns {boolean} a true or false value to show if collision is happening **********/ hasBoxCollision(sprite) { return Gamestack.Collision.spriteBoxesCollide(this, sprite); } onBoxCollision(sprite, callback) { this.onUpdate(function() { if (this.hasBoxCollision(sprite, this.boxCollisionSettings.padding)) { callback(this, sprite); }; }); } /***************************** * shoot(sprite) * -fire a shot from the sprite:: as in a firing gun or spaceship * -takes options{} for number of shots anglePerShot etc... * -TODO: complete and test this code ***************************/ /** * fire a Shot, or bullet-Sprite from the Sprite * @function * @memberof Sprite * @param {Object} options an object of arguments * @param {Gamestack.Animation} animation the animation to fire from the Sprite * @param {number} speed the speed of the shot that is projected * @param {Gamestack.Vector} position the initial position of the shot: defaults to current Sprite position * @param {Gamestack.Vector} size the Vector size of the shot * @param {Gamestack.Vector} rot_offset the rotational offset to apply: controls direction of the shot **********/ shoot(options, gw) { //character shoots an animation gw = gw || Gamestack.game_windows[0]; this.prep_key = 'shoot'; let animation = options.bullet || options.animation || options.anime || new Gamestack.Animation(); let speed = options.speed || options.velocity || 1; let size = options.size || new Gamestack.Vector(10, 10, 0); let position = new Gamestack.Vector(options.position) || new Gamestack.Vector(this.position); let rot_offset = options.rot_offset || options.rotation || 0; let total = options.total || 1; let rot_disp = options.rot_disp || 0; //the full rotational-dispersion of the bullets let life = options.life || 900; var shots = []; for (var x = 0; x &lt; total; x++) { var __playerInst = this; if (Gamestack.isAtPlay) { var bx = position.x, by = position.y, bw = size.x, bh = size.y; var shot = new Gamestack.Sprite().FromData({ active: true, position: new Gamestack.Vector(position), size: new Gamestack.Vector(size), speed: speed, image: animation.image, rotation: new Gamestack.Vector(0, 0, 0), flipX: false, life: options.life, noScroll:true }); shot.Animation(animation); rot_offset = new Gamestack.Vector(rot_offset, 0, 0); shot.position.x = bx, shot.position.y = by; //Danger On this line: annoying math --dispersing rotation of bullets by rot_disp var div = rot_disp / total; var rotPlus = div * x + div / 2 - rot_disp / 2; shot.rotation.x = rot_offset.x + rotPlus; // shot.origin = new Gamestack.Vector(position); shot.speed = new Gamestack.Vector(Math.cos((shot.rotation.x) * 3.14 / 180) * speed, Math.sin((shot.rotation.x) * 3.14 / 180) * speed); shots.push(shot); shot.onUpdate(function(spr) { // console.log('update:rotation:' + shot.rotation.x); }); gw.add(shot); } } return shots; } /** * create a sub-sprite belonging to the current sprite * @function * @memberof Sprite * @param {Object} options an object of arguments * @param {Animation} animation the animation to fire from the Sprite * @param {number} speed the speed of the shot that is projected * @param {Vector} position the initial position of the shot: defaults to current Sprite position * @param {Vector} size the Vector size of the shot * @param {Vector} offset the positional offset to apply * @returns {Sprite} a Gamestack.Sprite object **********/ subsprite(options, gw) { gw = gw || Gamestack.game_windows[0]; let animation = options.animation || new Gamestack.Animation(); let position = options.position || new Gamestack.Vector(this.position); let offset = options.offset || new Gamestack.Vector(0, 0, 0); let size = new Gamestack.Vector(options.size || this.size); if (Gamestack.isAtPlay) { var subsprite = gw.add(new Gamestack.Sprite().FromData({ active: true, position: position, size: size, offset: offset, image: animation.image, rotation: new Gamestack.Vector(0, 0, 0), flipX: false, scrollFactor: this.scrollFactor, noScroll: this.noScroll })); subsprite.Animation(animation); return subsprite; } else { alert('No subsprite when not at play'); } } /** * switch to the next frame on sprite.selected_animation * @function * @memberof Sprite * @param {Animation} animation the optional animation to switch to before animate is called, defaults to the existing sprite.selected_animation **********/ animate(animation) { if (Gamestack.isAtPlay) { if (animation) { this.Animation(animation) } this.selected_animation.run(); } } /** * run a function when the sprite.selected_animation is complete * * @function * @memberof Sprite * @param {Function} fun the function to call when the animation is complete * **********/ onAnimationComplete(fun) { this.selected_animation.onComplete(fun); } /***************************** * accelY * -accelerate on Y-Axis with 'accel' and 'max' (speed) arguments * -example-use: gravitation of sprite || up / down movement ***************************/ /** * accelerate speed on the y-axis * * @function * @memberof Sprite * @param {number} accel the increment of acceleration * @param {number} max the maximum for speed * **********/ accelY(accel, max) { accel = Math.abs(accel); if (typeof(max) == 'number') { max = { y: max }; } this.assertSpeed(); let diff = max.y - this.speed.y; if (diff &gt; 0) { this.speed.y += Math.abs(diff) &gt;= accel ? accel : diff; }; if (diff &lt; 0) { this.speed.y -= Math.abs(diff) &gt;= accel ? accel : diff; }; } /***************************** * accelX * -accelerate on x-Axis * -example-use: running of sprite || left / right movement ***************************/ /** * accelerate speed on the x-Axis * * @function * @memberof Sprite * @param {number} accel the increment of acceleration * @param {number} max the maximum for speed * **********/ accelX(accel, max) { accel = Math.abs(accel); if (typeof(max) == 'number') { max = { x: max }; } this.assertSpeed(); let diff = max.x - this.speed.x; if (diff &gt; 0) { this.speed.x += Math.abs(diff) &gt;= accel ? accel : diff; }; if (diff &lt; 0) { this.speed.x -= Math.abs(diff) &gt;= accel ? accel : diff; }; } /***************************** * accel * -accelerate any acceleration -key ***************************/ /** * decelerate speed on the x-Axis, toward zero * @function * @memberof Sprite * @param {number} amt the increment of deceleration, negatives ignored * **********/ decelY(amt) { amt = Math.abs(amt); if (Math.abs(this.speed.y) &lt;= amt) { this.speed.y = 0; } else if (this.speed.y &gt; amt) { this.speed.y -= amt; } else if (this.speed.y &lt; amt * -1) { this.speed.y += amt; } } /***************************** * decelX * -decelerate on the X axis * -args: 1 float:amt ***************************/ /** * decelerate speed on the x-Axis, toward zero * @function * @memberof Sprite * @param {number} amt the increment of deceleration, negatives ignored * **********/ decelX(amt) { amt = Math.abs(amt); if (this.speed.x &gt; amt) { this.speed.x -= amt; } else if (this.speed.x &lt; amt * -1) { this.speed.x += amt; } if (Math.abs(this.speed.x) &lt;= amt) { this.speed.x = 0; } } /** * accelerate toward a max value on any object-property * @function * @memberof Sprite * @param {Object} prop The object to control * @param {string} key the target property-key for object argument * @param {number} accel the additive increase to the property on each call * @param {number} max the max value to accelerate towards **********/ accel(object, key, accel, max) { var prop = object; accel = Math.abs(accel); if (typeof(max) == 'number') { max = { x: max }; } let speed = prop[key]; // this.assertSpeed(); let diff = max.x - prop[key]; if (diff &gt; 0) { prop[key] += Math.abs(diff) &gt;= accel ? accel : diff; }; if (diff &lt; 0) { prop[key] -= Math.abs(diff) &gt;= accel ? accel : diff; }; } /***************************** * decel * -deceleration -key ***************************/ /** * decelerate toward a max value on any object-property * @function * @memberof Sprite * @param {Object} prop the object to control * @param {string} key the property-key for targeted property of prop argument * * @param {number} decel the increment of deceleration * * @param {number} max the max value to decelerate towards * * **********/ decel(prop, key, rate) { if (typeof(rate) == 'object') { rate = rate.rate; } rate = Math.abs(rate); if (Math.abs(prop[key]) &lt;= rate) { prop[key] = 0; } else if (prop[key] &gt; 0) { prop[key] -= rate; } else if (prop[key] &lt; 0) { prop[key] += rate; } else { prop[key] = 0; } } seekPosition(target_Position, differential_SpeedMultiple) { var target = {}; //always positive: differential_SpeedMultiple = Math.abs(differential_SpeedMultiple); if (target_Position.hasOwnProperty('position')) { console.log('1st argument had its own position property. Using this property now:'); target = target_Position.position; } else { target = target_Position; } let diff = this.position.sub(target).mult(-1); this.speed = diff.mult(differential_SpeedMultiple); } /***************************** * decelY * -decelerate on the Y axis * -args: 1 float:amt ***************************/ /** * A generic 'smooth motion', adds to position.x and position.y with smooth acceleration and deceleration * --uses quadratic-easing of the TWEEN.js library * @function * @memberof Sprite * @param {number} x The x to be added to Sprite().positon.x over the course of the SmoothMotion --use negative for subtractive motion * @param {number} y The y to be added to Sprite().positon.y over the course of the SmoothMotion- -use negative for subtractive motion * @param {number} duration the amount of time taken to complete this motion * **********/ SmoothMotion(x, y, duration) { if (typeof(x) == 'object') //argument coercion: x is a vector, y is duration { duration = y; y = x.y; x = x.x; } x = x + this.position.x; y = y + this.position.y; if (!TWEEN instanceof Object) { return console.error('TWEEN.js required for SmoothMotion();'); } var t = new TWEEN.Tween(this.position) .easing(TWEEN.Easing.Quadratic.InOut) .to(new Gamestack.Vector(x, y), duration) .onUpdate(function() { //console.log(objects[0].position.x,objects[0].position.y); }) .onComplete(function() { //console.log(objects[0].position.x, objects[0].position.y); }); t.start(); } /** * A generic 'smooth rotate', adds to rotation.x with smooth acceleration and deceleration * --uses quadratic-easing of the TWEEN.js library * @function * @memberof Sprite * @param {number} r The numeric value to be added to Sprite().rotation.x over the course of the SmoothRotate --use negative for subtractive rotation * @param {number} duration the amount of time taken to complete this rotation **********/ SmoothRotate(r, duration) { if (!TWEEN instanceof Object) { return console.error('TWEEN.js required for SmoothRotate();'); } r = r + this.rotation.x; var t = new TWEEN.Tween(this.rotation) .easing(TWEEN.Easing.Quadratic.InOut) .to(new Gamestack.Vector(r), duration) .onUpdate(function() { //console.log(objects[0].position.x,objects[0].position.y); }) .onComplete(function() { //console.log(objects[0].position.x, objects[0].position.y); }); t.start(); } /** * get the vector-position at the center of the sprite, based on its current position and size * @function * @memberof Sprite * * @returns (Vector) a vector-position pinpointing the current-center of the sprite * **********/ center() { return new Gamestack.Vector(this.position.x + this.size.x / 2, this.position.y + this.size.y / 2, 0); } /***************************** * System Use / Collision ***************************/ /***************************** * @ignore ***************************/ shortest_stop(item, callback) { var diff_min_y = item.min ? item.min.y : Math.abs(item.position.y - this.position.y + this.size.y); var diff_min_x = item.min ? item.min.x : Math.abs(item.position.x - this.position.x + this.size.x); var diff_max_y = item.max ? item.max.y : Math.abs(item.position.y + item.size.y - this.position.y); var diff_max_x = item.max ? item.max.x : Math.abs(item.position.x + item.size.x - this.position.y); var dimens = { top: diff_min_y, left: diff_min_x, bottom: diff_max_y, right: diff_max_x }; var minkey = \"\", min = 10000000; for (var x in dimens) { if (dimens[x] &lt; min) { min = dimens[x]; minkey = x; // a key of top left bottom or right } } callback(minkey); } /************* * #BE CAREFUL * -with this function :: change sensitive / tricky / 4 way collision * *************/ /** * determine if sprite overlaps on x-axis with another sprite * * @function * @memberof Sprite * @param {Sprite} item the Sprite to compare with * @param {number} padding the 0-1.0 float value of padding to use on self when testing overlap * @returns {boolean} a true || false var showing if overlap has occured * **********/ overlap_x(item, padding) { if (!padding) { padding = 0; } var paddingX = Math.round(padding * this.size.x), paddingY = Math.round(padding * this.size.y), left = this.position.x + paddingX, right = this.position.x + this.size.x - paddingX, top = this.position.y + paddingY, bottom = this.position.y + this.size.y - paddingY; return right &gt; item.position.x &amp;&amp; left &lt; item.position.x + item.size.x; } /************* * #BE CAREFUL * -with this function :: change sensitive / tricky / 4 way collision * *************/ /** * determine if sprite overlaps on y-axis with another sprite * @function * @memberof Sprite * @param {Sprite} item the Sprite to compare with * @param {number} padding the 0-1.0 float value of padding to use on self when testing overlap * @returns {boolean} a true || false var showing if overlap has occured * **********/ overlap_y(item, padding) { if (!padding) { padding = 0; } var paddingX = Math.round(padding * this.size.x), paddingY = Math.round(padding * this.size.y), left = this.position.x + paddingX, right = this.position.x + this.size.x - paddingX, top = this.position.y + paddingY, bottom = this.position.y + this.size.y - paddingY; return bottom &gt; item.position.y &amp;&amp; top &lt; item.position.y + item.size.y; } /************* * #BE CAREFUL * -with this function :: change sensitive / tricky / 4 way collision * *************/ /** * stop collision on x-axis with another sprite * @function * @memberof Sprite * @param {Sprite} item the Sprite with which to collide-stop on the x-axis **********/ collide_stop_x(item) { var apart = false; var ct = 10000; while (!apart &amp;&amp; ct &gt; 0) { ct--; var diffX = this.center().sub(item.center()).x; var distX = Math.abs(this.size.x / 2 + item.size.x / 2 - Math.round(this.size.x * this.padding.x)); if (Math.abs(diffX) &lt; distX) { this.position.x -= diffX &gt; 0 ? -1 : 1; } else { this.speed.x = 0; apart = true; } } } /************* * #BE CAREFUL * -with this function :: change sensitive / tricky / 4 way collision * *************/ /** * Trigger a fourway collision-stop between this and another Sprite :: * objects will behave clastically and resist passing through one-another * * @function * @memberof Sprite * @param {Sprite} item the Sprite to collide with * **********/ collide_stop(item) { if (this.id == item.id) { return false; } this.speed = this.speed || new Gamestack.Vector(0, 0, 0); this.padding = this.padding || new Gamestack.Vector(0, 0, 0); // this.position = this.position.sub(this.speed); if (this.hasBoxCollision(item)) { var diff = this.center().sub(item.center()); if (this.overlap_x(item, this.padding.x + 0.1) &amp;&amp; Math.abs(diff.x) &lt; Math.abs(diff.y)) { var apart = false; var ct = 10000; while (!apart &amp;&amp; ct &gt; 0) { ct--; var diffY = this.center().sub(item.center()).y; var distY = Math.abs(this.size.y / 2 + item.size.y / 2 - Math.round(this.size.y * this.padding.y)); if (Math.abs(diffY) &lt; distY) { this.position.y -= diffY &gt; 0 ? -1 : diffY &lt; 0 ? 1 : 0; this.position.y = Math.round(this.position.y); } else { if (diffY &lt;= 0) { this.__inAir = false; }; this.speed.y = 0; return apart = true; } } } if (this.overlap_y(item, this.padding.y) &amp;&amp; Math.abs(diff.y) &lt; Math.abs(diff.x)) { this.collide_stop_x(item); } } } /** * collide-stop only from the top (of the sprite passed as argument) :: * * @function * @memberof Sprite * @param {Sprite} item the Sprite to collide with * **********/ collide_stop_top(item, callback) { if (this.id == item.id) { return false; } if (this.overlap_x(item, this.padding.x + 0.1)) { console.log('OVERLAP_X'); var paddingY = this.padding.y * this.size.y; if (this.position.y + this.size.y - paddingY &lt;= item.position.y) { this.groundMaxY = item.position.y - this.size.y + paddingY; } } } /** * restore a sprite from existing json-data --applies to data-persistence * * @function * @memberof Sprite * * @returns (Sprite) **********/ restoreFrom(data) { data.image = new GameImage(data.src || data.image.src); return new Gamestack.Sprite(data); } /***************************** * @ignore * #IN-TESTING * fromFile(file_path) * -TODO : complete this function based on code to load Sprite() from file, located in the spritemaker.html file * -TODO: test this function ***************************/ fromFile(file_path) { if (typeof file_path == 'string') { var __inst = this; $.getJSON(file_path, function(data) { __inst = new Gamestack.Sprite(data); }); } } /***************************** * return a decycled json-string for the sprite --without circular references * @returns {string} a json string ***************************/ toJSONString() { return jstr(JSON.decycle(this)); } }; Gamestack.Sprite = Sprite; ; class Text { constructor(value){ this.Text(value); this.FontSize(15); this.FontFamily('Arial'); this.color = 'white'; this.position = new Gamestack.Vector(0, 0); } Font(fsize, ffamily){ this.FontSize(fsize); this.FontFamily(ffamily) return this; } FontSize(value){ if(typeof value !== 'string') value = value + ''; value = value.replace('px', '') + 'px'; this.fontSize = value; return this; } FontFamily(value) { this.fontFamily = value; return this; } getOffsetPos(pos){ var offset = this.window_offset || new Gamestack.Vector(0, 0); return pos.add(offset); } draw(ctx, camera){ var x = this.position.x + camera.position.x, y = this.position.y + camera.position.y; if(ctx.save) { ctx.save(); } ctx.fillStyle = this.color; ctx.font = this.fontSize + ' ' + this.fontFamily; var pos = new Gamestack.Vector(x, y), realPos = this.getOffsetPos(pos); ctx.fillText(this.text, realPos.x, realPos.y); ctx.restore(); } } Gamestack.Text = Text; ;/**************************** * Robotix ***************************/ //Appendage:: one stack of objects which behave as single appendage: //--a chain of links or an arm or leg made of separate parts class Appendage { constructor() { } } //Single part which exists along with its parent object class Attachment { constructor(){ } } ;/** * Creates a GravityForce instance. * *@param {Object} args the object of arguments * @param {string} args.name optional * @param {string} args.description optional * @param {Array} args.subjects the subjects to be pulled by the GravityForce * @param {Array} args.clasticObjects any clastic object or array-of-objects that should have collision-stop behavior with subjects * @param {Vector} args.max the max speed of the gravity-force, similar to concept of 'terminal velocity' * @param {number} args.accel the increment of acceleration for each update called, while subjects are falling * * @returns {GravityForce} a GravityForce object */ (function () { console.log('Force class... creating'); class GravityForce { constructor(args = {}) { this.name = args.name || \"\"; this.description = args.description || \"\"; this.subjects = args.subjects || []; this.clasticObjects = args.clasticObjects || []; this.topClastics = args.topClastics || []; this.max = args.max || new Vector3(3, 3, 3); this.accel = args.accel || new Vector3(1.3, 1.3, 1.3); for (var x in this.clasticObjects) { if (!this.clasticObjects[x] instanceof Gamestack.Sprite) { this.clasticObjects[x] = Gamestack.getById(this.clasticObjects[x].id); } } for (var x in this.topClastics) { if (!this.topClastics[x] instanceof Gamestack.Sprite) { this.topClastics[x] = Gamestack.getById(this.topClastics[x].id); } } for (var x in this.subjects) { if (!this.subjects[x] instanceof Gamestack.Sprite) { this.subjects[x] = Gamestack.getById(this.subjects[x].id); } } } getArg(args, key, fallback) { if (args.hasOwnProperty(key)) { return args[key]; } else { return fallback; } } /** * Updates position for all objects effected by this instance. * @memberof GravityForce */ update() { var subjects = this.subjects; var clasticObjects = this.clasticObjects; var topClastics = this.topClastics; var accel = this.accel || {}; var max = this.max || {}; Gamestack.each(subjects, function (ix, itemx) { if(!itemx.jumping &amp;&amp; !itemx.flying) itemx.accelY(accel, max); itemx.__inAir = true; if (itemx.position.y &gt;= itemx.groundMaxY) { itemx.position.y = itemx.groundMaxY; } itemx.groundMaxY = 3000000; //some crazy number you'll never reach in-game Gamestack.each(topClastics, function (iy, itemy) { // itemx.collide_stop_top(itemy); }); }); } }; let Force = GravityForce; Gamestack.Force = Force; Gamestack.GForce = Force; Gamestack.GravityForce = GravityForce; })(); ;;;;;class Player extends Sprite { constructor() { super(...arguments); } OnInput(inputDevice, arg1, arg2, callback) { console.info('Player.OnInput: Feature not implemented'); } } Gamestack.Player = Player; ; /** * Creates an instance of Shot. * &lt;info-bit&gt;Shot object fires a moving-animation from a sprite &lt;/info-bit&gt; * * @param {string} name the name of this Shot * @param {GameImage | Animation} imageOrAnimation the GameImage or Animation to apply for this Shot * @returns {Shot} a Gamestack.Shot object */ class Shot { constructor(name, imageOrAnimation) { this.name = name || 'No-Name'; if(imageOrAnimation instanceof Gamestack.GameImage) { this.anime = new Animation(imageOrAnimation); } else if(imageOrAnimation instanceof Gamestack.Animation) { this.anime = imageOrAnimation; } this.rotation = 0; this.rot_disp = 0; var args = name instanceof Object ? name : {}; //is name / first arg an entire instance of shot? this.init(args); } init(args) { if(args instanceof Object) { for (var x in args) { this[x] = args[x]; if(args[x] instanceof Object &amp;&amp; args[x].hasOwnProperty('x'))//process as Vector { this[x] = new Vector(args[x]); } } } } Image(image) { this.anime = new Animation(image); } Animation(anime) { this.anime = anime; return this; } Total(total, rot_disp_per_unit) { this.total =total; this.rot_disp = rot_disp_per_unit; return this; } WaveGrowth(growth) { if(growth &gt; 0) this.curve_growth = growth; } CurveMode(key, size, growth) { this.curve = Gamestack.Curves.InOut[key.toLowerCase()]; this.curve_key = key.toLowerCase(); this.curve_size = size; if(growth &gt; 0) this.curve_growth = growth; if(typeof(this.curve_size)=='number') this.curve_size = new Gamestack.Vector(this.curve_size, this.curve_size); return this; } RotDisp( rot_disp) { this.rot_disp = rot_disp; return this; } Velocity(v) { this.velocity = v; return this; } onCollide(collideables, callback) { } } Gamestack.Shot = Shot; ;class Background extends Gamestack.Sprite { constructor(arg1={}, arg2={}) { super(arg1, arg2); let args = typeof(arg1) == 'object' ? arg1 : {}; this.type = args.type || \"parallax\" || \"basic\" || false; this.source_objects = args.objects || args.source_objects || []; this.members = []; this.rows = args.rows || 1;//The Y number of repititions this.cols = args.cols || 1; //The X number of repetitions of the images this.flip = args.flip || false; this.fill = args.fill || false; this.flip = args.flip || false; } Flip(value) { if(value == undefined) { this.flip = true; } else if (value == true || value == false) { this.flip = value; } return this; } Rows(r) { this.rows = r; return this; } Cols(c) { this.cols = c; return this; } Fill(approxRows, approxCols, gw) { approxRows = approxRows || this.rows || 1; approxCols = approxCols || this.cols || 1; this.members.push(new Background(this)); //\"This\" or base image is always applied for(var x = 0; x &lt; this.source_objects.length; x++) { this.members.push(new Background(this.source_objects[x]));//src strings OR Sprites() } gw = gw || Gamestack.game_windows[0]; var w= gw.canvas.width, h = gw.canvas.height, xBacksTotal = Math.floor(approxRows / 2), yBacksTotal = Math.floor(approxCols / 2); var __inst = this; //create first row: for(var y = -yBacksTotal; y &lt;= yBacksTotal + 1; y++) { console.log('adding background:' + y); for(var x = -xBacksTotal; x &lt;= xBacksTotal + 1; x++) { this.members.push(new Background(this)); var b = this.members[this.members.length - 1]; b.setSize(this.size); var __inst = this; b.position.x = x * this.size.x; b.position.y = y * this.size.y; b.minX = -xBacksTotal * b.size.x + b.size.x; b.maxX = (xBacksTotal + 1) * b.size.x ; b.minY = -yBacksTotal * b.size.y + b.size.y; b.maxY = yBacksTotal * b.size.y ; if(x % 2 == 0) { b.flipX = true; } if(y % 2 == 0) { b.flipY = true; } b.onUpdate(function(spr){ spr.campos = gw.camera.position; var cx = spr.campos.x - (spr.campos.x % spr.size.x), cy = spr.campos.y - ( spr.campos.y % spr.size.y ); if(spr.position.x - cx &lt; spr.minX) { spr.position.x = spr.maxX + cx; } if(spr.position.x - cx &gt; spr.maxX) { spr.position.x = spr.minX + cx; } if(spr.position.y - cy &lt; spr.minY) { spr.position.y = spr.maxY + cy; } if(spr.position.y - cy &gt; spr.maxY) { spr.position.y = spr.minY + cy; } }); gw.add(b); //add to window } } return this; } add(object) { var cleanCheck = object instanceof Gamestack.Sprite || object instanceof Array &amp;&amp; object[0] instanceof Gamestack.Sprite; //is Sprite if(!cleanCheck) { return console.error('Must have: valid contents (Gamestack.Sprite OR [] of Gamestack.Sprite())'); } if(object instanceof Array) { this.source_objects.cancat(object) } else { this.source_objects.push(object); } return this; } } Gamestack.Background = Background;; //Author: Jordan E. Blake class Effect { constructor() { } isAnimation() { } isParticleEffect() { } isSoundEffect() { } commit() { } } class SpriteMove { constructor(args = {}) { this.line = 100; this.timeLimit = 350; this.degreesRotated = 90; } setAnimation() { } setAnimationForward() //set the basic animation OR 'forward anime' { } setAnimationBackard() //set the backward animation OR 'backward-anime' { } setLineBack() //set the 'backward movement', should the Sprite need to return from the move { } setLine() //set the basic line OR 'forward movement' { } setLineForward() //set the basic line OR 'forward movement' { } setLineBack() //set the 'backward movement', should the Sprite need to return from the move { } setImmediateEffects() //Effects triggered when the SpriteMove starts { } setAfterEffects() //Effects triggered when the SpriteMove completes { } commit() { } then() { } } class Jump { constructor(spriteMove) { } setAnimation() { } setTimeLimit() { } setUpward(distance, duration) { } setDownward(distance, duration) { } commit() { } } class Vault { constructor(forward, back, afterEffects) { } commit() { } setForwardMove(line, curve, duration) { } setBackwardMove(line, curve, duration) { } onForwardDone(psuedoEffect) { } onBackwardDone(psuedoEffect) { } } class Attack { constructor(spriteMove, rpsLevel, powerLevel, afterEffects) { } commit() { } setAfterEffects(afterEffects) { } setRpsLevel(rpsLevel) { } setPowerLevel(pLevel) { } } ;/** * Takes an object of arguments and returns Projectile() object. Projectile fires a shot from the parent sprite, with specified offset, rotation, motion_curve, line_curve * @param {Object} args object of arguments * @param {string} args.name optional * @param {string} args.description optional * @param {string} args.distance the distance before dissappearance * @param {TWEEN.Easing.'objectGroup'.'objectMember'} args.motion_curve the TWEEN.Easing function to be applied for motion/speed (Example: TWEEN.Easing.Quadratic.InOut) * * * @param {TWEEN.Easing.'objectGroup'.'objectMember'} args.line_curve the TWEEN.Easing function to be applied for line (Example: TWEEN.Easing.Quadratic.InOut) * * @returns {Projectile} a Projectile object */ class Projectile { constructor(args = {}) { this.getArg = $Q.getArg; for (var x in args) { this[x] = args[x]; } this.name = args.name || \"__\"; this.description = args.description || \"__\"; this.animation = Gamestack.getArg(args, 'animation', new Animation()); this.parent_id = args.parent_id || args.object_id || \"__blank\"; //The parent object this.name = Gamestack.getArg(args, 'name', \"__\"); this.size = false; if(args.size) { this.size = new Vector(args.size); } else if(this.animation &amp;&amp; this.animation.frameSize) { this.size = new Vector(this.animation.frameSize); } else { console.info('Projectile():using default size.'); this.size = new Vector(20, 20, 20); } this.origin = args.origin || new Vector(0, 0, 0); this.rotation = args.rotation || 0; this.line.Rotation(this.rotation); this.description = Gamestack.getArg(args, 'description', false); this.duration = Gamestack.getArg(args, 'duration', 500); this.delay = Gamestack.getArg(args, 'delay', 0); this.position = Gamestack.getArg(args, 'position', new Vector(0, 0, 0)); this.motion_curve = Gamestack.getArg(args, 'motion_curve', TWEEN.Easing.Linear.None); this.highlighted = false; this.sprites = []; this.run_ext = args.run_ext || []; } /** * specify a function to be called when Motion is complete * * @function * @memberof Projectile * @param {Function} fun the function to be called when complete * **********/ onComplete(fun) { this.complete = fun; } onCollide(fun) { this.collide = fun; } setAnimation(anime) { this.animation = anime; return this; } setMotionCurve(c) { this.motion_curve = c; return this; } kill_one() { var spr = this.sprites[this.sprites.length - 1]; Gamestack.remove(spr); } onRun(caller, callkey) { this.run_ext = this.run_ext || []; this.run_ext.push({caller: caller, callkey: callkey}); } shoot_basic(position, size, rot_offset, speed, numberShots, disp){ var __playerInst = this; var bx = position.x, by = position.y, bw = size.x, bh = size.y; var half = numberShots / 2; for(var x = half * -1; x &lt;= half; x++) { var shot = Gamestack.add(new Sprite({ active: true, position: position, size: size, speed: speed, image: animation.image, rotation: new Vector3(0, 0, 0), flipX: false })); shot.setAnimation(animation); rot_offset = new Vector(rot_offset + (x * disp), 0, 0); shot.position.x = bx, shot.position.y = by; shot.rotation.x = 0 + rot_offset.x; shot.stats = { damage: 1 }; if (!options.line) { shot.onUpdate(function () { shot.position.x += Math.cos((shot.rotation.x) * 3.14 / 180) * speed; shot.position.y += Math.sin((shot.rotation.x) * 3.14 / 180) * speed; }); } } } fire(origin, rotation) { for (var x = 0; x &lt; this.run_ext.length; x++) { this.run_ext[x].caller[this.run_ext[x].callkey](); } this.line.origin = origin; this.line.rotation = rotation; console.log('FIRING FROM:' + jstr(origin)); var sprite = new Sprite({image: this.animation.image}); sprite.setAnimation(this.animation); sprite.setSize(this.size); sprite.position = new Vector(0, 0, 0); var __inst = this; __inst.line.fill(); var lp = this.line.points; sprite.position = new Vector(lp[0]); sprite.onUpdate(function (sprite) { for (var x = 0; x &lt; lp.length; x++) { if (sprite.position.equals(lp[x]) &amp;&amp; x &lt; lp.length - 1) { sprite.position = new Vector(lp[x + 1]); break; } if (x == lp.length - 1) { Gamestack.remove(sprite); } } }); Gamestack.add(sprite); this.sprites.push(sprite); } } Gamestack.Projectile = Projectile;; (function(){ console.log('Terrain class... creating'); class Terrain extends Gamestack.Sprite { constructor(args={}) { super(args); //init as Gamestack.Sprite() this.collideables = args.collideables || args.colliders || []; } Collideables(c) { this.collideables = c || []; if(!this.collideables instanceof Array) { return console.error('Must pass array for \"c\" argument'); } return this; } onCollide() // Gamestack.Terrain instance should have an onCollide() function { } } Gamestack.Terrain= Terrain; })(); ; (function(){ console.log('Interactive class... creating'); class Interactive extends Gamestack.Sprite { constructor(args = {}) { super(args); //init as Gamestack.Sprite() this.collision_settings = new Gamestack.CollisionSettings(args); this.collideables = args.collideables || []; Gamestack.Extendors.collideable(this, args); //overwrites the onCollide(): } Collideables(c) { this.collideables = c || []; if(!this.collideables instanceof Array) { return console.error('Must pass array for \"c\" argument'); } return this; } onCollide() // Gamestack.Interactive instance should have an onCollide() function { } } Gamestack.Interactive = Interactive; })();;class SpriteArray { constructor() { this.sprites = []; this.update = []; this.moves = {}; this.load = function() {}; this.update = function() {}; } each(f) { var ix = 0; this.sprites.forEach(function(spr) { f(ix, spr); ix += 1; }); } add(sprite) { this.sprites.push(sprite); return this; } /** * runs a function when the sprite's image has loaded * * @function * @params {Function} f the function to be called on load * @memberof Sprite **********/ onLoadSprites(f) { var sprites = this.sprites, len = this.sprites.length, ix = 0; var __spriteList = this; __spriteList.load = f.bind(this); sprites.forEach(function(spr) { spr.onLoad(function() { ix += 1; if (ix == len) { __spriteList.load(__spriteList.sprites); } }); }); } } Gamestack.SpriteArray = SpriteArray; class SpriteVerticalChain extends SpriteArray { constructor() { super(); } add(sprite) { sprite.parent = this.sprites.length &gt;= 1 ? this.sprites[this.sprites.length - 1] : false; sprite.onUpdate(function() { this.origin = this.origin || new Gamestack.Vector(this.size.x / 2, 0); if (this.parent) { this.offset = this.offset || new Gamestack.Vector(0, 0); var extremity = new Gamestack.Vector(0, this.parent.size.y); var p = this.parent.position.add(this.parent.origin); // p = p.sub(this.origin); // p = p.add(parent.origin); var np = new Gamestack.Vector(Gamestack.GeoMath.rotatePointsXY(extremity.x, extremity.y, this.parent.rotation.x)); this.position = p.add(np).add(this.offset); } }); this.sprites.push(sprite); return this; } } Gamestack.SpriteVerticalChain = SpriteVerticalChain; ; class SpriteCollider { constructor(){ } PixelUnit(){ } Box(){ } Eliptical(){ } TestMode(){ } } ;class FeatureSymbol { constructor(key) { this.key = key || \"@NONE\"; this.symbol = Symbol(key); } } Gamestack.FeatureSymbol = FeatureSymbol; Gamestack.FeatureInjectors = Gamestack.FeatureInjectors || {}; Gamestack.FeatureInject = function(constructor, args) { //console.log('Gamestack.FeatureInject()'); var GClassFeatures = {}; for (var y in Gamestack.ObjectFeatureMap) { if (Gamestack[y] &amp;&amp; typeof Gamestack[y] == 'function') { var constructor = Gamestack[y]; GClassFeatures[y] = {}; // console.log('Feature Symbol-key:' + Gamestack.ObjectFeatureMap[x][y]); GClassFeatures[y].featureSymbols = GClassFeatures[y].featureSymbols || []; for (var z in Gamestack.ObjectFeatureMap[y]) { GClassFeatures[y].featureSymbols.push(new Gamestack.FeatureSymbol(Gamestack.ObjectFeatureMap[y][z])); GClassFeatures[y].featureSymbols.hasKey = function(key) { for (var x = 0; x &lt; this.length; x++) { if (typeof this[x].key !== 'string') continue; if (this[x].key.indexOf('@') == -1) console.error('feature-keys must contain @'); // console.log('eval key:' + this[x].key.split('@')[1]); if (this[x].key.split('@')[1] == key) return true; } return false; }; GClassFeatures[y].featureSymbols.hasSymbol = function(symbol) { for (var x in this) { if (this[x].symbol == symbol) return true; } return false; }; // console.info('adding feature-symbol:' + Gamestack.ObjectFeatureMap[x][y]); } } else { console.error('Gamestack.ObjectFeatureMap: member by name of ' + x + ' does not exist as member of Gamestack'); } } console.info('FEATURES:', GClassFeatures); for (var x in Gamestack.FeatureInjectors) { // console.log(Gamestack.FeatureInjectors[x]); var props = Larva.getProtoFuncs(Gamestack.FeatureInjectors[x]); for (var y = 0; y &lt; props.length; y++) { console.log(x + \":\" + props[y]); for (var z in GClassFeatures) if (GClassFeatures[z] &amp;&amp; GClassFeatures[z].featureSymbols.hasKey(props[y])) { Gamestack.FeatureInjectors[x][props[y]](Gamestack[z].prototype, args); } } } }; class CssFeatures { colored(obj){ obj.Color = function(c) { this.color = c; return this; } } color_transition(min_color, max_color){ this.min_color = min_color; this.max_color = max_color; return this; } text(obj){ obj.Text = function(value) { this.text = value; return this; } } opaque(obj){ obj.Opacity = function(o){ this.opacity = o; return this; } } }; class DataFunctions { data(obj){ obj.Name = function(n) { this.name = n; return this; }; obj.Description = function(d){ this.description = d; return this; }; obj.Context = function(c) { this.context = c; return this; }; } } /*************************** GeometryFeatures: A functional dependency injector injects properties and functions according to Symbols **************************/ class VectorFunctions { constructor() { this.name = 'VectorFunctionals'; } collideable(obj) { obj.collision_callback = function() {}; obj.onCollide = args.onCollide || function(collideables, callback) { if (typeof(collideables) == 'function') { callback = collideables; } this.collision_callback = callback || function() {}; }; } spatial(obj) { obj.Size = function(x, y, z) { if (typeof(x) == 'object') this.size = new Gamestack.Vector(x); else if (!isNaN(x) &amp;&amp; !isNaN(y)) //has minimum of numeric x and y this.size = new Gamestack.Vector(x, y, z); else //use x accross the vector this.size = new Gamestack.Vector(x, x, x); return this; }; obj.Pos = function(x, y, z) { if (typeof(x) == 'object') this.position = new Gamestack.Vector(x); else if (!isNaN(x) &amp;&amp; !isNaN(y)) //has minimum of numeric x and y this.position = new Gamestack.Vector(x, y, z); else //use x accross the vector this.position = new Gamestack.Vector(x, x, x); return this; }; obj.Rot = function(x, y, z) { if (typeof(x) == 'object') this.rotation = new Gamestack.Vector(x); else if (!isNaN(x) &amp;&amp; !isNaN(y)) //has minimum of numeric x and y this.rotation = new Gamestack.Vector(x, y, z); else //use x accross the vector this.rotation = new Gamestack.Vector(x, x, x); return this; }; obj.Position = obj.Pos; obj.Rotate = obj.Rot; obj.Rotation = obj.Rot; } posable(obj) { obj.Pos = function(x, y, z) { if (typeof(x) == 'object') this.position = new Gamestack.Vector(x); else if (!isNaN(x) &amp;&amp; !isNaN(y)) //has minimum of numeric x and y this.position = new Gamestack.Vector(x, y, z); else //use x accross the vector this.position = new Gamestack.Vector(x, x, x); return this; }; obj.Position = obj.Pos; } sizeable(obj) { obj.Size = function(x, y, z) { if (typeof(x) == 'object') this.size = new Gamestack.Vector(x); else if (!isNaN(x) &amp;&amp; !isNaN(y)) //has minimum of numeric x and y this.size = new Gamestack.Vector(x, y, z); else //use x accross the vector this.size = new Gamestack.Vector(x, x, x); return this; }; obj.Position = obj.Pos; } rotable(obj) { obj.Rot = function(x, y, z) { if (typeof(x) == 'object') this.rotation = new Gamestack.Vector(x); else if (!isNaN(x) &amp;&amp; !isNaN(y)) //has minimum of numeric x and y this.rotation = new Gamestack.Vector(x, y, z); else //use x accross the vector this.rotation = new Gamestack.Vector(x, x, x); if (typeof this.Transpose == 'function') { this.Transpose(); } return this; }; obj.Rotate = obj.Rot; obj.Rotation = obj.Rot; } minable(obj) { obj.Min = function(x, y, z) { if (typeof(x) == 'object') this.min = new Gamestack.Vector(x); else if (!isNaN(x) &amp;&amp; !isNaN(y)) //has minimum of numeric x and y this.min = new Gamestack.Vector(x, y, z); else //use x accross the vector this.min = new Gamestack.Vector(x, x, x); return this; }; obj.Minimum = obj.Min; } maxable(obj) { obj.Max = function(x, y, z) { if (typeof(x) == 'object') this.max = new Gamestack.Vector(x); else if (!isNaN(x) &amp;&amp; !isNaN(y)) //has minimum of numeric x and y this.max = new Gamestack.Vector(x, y, z); else //use x accross the vector this.max = new Gamestack.Vector(x, x, x); return this; }; obj.Maximum = obj.Max; } boundable(obj) { this.minable(obj); this.maxable(obj); } selftransposable(obj) { //apply the transposition obj.Transpose = function(rotation, position) { this.rotation = new Gamestack.Vector(rotation || this.rotation); this.position = new Gamestack.Vector(position || this.position); //TODO: Modify this trig function and its call below to an optional 3D rotation for (var x = 0; x &lt; this.points.length; x++) { var p = this.points[x]; var np = Gamestack.Trig.rotate_from_xy(0, 0, p.x, p.y, this.rotation.x); this.points[x] = this.position.add(np); } return this; }; } pointarrayflippable(obj) { //apply the transposition obj.FlipX = function() { var middle = Math.floor(this.points.length / 2); //account for FlipX with length of --odd number var x, y; for (x = this.points.length - 1, y = 0; x &gt; middle, y &lt; middle; x--, y++) { var p1 = this.points[x], p2 = this.points[y]; [p1.x, p2.x] = [p2.x, p1.x]; } return this; }; //apply the transposition obj.FlipY = function() { var middle = Math.floor(this.points.length / 2); //account for FlipX with length of --odd number var x, y; for (x = this.points.length - 1, y = 0; x &gt; middle, y &lt; middle; x--, y++) { var p1 = this.points[x], p2 = this.points[y]; [p1.y, p2.y] = [p2.y, p1.y]; } return this; }; } informable(obj, args) { obj.name = Gamestack.getArg(args, 'name', \"__ObjectName\"); obj.description = Gamestack.getArg(args, 'description', false); obj.group = Gamestack.getArg(args, 'group', 'one'); } tweenable(obj) { obj.curve_string = obj.curve_string || \"linearNone\"; obj.setTweenCurve = function(c) { c = c || \"linear_none\"; var cps = c.split('_'); //alert(cps); var s1 = cps[0].toLowerCase(), s2 = cps[1].toLowerCase(); var curve = TWEEN.Easing.Linear.None; obj.curve_string = 'linear_none' Gamestack.each(TWEEN.Easing, function(ix, easing) { Gamestack.each(TWEEN.Easing[ix], function(iy, easeType) { if (ix == s1 &amp;&amp; iy == s2) { // alert('setting curve'); curve = TWEEN.Easing[ix][iy]; obj.curve_string = ix + '_' + iy; } }); }); obj.curve = curve; return curve; }; obj.curvesToArray = function() { var c = []; Gamestack.each(TWEEN.Easing, function(ix, easing) { Gamestack.each(easing, function(iy, easeType) { if (['in', 'out', 'inout', 'none'].indexOf(iy.toLowerCase()) &gt;= 0) { c.push(ix + \"_\" + iy); } }); }); return c; } } }; Gamestack.FeatureInjectors.CssFeatures = new CssFeatures(); Gamestack.FeatureInjectors.VectorFunctions = new VectorFunctions(); Gamestack.FeatureInjectors.DataFunctions = new DataFunctions(); ;let Larva = { DEV:false, //Display message in console info: function(arg1, arg2) { if(!this.DEV) return; console.info(arg1, arg2); }, log:function(arg1, arg2){ if(!this.DEV) return; console.log(arg1, arg2); }, /* ERRORS always show */ error:function(arg1, arg2){ if(!this.DEV) return; console.error(arg1, arg2); }, warn:function(arg1, arg2){ if(!this.DEV) return; console.error(arg1, arg2); }, //obj is number or becomes fallback number: function(number, fallback = 0) { number = typeof(number) == 'number' ? number : fallback; }, //obj is string or becomes fallback string: function(string, fallback) { string = typeof(string) == 'string' ? string : fallback; }, //obj is Array or becomes wrapped in [] as [obj] arrayWrap: function(obj) { if (obj instanceof Array) return obj; else return [obj]; }, //obj or array-of-objects are ALL truthy (return=true) or not (return=false) allDefined: function(obj_all) { var list = this.arrayWrap(obj_all); var failed = false; for (var x in list) { if (!list[x]) { failed = true; console.error('Failed to define @ Larva.Define()'); } }; return !failed; }, //getPreferredPropertyByKey(): uses the property[key] if present, if not returns same property passed in getPreferredPropertyByKey:function(property, key, warning){ if(property.hasOwnProperty(key)) { this.warn(warning); return property[key]; } else { return property; } }, //obj's are all of type or return false psuedoTypeCheck: function(obj, psuedotype = [], throwing = false) //obj is type or is encapsulated into type { var list = this.arrayWrap(obj); for (var x in list) { if (typeof(list[x]) !== psuedotype &amp;&amp; !(list[x] instanceof psuedotype)) { if (!throwing) return console.error(error); else throw new console.error(error); } } return true; }, getAllFuncs: function(obj) { return Object.getOwnPropertyNames(obj).filter(function (p) { return typeof obj[p] === 'function'; }); }, getProtoFuncs: function(obj) { return Object.getOwnPropertyNames(obj.__proto__).filter(function (p) { return typeof obj[p] === 'function'; }); }, truthOrDie:function(list, exitMessage) //All members of Array are truthy or the program exits with Error() { function findError(obj, error) { return obj || new Error(error) }; for (var x in list) { let e = findError(list[x], exitMessage); if (e instanceof Error) { console.Error(e); } }; }, truthyPropsPerArray: function(obj, propKeys, kill) { var list = this.arrayWrap(obj), keys = this.arrayWrap(propKeys); let error = \"The required truthy property has non-truthy value.\"; function findError(obj, prop) { return obj[prop] || new Error(error) }; var failed = false; for (var x in list) { for (var y in keys) { let e = findError(list[x], keys[y]); if (e instanceof Error) { failed = true; if (kill) throw e; else console.error(e); } } } return !failed; }, typeArgsExtract: function(obj, type) //obj is type or is each-converted into type { if (obj instanceof type) { return obj; } else { obj = [obj]; } return obj; }, typeOrHalt: function(obj, type) //obj is type or error is thrown { if (obj instanceof type) { return obj; } else { throw new Error('object not of required type'); console.info(obj); console.info(type + \"?\"); } return obj; }, typeOrError: function(obj, type) //obj is type or error is logged, execution continues { if (obj instanceof type) { return obj; } else { console.log(new Error('object not of required type')); console.info(obj); console.info(type + \"?\"); } return obj; }, check:function(object, propKey, propValue) { if(!object[propKey]) { object[propKey] = propValue; } } }; ;let Logger = { options: { error: true, info: true, warning: true }, log: function (message) { }, interlog: function (message, loopDuration) { }, info: function (message) { }, warning: function (message) { }, error: function (message) { } } ; let E = function(msg, halt){ //basic Error console.error(msg); }; let L = function(str1, str2){ console.log(str1, str2); }; let I = function(str1, str2){ console.info(str1, str2); }; let R = function(obj, callback){ for(var x in obj) { callback(obj[x]); } }; ;/* ========================================================================= JSManipulate v1.0 (2011-08-01) Javascript image filter &amp; effect library Developed by Joel Besada (http://www.joelb.me) Demo page: http://www.joelb.me/jsmanipulate MIT LICENSED (http://www.opensource.org/licenses/mit-license.php) Copyright (c) 2011, Joel Besada ========================================================================= */ /** * Contains common filter functions. */ function FilterUtils(){ this.HSVtoRGB = function (h, s, v){ var r, g, b; var i = Math.floor(h * 6); var f = h * 6 - i; var p = v * (1 - s); var q = v * (1 - f * s); var t = v * (1 - (1 - f) * s); switch(i % 6){ case 0: r = v; g = t; b = p; break; case 1: r = q; g = v; b = p; break; case 2: r = p; g = v; b = t; break; case 3: r = p; g = q; b = v; break; case 4: r = t; g = p; b = v; break; case 5: r = v; g = p; b = q; break; default: break; } return [r * 255, g * 255, b * 255]; }; this.RGBtoHSV = function (r, g, b){ r = r/255; g = g/255; b = b/255; var max = Math.max(r, g, b); var min = Math.min(r, g, b); var h, s, v = max; var d = max - min; s = max === 0 ? 0 : d / max; if(max === min){ h = 0; }else{ switch(max){ case r: h = (g - b) / d + (g &lt; b ? 6 : 0); break; case g: h = (b - r) / d + 2; break; case b: h = (r - g) / d + 4; break; default: break; } h /= 6; } return [h, s, v]; }; this.getPixel = function (pixels,x,y,width,height){ var pix = (y*width + x)*4; if (x &lt; 0 || x &gt;= width || y &lt; 0 || y &gt;= height) { return [pixels[((this.clampPixel(y, 0, height-1) * width) + this.clampPixel(x, 0, width-1))*4], pixels[((this.clampPixel(y, 0, height-1) * width) + this.clampPixel(x, 0, width-1))*4 + 1], pixels[((this.clampPixel(y, 0, height-1) * width) + this.clampPixel(x, 0, width-1))*4 + 2], pixels[((this.clampPixel(y, 0, height-1) * width) + this.clampPixel(x, 0, width-1))*4 + 3]]; } return [pixels[pix],pixels[pix+1],pixels[pix+2],pixels[pix+3]]; }; var haveNextGaussian = false; var nextGaussian; this.gaussianRandom = function(){ if(haveNextGaussian){ haveNextGaussian = false; return nextGaussian; } else { var v1, v2, s; do { v1 = 2 * Math.random() - 1; v2 = 2 * Math.random() - 1; s = v1 * v1 + v2 * v2; } while (s &gt;= 1 || s === 0); var mult = Math.sqrt(-2 * Math.log(s)/s); nextGaussian = v2 * mult; haveNextGaussian = true; return v1 * mult; } }; this.clampPixel = function (x,a,b){ return (x &lt; a) ? a : (x &gt; b) ? b : x; }; this.triangle = function(x){ var r = this.mod(x, 1); return 2*(r &lt; 0.5 ? r : 1-r); }; this.mod = function(a,b){ var n = parseInt(a/b,10); a -= n*b; if(a &lt; 0){ return a + b; } return a; }; this.mixColors = function(t, rgb1, rgb2){ var r = this.linearInterpolate(t,rgb1[0],rgb2[0]); var g = this.linearInterpolate(t,rgb1[1],rgb2[1]); var b = this.linearInterpolate(t,rgb1[2],rgb2[2]); var a = this.linearInterpolate(t,rgb1[3],rgb2[3]); return [r,g,b,a]; }; this.linearInterpolate = function(t,a,b){ return a + t * (b-a); }; this.bilinearInterpolate = function (x,y,nw,ne,sw,se){ var m0, m1; var r0 = nw[0]; var g0 = nw[1]; var b0 = nw[2]; var a0 = nw[3]; var r1 = ne[0]; var g1 = ne[1]; var b1 = ne[2]; var a1 = ne[3]; var r2 = sw[0]; var g2 = sw[1]; var b2 = sw[2]; var a2 = sw[3]; var r3 = se[0]; var g3 = se[1]; var b3 = se[2]; var a3 = se[3]; var cx = 1.0 - x; var cy = 1.0 - y; m0 = cx * a0 + x * a1; m1 = cx * a2 + x * a3; var a = cy * m0 + y * m1; m0 = cx * r0 + x * r1; m1 = cx * r2 + x * r3; var r = cy * m0 + y * m1; m0 = cx * g0 + x * g1; m1 = cx * g2 + x * g3; var g = cy * m0 + y * m1; m0 = cx * b0 + x * b1; m1 = cx * b2 + x * b3; var b =cy * m0 + y * m1; return [r,g,b,a]; }; this.tableFilter = function (inputData, table, width, height){ for (var y = 0; y &lt; height; y++) { for (var x = 0; x &lt; width; x++) { var pixel = (y*width + x)*4; for(var i = 0; i &lt; 3; i++){ inputData[pixel+i] = table[inputData[pixel+i]]; } } } }; this.convolveFilter = function(inputData, matrix, width, height){ var outputData = []; var rows, cols; rows = cols = Math.sqrt(matrix.length); var rows2 = parseInt(rows/2,10); var cols2 = parseInt(cols/2,10); var trace = true; for(var y = 0; y &lt; height; y++){ for (var x = 0; x &lt; width; x++){ var pixel = (y*width + x)*4; var r = 0, g = 0, b = 0; for(var row = -rows2; row &lt;= rows2; row++){ var iy = y+row; var ioffset; if (0 &lt;= iy &amp;&amp; iy &lt; height) { ioffset = iy*width; } else { ioffset = y*width; } var moffset = cols*(row+rows2)+cols2; for (var col = -cols2; col &lt;= cols2; col++) { var f = matrix[moffset+col]; if (f !== 0) { var ix = x+col; if (!(0 &lt;= ix &amp;&amp; ix &lt; width)) { ix = x; } var iPixel = (ioffset+ix)*4; r += f * inputData[iPixel]; g += f * inputData[iPixel+1]; b += f * inputData[iPixel+2]; } } } outputData[pixel] = parseInt(r+0.5,10); outputData[pixel+1] = parseInt(g+0.5,10); outputData[pixel+2] = parseInt(b+0.5,10); outputData[pixel+3] = inputData[pixel+3]; } } for(var k = 0; k &lt; outputData.length; k++){ inputData[k] = outputData[k]; } }; this.transformFilter = function(inputData, transformInverse, width, height){ var out = []; var outputData = []; for(var j = 0; j &lt; inputData.length; j++){ outputData[j] = inputData[j]; } for(var y = 0; y &lt; height; y++){ for (var x = 0; x &lt; width; x++){ var pixel = (y*width + x)*4; transformInverse.apply(this,[x,y,out]); var srcX = Math.floor(out[0]); var srcY = Math.floor(out[1]); var xWeight = out[0]-srcX; var yWeight = out[1]-srcY; var nw,ne,sw,se; if(srcX &gt;= 0 &amp;&amp; srcX &lt; width-1 &amp;&amp; srcY &gt;= 0 &amp;&amp; srcY &lt; height-1){ var i = (width*srcY + srcX)*4; nw = [inputData[i],inputData[i+1],inputData[i+2],inputData[i+3]]; ne = [inputData[i+4],inputData[i+5],inputData[i+6],inputData[i+7]]; sw = [inputData[i+width*4],inputData[i+width*4+1],inputData[i+width*4+2],inputData[i+width*4+3]]; se = [inputData[i+(width + 1)*4],inputData[i+(width + 1)*4+1],inputData[i+(width + 1)*4+2],inputData[i+(width + 1)*4+3]]; } else { nw = this.getPixel( inputData, srcX, srcY, width, height ); ne = this.getPixel( inputData, srcX+1, srcY, width, height ); sw = this.getPixel( inputData, srcX, srcY+1, width, height ); se = this.getPixel( inputData, srcX+1, srcY+1, width, height ); } var rgba = this.bilinearInterpolate(xWeight,yWeight,nw,ne,sw,se); outputData[pixel] = rgba[0]; outputData[pixel + 1] = rgba[1]; outputData[pixel + 2] = rgba[2]; outputData[pixel + 3] = rgba[3]; } } for(var k = 0; k &lt; outputData.length; k++){ inputData[k] = outputData[k]; } }; } /** * Blurs the image with Gaussian blur. */ function BlurFilter(){ this.name = \"Blur\"; this.isDirAnimatable = false; this.defaultValues = { amount : 3 }; this.valueRanges = { amount : {min:0, max:10} }; this.filter = function(input,values){ var width = input.width; var width4 = width &lt;&lt; 2; var height = input.height; var inputData = input.data; var q; var amount = values.amount; if (amount &lt; 0.0) { amount = 0.0; } if (amount &gt;= 2.5) { q = 0.98711 * amount - 0.96330; } else if (amount &gt;= 0.5) { q = 3.97156 - 4.14554 * Math.sqrt(1.0 - 0.26891 * amount); } else { q = 2 * amount * (3.97156 - 4.14554 * Math.sqrt(1.0 - 0.26891 * 0.5)); } var qq = q * q; var qqq = qq * q; var b0 = 1.57825 + (2.44413 * q) + (1.4281 * qq ) + (0.422205 * qqq); var b1 = ((2.44413 * q) + (2.85619 * qq) + (1.26661 * qqq)) / b0; var b2 = (-((1.4281 * qq) + (1.26661 * qqq))) / b0; var b3 = (0.422205 * qqq) / b0; var bigB = 1.0 - (b1 + b2 + b3); var c = 0; var index; var indexLast; var pixel; var ppixel; var pppixel; var ppppixel; for (c = 0; c &lt; 3; c++) { for (var y = 0; y &lt; height; y++) { index = y * width4 + c; indexLast = y * width4 + ((width - 1) &lt;&lt; 2) + c; pixel = inputData[index]; ppixel = pixel; pppixel = ppixel; ppppixel = pppixel; for (; index &lt;= indexLast; index += 4) { pixel = bigB * inputData[index] + b1 * ppixel + b2 * pppixel + b3 * ppppixel; inputData[index] = pixel; ppppixel = pppixel; pppixel = ppixel; ppixel = pixel; } index = y * width4 + ((width - 1) &lt;&lt; 2) + c; indexLast = y * width4 + c; pixel = inputData[index]; ppixel = pixel; pppixel = ppixel; ppppixel = pppixel; for (; index &gt;= indexLast; index -= 4) { pixel = bigB * inputData[index] + b1 * ppixel + b2 * pppixel + b3 * ppppixel; inputData[index] = pixel; ppppixel = pppixel; pppixel = ppixel; ppixel = pixel; } } } for (c = 0; c &lt; 3; c++) { for (var x = 0; x &lt; width; x++) { index = (x &lt;&lt; 2) + c; indexLast = (height - 1) * width4 + (x &lt;&lt; 2) + c; pixel = inputData[index]; ppixel = pixel; pppixel = ppixel; ppppixel = pppixel; for (; index &lt;= indexLast; index += width4) { pixel = bigB * inputData[index] + b1 * ppixel + b2 * pppixel + b3 * ppppixel; inputData[index] = pixel; ppppixel = pppixel; pppixel = ppixel; ppixel = pixel; } index = (height - 1) * width4 + (x &lt;&lt; 2) + c; indexLast = (x &lt;&lt; 2) + c; pixel = inputData[index]; ppixel = pixel; pppixel = ppixel; ppppixel = pppixel; for (; index &gt;= indexLast; index -= width4) { pixel = bigB * inputData[index] + b1 * ppixel + b2 * pppixel + b3 * ppppixel; inputData[index] = pixel; ppppixel = pppixel; pppixel = ppixel; ppixel = pixel; } } } }; } /** * Adjusts the brightness of the image by going over to HSV values. * Negative values decrease brightness while positive values increase brightness. */ function BrightnessFilter(){ this.name = \"Brightness\"; this.isDirAnimatable = true; this.defaultValues = { amount : 0.0 }; this.valueRanges = { amount : {min:-1.0, max:1.0} }; var filterUtils = new FilterUtils(); this.filter = function(input,values){ var width = input.width, height = input.height; var inputData = input.data; if(values === undefined){ values = this.defaultValues; } var amount = (values.amount === undefined) ? this.defaultValues.amount : values.amount; for (var y = 0; y &lt; height; y++) { for (var x = 0; x &lt; width; x++) { var pixel = (y*width + x)*4; var hsv = filterUtils.RGBtoHSV(inputData[pixel],inputData[pixel+1],inputData[pixel+2]); hsv[2] += amount; if(hsv[2] &lt; 0){ hsv[2] = 0; } else if (hsv[2] &gt; 1){ hsv[2] = 1; } var rgb = filterUtils.HSVtoRGB(hsv[0],hsv[1],hsv[2]); for(var i = 0; i &lt; 3; i++){ inputData[pixel+i] = rgb[i]; } } } }; } /** * Embosses the edges of the image. * This filter takes no parameters but can be applied several times for * further effect. */ function BumpFilter(){ this.name = \"Bump\"; this.isDirAnimatable = true; this.defaultValues = { }; this.valueRanges = { }; var filterUtils = new FilterUtils(); this.filter = function(input,values){ var width = input.width, height = input.height; var inputData = input.data; var matrix = [-1,-1, 0, -1, 1, 1, 0, 1, 1]; filterUtils.convolveFilter(inputData,matrix,width,height); }; } /** * Smears out the image with circular shapes to create a painting style effect. * The mix values sets the intensity of the effect. * NOTE: This filter can be very slow, especially at higher densities/sizes. Use with caution. */ function CircleSmearFilter(){ this.name = \"Circle Smear\"; this.isDirAnimatable = false; this.defaultValues = { size : 4, density : 0.5, mix : 0.5 }; this.valueRanges = { size : {min:1, max:10}, density : {min:0.0, max:1.0}, mix : {min:0.0, max:1.0} }; var filterUtils = new FilterUtils(); this.filter = function(input,values){ var width = input.width, height = input.height; var inputData = input.data; var outputData = []; for(var j = 0; j &lt; inputData.length; j++){ outputData[j] = inputData[j]; } if(values === undefined){ values = this.defaultValues; } var size = (values.size === undefined) ? this.defaultValues.size : values.size; if(size &lt; 1){ size = 1;} size = parseInt(size,10); var density = (values.density === undefined) ? this.defaultValues.density : values.density; var mix = (values.mix === undefined) ? this.defaultValues.mix : values.mix; var radius = size+1; var radius2 = radius*radius; var numShapes = parseInt(2*density/30*width*height / 2,10); for(var i = 0; i &lt; numShapes; i++){ var sx = (Math.random()*Math.pow(2,32) &amp; 0x7fffffff) % width; var sy = (Math.random()*Math.pow(2,32) &amp; 0x7fffffff) % height; var rgb2 = [inputData[(sy*width+sx)*4],inputData[(sy*width+sx)*4+1],inputData[(sy*width+sx)*4+2],inputData[(sy*width+sx)*4+3]]; for(var x = sx - radius; x &lt; sx + radius + 1; x++){ for(var y = sy - radius; y &lt; sy + radius + 1; y++){ var f = (x - sx) * (x - sx) + (y - sy) * (y - sy); if (x &gt;= 0 &amp;&amp; x &lt; width &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; height &amp;&amp; f &lt;= radius2) { var rgb1 = [outputData[(y*width+x)*4],outputData[(y*width+x)*4+1],outputData[(y*width+x)*4+2],outputData[(y*width+x)*4+3]]; var mixedRGB = filterUtils.mixColors(mix,rgb1,rgb2); for(var k = 0; k &lt; 3; k++){ outputData[(y*width+x)*4+k] = mixedRGB[k]; } } } } } for(var l = 0; l &lt; outputData.length; l++){ inputData[l] = outputData[l]; } }; } /** * Adjusts the contrast of the image. */ function ContrastFilter(){ this.name = \"Contrast\"; this.isDirAnimatable = true; this.defaultValues = { amount : 1.0 }; this.valueRanges = { amount : {min:0.0, max:2.0} }; if(!FilterUtils){ if(console){ console.error(\"Unable to find filterutils.js, please include this file! (Required by \" + this.name + \" filter)\"); } return; } var filterUtils = new FilterUtils(); this.filter = function(input,values){ var width = input.width, height = input.height; var inputData = input.data; if(values === undefined){ values = this.defaultValues; } var amount = (values.amount === undefined) ? this.defaultValues.amount : values.amount; if(amount &lt; 0){ amount = 0.0; } var table = []; for(var i = 0; i &lt; 256; i++){ table[i] = parseInt(255 * (((i/255)-0.5)*amount+0.5),10); } filterUtils.tableFilter(inputData,table,width,height); }; } /** * Smears out the image with cross shapes to create a painting style effect. * The mix values sets the intensity of the effect. */ function CrossSmearFilter(){ this.name = \"Cross Smear\"; this.isDirAnimatable = false; this.defaultValues = { distance : 8, density : 0.5, mix : 0.5 }; this.valueRanges = { distance : {min:0, max:30}, density : {min:0.0, max:1.0}, mix : {min:0.0, max:1.0} }; var filterUtils = new FilterUtils(); this.filter = function(input,values){ var width = input.width, height = input.height; var inputData = input.data; var outputData = []; for(var j = 0; j &lt; inputData.length; j++){ outputData[j] = inputData[j]; } if(values === undefined){ values = this.defaultValues; } var distance = (values.distance === undefined) ? this.defaultValues.distance : values.distance; if(distance &lt; 0){ distance = 0;} distance = parseInt(distance,10); var density = (values.density === undefined) ? this.defaultValues.density : values.density; var mix = (values.mix === undefined) ? this.defaultValues.mix : values.mix; var numShapes = parseInt(2*density*width * height / (distance + 1),10); for(var i = 0; i &lt; numShapes; i++){ var x = (Math.random()*Math.pow(2,32) &amp; 0x7fffffff) % width; var y = (Math.random()*Math.pow(2,32) &amp; 0x7fffffff) % height; var length = (Math.random()*Math.pow(2,32)) % distance + 1; var rgb2 = [inputData[(y*width+x)*4],inputData[(y*width+x)*4+1],inputData[(y*width+x)*4+2],inputData[(y*width+x)*4+3]]; var rgb1; var mixedRGB; var k; for (var x1 = x-length; x1 &lt; x+length+1; x1++) { if(x1 &gt;= 0 &amp;&amp; x1 &lt; width){ rgb1 = [outputData[(y*width+x1)*4],outputData[(y*width+x1)*4+1],outputData[(y*width+x1)*4+2],outputData[(y*width+x1)*4+3]]; mixedRGB = filterUtils.mixColors(mix,rgb1,rgb2); for(k = 0; k &lt; 3; k++){ outputData[(y*width+x1)*4+k] = mixedRGB[k]; } } } for (var y1 = y-length; y1 &lt; y+length+1; y1++) { if(y1 &gt;= 0 &amp;&amp; y1 &lt; height){ rgb1 = [outputData[(y1*width+x)*4],outputData[(y1*width+x)*4+1],outputData[(y1*width+x)*4+2],outputData[(y1*width+x)*4+3]]; mixedRGB = filterUtils.mixColors(mix,rgb1,rgb2); for(k = 0; k &lt; 3; k++){ outputData[(y1*width+x)*4+k] = mixedRGB[k]; } } } } for(var l = 0; l &lt; outputData.length; l++){ inputData[l] = outputData[l]; } }; } /** * Diffuses the image creating a frosted glass effect. */ function DiffusionFilter(){ this.name = \"Diffusion\"; this.isDirAnimatable = false; this.defaultValues = { scale: 4 }; this.valueRanges = { scale: {min: 1, max: 100} }; var filterUtils = new FilterUtils(); this.filter = function (input, values){ var width = input.width, height = input.height; var inputData = input.data; if(values === undefined){ values = this.defaultValues; } var scale = (values.scale === undefined) ? this.defaultValues.scale : values.scale; var out = []; var outputData = []; var sinTable = []; var cosTable = []; for(var i = 0; i &lt; 256; i++){ var angle = Math.PI*2*i/256; sinTable[i] = scale*Math.sin(angle); cosTable[i] = scale*Math.cos(angle); } transInverse = function (x,y,out){ var angle = parseInt(Math.random() * 255,10); var distance = Math.random(); out[0] = x + distance * sinTable[angle]; out[1] = y + distance * cosTable[angle]; }; filterUtils.transformFilter(inputData,transInverse,width,height); }; } /** * Dithers the image to the specified number of colors. Setting color to false * grayscales the image. */ function DitherFilter(){ this.name = \"Dither\"; this.isDirAnimatable = false; this.defaultValues = { levels : 3, color : true }; this.valueRanges = { levels : {min:2, max:30}, color : {min:false, max:true} }; var filterUtils = new FilterUtils(); this.filter = function(input,values){ var width = input.width, height = input.height; var inputData = input.data; var outputData = []; var i, j; for (j=0; j &lt; inputData.length; j++) { outputData[j] = 0; } if(values === undefined){ values = this.defaultValues; } var levels = (values.levels === undefined) ? this.defaultValues.levels : values.levels; var color = (values.color === undefined) ? this.defaultValues.color : values.color; if(levels &lt;= 1){ levels = 1; } var matrix = [0,0,0, 0,0,7, 3,5,1]; var sum = 7+3+5+1; var index = 0; var map = []; for (i=0; i &lt; levels; i++) { map[i] = parseInt(255* i / (levels-1),10); } var div = []; for (i=0; i &lt; 256; i++) { div[i] = parseInt(levels*i / 256,10); } for (var y = 0; y &lt; height; y++) { var reverse = ((y &amp; 1) == 1); var direction; if(reverse){ index = (y*width+width-1)*4; direction = -1; } else { index = y*width*4; direction = 1; } for (var x = 0; x &lt; width; x++) { var r1 = inputData[index]; var g1 = inputData[index+1]; var b1 = inputData[index+2]; if(!color){ r1 = g1 = b1 = parseInt((r1+g1+b1) / 3,10); } var r2 = map[div[r1]];var g2 = map[div[g1]];var b2 = map[div[b1]]; outputData[index] = r2; outputData[index + 1] = g2; outputData[index+2] = b2; outputData[index+3] = inputData[index+3]; var er = r1-r2; var eg = g1-g2; var eb = b1-b2; for (i = -1; i &lt;= 1; i++) { var iy = i+y; if (0 &lt;= iy &amp;&amp; iy &lt; height) { for (j = -1; j &lt;= 1; j++) { var jx = j+x; if (0 &lt;= jx &amp;&amp; jx &lt; width) { var w; if (reverse){ w = matrix[(i+1)*3-j+1]; } else{ w = matrix[(i+1)*3+j+1]; } if (w !== 0) { var k = (reverse) ? index - j*4 : index + j*4; r1 = inputData[k]; g1 = inputData[k+1]; b1 = inputData[k+2]; var factor = w/sum; r1 += er * factor; g1 += eg * factor; b1 += eb * factor; inputData[k] = r1; inputData[k+1] = g1 ;inputData[k+2] = b1; } } } } } index += direction*4; } } for(j = 0; j &lt; outputData.length; j++){ inputData[j] = outputData[j]; } }; } /** * Highlights the edges of the image. */ function EdgeFilter(){ this.name = \"Edge Detection\"; this.isDirAnimatable = true; this.defaultValues = { }; this.valueRanges = { }; var matrixH = [-1,-2,-1, 0, 0, 0, 1, 2, 1]; var matrixV = [-1, 0, 1, -2, 0, 2, -1, 0, 1]; this.filter = function(input,values){ var width = input.width, height = input.height; var inputData = input.data; var outputData = []; for (var y = 0; y &lt; height; y++) { for (var x = 0; x &lt; width; x++) { var pixel = (y*width + x)*4; var rh = 0; gh = 0; bh = 0; var rv = 0; gv = 0; bv = 0; for(var row = -1; row &lt;= 1; row++){ var iy = y+row; var ioffset; if(iy &gt;= 0 &amp;&amp; iy &lt; height){ ioffset = iy*width*4; } else { ioffset = y*width*4; } var moffset = 3*(row+1)+1; for(var col = -1; col &lt;= 1; col++){ var ix = x+col; if(!(ix &gt;= 0 &amp;&amp; ix &lt; width)){ ix = x; } ix *= 4; var r = inputData[ioffset+ix]; var g = inputData[ioffset+ix+1]; var b = inputData[ioffset+ix+2]; var h = matrixH[moffset+col]; var v = matrixV[moffset+col]; rh += parseInt(h*r,10); bh += parseInt(h*g,10); gh += parseInt(h*b,10); rv += parseInt(v*r,10); gv += parseInt(v*g,10); bv += parseInt(v*b,10); } } r = parseInt(Math.sqrt(rh*rh + rv*rv) / 1.8,10); g = parseInt(Math.sqrt(gh*gh + gv*gv) / 1.8,10); b = parseInt(Math.sqrt(bh*bh + bv*bv) / 1.8,10); outputData[pixel] = r; outputData[pixel+1] = g; outputData[pixel+2] = b; outputData[pixel+3] = inputData[pixel+3]; } } for(var k = 0; k &lt; outputData.length; k++){ inputData[k] = outputData[k]; } }; } /** * Embosses the image with a simulated light source. * Angle and elevation sets the position of the light. */ function EmbossFilter(){ this.name = \"Emboss\"; this.isDirAnimatable = false; this.defaultValues = { height : 1, angle : 135, elevation : 30 }; this.valueRanges = { height : {min:1, max:10}, angle : {min:0, max:360}, elevation : {min:0, max:180} }; this.filter = function(input,values){ var width = input.width, height = input.height; var inputData = input.data; if(values === undefined){ values = this.defaultValues; } var bumpHeight = (values.height === undefined) ? this.defaultValues.height : values.height; var angle = (values.angle === undefined) ? this.defaultValues.angle : values.angle; var elevation = (values.elevation === undefined) ? this.defaultValues.elevation : values.elevation; angle = angle / 180 * Math.PI; elevation = elevation / 180 * Math.PI; var width45 = 3 * bumpHeight; var pixelScale = 255.9; var bumpPixels = []; var bumpMapWidth = width; var bumpMapHeight = height; for(var i = 0; i &lt; inputData.length; i+=4){ bumpPixels[i/4] = (inputData[i] + inputData[i+1] + inputData[i+2])/3; } var Nx, Ny, Nz, Lx, Ly, Lz, Nz2, NzLz, NdotL; var shade, background; Lx = parseInt(Math.cos(angle) * Math.cos(elevation) * pixelScale,10); Ly = parseInt(Math.sin(angle) * Math.cos(elevation) * pixelScale,10); Lz = parseInt(Math.sin(elevation) * pixelScale,10); Nz = parseInt(6 * 255 / width45,10); Nz2 = Nz * Nz; NzLz = Nz * Lz; background = Lz; var bumpIndex = 0; for (var y = 0; y &lt; height; y++, bumpIndex += bumpMapWidth) { var s1 = bumpIndex; var s2 = s1 + bumpMapWidth; var s3 = s2 + bumpMapWidth; for (var x = 0; x &lt; width; x++, s1++, s2++, s3++) { var pixel = (y*width + x)*4; if (y !== 0 &amp;&amp; y &lt; height-2 &amp;&amp; x !== 0 &amp;&amp; x &lt; width-2) { Nx = bumpPixels[s1-1] + bumpPixels[s2-1] + bumpPixels[s3-1] - bumpPixels[s1+1] - bumpPixels[s2+1] - bumpPixels[s3+1]; Ny = bumpPixels[s3-1] + bumpPixels[s3] + bumpPixels[s3+1] - bumpPixels[s1-1] - bumpPixels[s1] - bumpPixels[s1+1]; if (Nx === 0 &amp;&amp; Ny === 0){ shade = background; } else if ((NdotL = Nx*Lx + Ny*Ly + NzLz) &lt; 0){ shade = 0; } else { shade = parseInt(NdotL / Math.sqrt(Nx*Nx + Ny*Ny + Nz2),10); } } else { shade = background; } inputData[pixel] = inputData[pixel+1] = inputData[pixel+2] = shade; } } }; } /** * Adjust simulated exposure values on the image. */ function ExposureFilter(){ this.name = \"Exposure\"; this.isDirAnimatable = true; this.defaultValues = { exposure : 1.0 }; this.valueRanges = { exposure : {min:0, max:5} }; var filterUtils = new FilterUtils(); this.filter = function(input,values){ var width = input.width, height = input.height; var inputData = input.data; if(values === undefined){ values = this.defaultValues; } var exposure = (values.exposure === undefined) ? this.defaultValues.exposure : values.exposure; var table = []; for(var i = 0; i &lt; 256; i++){ table[i] = parseInt(255 *(1-Math.exp(-(i/255) * exposure)),10); } filterUtils.tableFilter(inputData, table, width, height); }; } /** * Adjusts the gain and bias of the image. Gain alters the contrast while bias biases * colors towards lighter or darker. */ function GainFilter(){ this.name = \"Gain/Bias\"; this.isDirAnimatable = true; this.defaultValues = { gain: 0.5, bias: 0.5 }; this.valueRanges = { gain: {min:0.0, max:1.0}, bias: {min:0.0, max:1.0} }; var table = []; var filterUtils = new FilterUtils(); this.filter = function(input,values){ var width = input.width, height = input.height; var inputData = input.data; if(values === undefined){ values = this.defaultValues; } var gain = (values.gain === undefined) ? this.defaultValues.gain : values.gain; var bias = (values.bias === undefined) ? this.defaultValues.bias : values.bias; var table = []; for(var i = 0; i &lt; 256; i++){ var val = i/255; var k = (1/gain-2) * (1-2*val); val = (val &lt; 0.5) ? val/(k+1) : (k-val)/(k-1); val /= (1/bias-2)*(1-val)+1; table[i] = parseInt(255 * val,10); } filterUtils.tableFilter(inputData,table,width,height); }; } /** * Adjusts the gamma values of the image. Values over 1 increase the gamma while values over 0 decrease gamma. */ function GammaFilter(){ this.name = \"Gamma\"; this.isDirAnimatable = true; this.defaultValues = { amount : 1.0 }; this.valueRanges = { amount : {min:0.0, max:2.0} }; this.filter = function(input,values){ var width = input.width, height = input.height; var inputData = input.data; if(values === undefined){ values = this.defaultValues; } var amount = (values.amount === undefined) ? this.defaultValues.amount : values.amount; if(amount &lt; 0){ amount = 0.0; } if(!FilterUtils){ if(console){ console.error(\"Unable to find filterutils.js, please include this file! (Required by \" + this.name + \" filter)\"); } return; } var filterUtils = new FilterUtils(); var table = []; for(var i = 0; i &lt; 256; i++){ table[i] = 255 * Math.pow(i/255, 1/amount) + 0.5; } filterUtils.tableFilter(inputData,table,width,height); }; } /** * Sets the image to grayscale. */ function GrayscaleFilter(){ this.name = \"Grayscale\"; this.isDirAnimatable = true; this.defaultValues = { }; this.valueRanges = { }; this.filter = function(input,values){ var width = input.width, height = input.height; var inputData = input.data; for (var y = 0; y &lt; height; y++) { for (var x = 0; x &lt; width; x++) { var pixel = (y*width + x)*4; var luma = inputData[pixel]*0.3 + inputData[pixel+1]*0.59 + inputData[pixel+2]*0.11; inputData[pixel] = inputData[pixel+1] = inputData[pixel+2] = luma; } } }; } /** * Adjusts the hue of the image by going over to HSV values. */ function HueFilter(){ this.name = \"Hue\"; this.isDirAnimatable = true; this.defaultValues = { amount : 0.0 }; this.valueRanges = { amount : {min:-1.0, max:1.0} }; var filterUtils = new FilterUtils(); this.filter = function(input,values){ var width = input.width, height = input.height; var inputData = input.data; if(values === undefined){ values = this.defaultValues; } var amount = (values.amount === undefined) ? this.defaultValues.amount : values.amount; for (var y = 0; y &lt; height; y++) { for (var x = 0; x &lt; width; x++) { var pixel = (y*width + x)*4; var hsv = filterUtils.RGBtoHSV(inputData[pixel],inputData[pixel+1],inputData[pixel+2]); hsv[0] += amount; while(hsv[0] &lt; 0){ hsv[0] += 360; } var rgb = filterUtils.HSVtoRGB(hsv[0],hsv[1],hsv[2]); for(var i = 0; i &lt; 3; i++){ inputData[pixel+i] = rgb[i]; } } } }; } /** * Inverts the colors of the image. */ function InvertFilter(){ this.name = \"Invert\"; this.isDirAnimatable = true; this.defaultValues = { }; this.valueRanges = { }; this.filter = function(input,values){ var width = input.width, height = input.height; var inputData = input.data; for (var y = 0; y &lt; height; y++) { for (var x = 0; x &lt; width; x++) { var pixel = (y*width + x)*4; for(var i = 0; i &lt; 3; i++){ inputData[pixel+i] = 255 - inputData[pixel+i]; } } } }; } /** * Creates a kaleidoscope effect on the image. CenterX and CenterY specify the * position in terms of ratios of width and height. */ function KaleidoscopeFilter(){ this.name = \"Kaleidoscope\"; this.isDirAnimatable = false; this.defaultValues = { angle : 0, rotation : 0, sides : 3, centerX : 0.5, centerY : 0.5 }; this.valueRanges = { angle : {min: 0, max: 360}, rotation : {min: 0, max: 360}, sides : {min: 1, max: 30}, centerX : {min: 0.0, max:1.0}, centerY : {min: 0.0, max:1.0} }; var filterUtils = new FilterUtils(); this.filter = function (input, values){ var width = input.width, height = input.height; var inputData = input.data; if(values === undefined){ values = this.defaultValues; } var angle = (values.angle === undefined) ? this.defaultValues.angle : values.angle; var rotation = (values.rotation === undefined) ? this.defaultValues.rotation : values.rotation; var sides = (values.sides === undefined) ? this.defaultValues.sides : values.sides; var centerX = (values.centerX === undefined) ? this.defaultValues.centerX : values.centerX; var centerY = (values.centerY === undefined) ? this.defaultValues.centerY : values.centerY; var iCenterX = width * centerX; var iCenterY = height * centerY; angle = angle/180 * Math.PI; rotation = rotation/180 * Math.PI; var transInverse = function(x,y,out){ var dx = x - iCenterX; var dy = y - iCenterY; var r = Math.sqrt(dx*dx + dy*dy); var theta = Math.atan2(dy,dx) - angle - rotation; theta = filterUtils.triangle(theta/Math.PI*sides*0.5); theta += angle; out[0] = iCenterX + r*Math.cos(theta); out[1] = iCenterY + r*Math.sin(theta); }; filterUtils.transformFilter(inputData,transInverse,width,height); }; } /** * Applies a fisheye lens distortion effect on the image. CenterX and CenterY specify the * position in terms of ratios of width and height. */ function LensDistortionFilter(){ this.name = \"Lens Distortion\"; this.isDirAnimatable = false; this.defaultValues = { refraction : 1.5, radius : 50, centerX : 0.5, centerY : 0.5 }; this.valueRanges = { refraction : {min: 1, max: 10}, radius : {min: 1, max: 200}, centerX : {min: 0.0, max:1.0}, centerY : {min: 0.0, max:1.0} }; var filterUtils = new FilterUtils(); this.filter = function (input, values){ var width = input.width, height = input.height; var inputData = input.data; if(values === undefined){ values = this.defaultValues; } var refraction = (values.refraction === undefined) ? this.defaultValues.refraction : values.refraction; var centerX = (values.centerX === undefined) ? this.defaultValues.centerX : values.centerX; var centerY = (values.centerY === undefined) ? this.defaultValues.centerY : values.centerY; var radius = (values.radius === undefined) ? this.defaultValues.radius : values.radius; var radius2 = radius*radius; var iCenterX = width * centerX; var iCenterY = height * centerY; var transInverse = function(x,y,out){ var dx = x-iCenterX; var dy = y-iCenterY; var x2 = dx*dx; var y2 = dy*dy; if (y2 &gt;= (radius2 - (radius2*x2)/radius2)) { out[0] = x; out[1] = y; } else { var rRefraction = 1.0 / refraction; var z = Math.sqrt((1.0 - x2/radius2 - y2/radius2) * radius2); var z2 = z*z; var xAngle = Math.acos(dx / Math.sqrt(x2+z2)); var angle1 = Math.PI/2 - xAngle; var angle2 = Math.asin(Math.sin(angle1)*rRefraction); angle2 = Math.PI/2 - xAngle - angle2; out[0] = x - Math.tan(angle2)*z; var yAngle = Math.acos(dy / Math.sqrt(y2+z2)); angle1 = Math.PI/2 - yAngle; angle2 = Math.asin(Math.sin(angle1)*rRefraction); angle2 = Math.PI/2 - yAngle - angle2; out[1] = y - Math.tan(angle2)*z; } }; filterUtils.transformFilter(inputData,transInverse,width,height); }; } /** * Smears out the image with line shapes to create a painting style effect. Mix specifies * the intensity of the effect. */ function LineSmearFilter(){ this.name = \"Line Smear\"; this.isDirAnimatable = false; this.defaultValues = { distance : 8, density : 0.5, angle : 0, mix : 0.5 }; this.valueRanges = { distance : {min:1, max:30}, density : {min:0.0, max:1.0}, angle : {min:0, max:360}, mix : {min:0.0, max:1.0} }; var filterUtils = new FilterUtils(); this.filter = function(input,values){ var width = input.width, height = input.height; var inputData = input.data; var outputData = []; var k; for(k = 0; k &lt; inputData.length; k++){ outputData[k] = inputData[k]; } if(values === undefined){ values = this.defaultValues; } var distance = (values.distance === undefined) ? this.defaultValues.distance : values.distance; if(distance &lt; 1){ distance = 1;} distance = parseInt(distance,10); var density = (values.density === undefined) ? this.defaultValues.density : values.density; var angle = (values.angle === undefined) ? this.defaultValues.angle : values.angle; var mix = (values.mix === undefined) ? this.defaultValues.mix : values.mix; angle = angle/180*Math.PI; var sinAngle = Math.sin(angle); var cosAngle = Math.cos(angle); var numShapes = parseInt(2*density*width*height / 2,10); for(var i = 0; i &lt; numShapes; i++){ var sx = (Math.random()*Math.pow(2,32) &amp; 0x7fffffff) % width; var sy = (Math.random()*Math.pow(2,32) &amp; 0x7fffffff) % height; var length = (Math.random()*Math.pow(2,32) &amp; 0x7fffffff) % distance + 1; var rgb2 = [inputData[(sy*width+sx)*4],inputData[(sy*width+sx)*4+1],inputData[(sy*width+sx)*4+2],inputData[(sy*width+sx)*4+3]]; var dx = parseInt(length*cosAngle,10); var dy = parseInt(length*sinAngle,10); var x0 = sx-dx; var y0 = sy-dy; var x1 = sx+dx; var y1 = sy+dy; var x, y, d, incrE, incrNE, ddx, ddy; if (x1 &lt; x0){ ddx = -1; } else { ddx = 1; } if (y1 &lt; y0){ ddy = -1; } else { ddy = 1; } dx = x1-x0; dy = y1-y0; dx = Math.abs(dx); dy = Math.abs(dy); x = x0; y = y0; var rgb1; var mixedRGB; if (x &lt; width &amp;&amp; x &gt;= 0 &amp;&amp; y &lt; height &amp;&amp; y &gt;= 0) { rgb1 = [outputData[(y*width+x)*4],outputData[(y*width+x)*4+1],outputData[(y*width+x)*4+2],outputData[(y*width+x)*4+3]]; mixedRGB = filterUtils.mixColors(mix,rgb1,rgb2); for(k = 0; k &lt; 3; k++){ outputData[(y*width+x)*4+k] = mixedRGB[k]; } } if (Math.abs(dx) &gt; Math.abs(dy)) { d = 2*dy-dx; incrE = 2*dy; incrNE = 2*(dy-dx); while (x != x1) { if (d &lt;= 0){ d += incrE; } else { d += incrNE; y += ddy; } x += ddx; if (x &lt; width &amp;&amp; x &gt;= 0 &amp;&amp; y &lt; height &amp;&amp; y &gt;= 0) { rgb1 = [outputData[(y*width+x)*4],outputData[(y*width+x)*4+1],outputData[(y*width+x)*4+2],outputData[(y*width+x)*4+3]]; mixedRGB = filterUtils.mixColors(mix,rgb1,rgb2); for(k = 0; k &lt; 3; k++){ outputData[(y*width+x)*4+k] = mixedRGB[k]; } } } } else { d = 2*dx-dy; incrE = 2*dx; incrNE = 2*(dx-dy); while (y != y1) { if (d &lt;= 0) { d += incrE; }else { d += incrNE; x += ddx; } y += ddy; if (x &lt; width &amp;&amp; x &gt;= 0 &amp;&amp; y &lt; height &amp;&amp; y &gt;= 0) { rgb1 = [outputData[(y*width+x)*4],outputData[(y*width+x)*4+1],outputData[(y*width+x)*4+2],outputData[(y*width+x)*4+3]]; mixedRGB = filterUtils.mixColors(mix,rgb1,rgb2); for(k = 0; k &lt; 3; k++){ outputData[(y*width+x)*4+k] = mixedRGB[k]; } } } } } for(k = 0; k &lt; outputData.length; k++){ inputData[k] = outputData[k]; } }; } /** * Replaces every pixel with the maximum RGB value of the neighboring pixels. Each color is * considered separately. */ function MaximumFilter(){ this.name = \"Maximum\"; this.isDirAnimatable = true; this.defaultValues = { }; this.valueRanges = { }; this.filter = function(input,values){ var width = input.width, height = input.height; var inputData = input.data; var outputData = []; for (var y = 0; y &lt; height; y++) { for (var x = 0; x &lt; width; x++) { var pixel = (y*width + x)*4; var maxR = 0; var maxG = 0; var maxB = 0; for (var dy = -1; dy &lt;= 1; dy++){ var iy = y+dy; if(iy &gt;= 0 &amp;&amp; iy &lt; height){ for (var dx = -1; dx &lt;= 1; dx++){ var ix = x+dx; if(ix &gt;= 0 &amp;&amp; ix &lt; width){ var iPixel = (iy*width + ix)*4; maxR = Math.max(maxR,inputData[iPixel]); maxG = Math.max(maxG,inputData[iPixel+1]); maxB = Math.max(maxB,inputData[iPixel+2]); } } } } outputData[pixel] = maxR; outputData[pixel+1] = maxG; outputData[pixel+2] = maxB; outputData[pixel+3] = inputData[pixel+3]; } } for(var k = 0; k &lt; outputData.length; k++){ inputData[k] = outputData[k]; } }; } /** * Replaces every pixel with the median RGB value of the neighboring pixels. Each color is * considered separately. */ function MedianFilter(){ this.name = \"Median\"; this.isDirAnimatable = false; this.defaultValues = { }; this.valueRanges = { }; this.filter = function(input,values){ var width = input.width, height = input.height; var inputData = input.data; var outputData = []; for (var y = 0; y &lt; height; y++) { for (var x = 0; x &lt; width; x++) { var pixel = (y*width + x)*4; var rList = []; var gList = []; var bList = []; for (var dy = -1; dy &lt;= 1; dy++){ var iy = y+dy; if(iy &gt;= 0 &amp;&amp; iy &lt; height){ for (var dx = -1; dx &lt;= 1; dx++){ var ix = x+dx; if(ix &gt;= 0 &amp;&amp; ix &lt; width){ var iPixel = (iy*width + ix)*4; rList.push(inputData[iPixel]); gList.push(inputData[iPixel+1]); bList.push(inputData[iPixel+2]); } } } } var sortFunc = function(a,b){ return a-b; }; rList.sort(sortFunc); gList.sort(sortFunc); bList.sort(sortFunc); outputData[pixel] = rList[4]; outputData[pixel+1] = gList[4]; outputData[pixel+2] = bList[4]; outputData[pixel+3] = inputData[pixel+3]; } } for(var k = 0; k &lt; outputData.length; k++){ inputData[k] = outputData[k]; } }; } /** * Replaces every pixel with the minimum RGB value of the neighboring pixels. Each color is * considered separately. */ function MinimumFilter(){ this.name = \"Minimum\"; this.isDirAnimatable = true; this.defaultValues = { }; this.valueRanges = { }; this.filter = function(input,values){ var width = input.width, height = input.height; var inputData = input.data; var outputData = []; for (var y = 0; y &lt; height; y++) { for (var x = 0; x &lt; width; x++) { var pixel = (y*width + x)*4; var minR = 255; var minG = 255; var minB = 255; for (var dy = -1; dy &lt;= 1; dy++){ var iy = y+dy; if(iy &gt;= 0 &amp;&amp; iy &lt; height){ for (var dx = -1; dx &lt;= 1; dx++){ var ix = x+dx; if(ix &gt;= 0 &amp;&amp; ix &lt; width){ var iPixel = (iy*width + ix)*4; minR = Math.min(minR,inputData[iPixel]); minG = Math.min(minG,inputData[iPixel+1]); minB = Math.min(minB,inputData[iPixel+2]); } } } } outputData[pixel] = minR; outputData[pixel+1] = minG; outputData[pixel+2] = minB; outputData[pixel+3] = inputData[pixel+3]; } } for(var k = 0; k &lt; outputData.length; k++){ inputData[k] = outputData[k]; } }; } /** * Creates random noise on the image, with or without color. */ function NoiseFilter(){ this.name = \"Noise\"; this.isDirAnimatable = true; this.defaultValues = { amount : 25, density : 1, monochrome : true }; this.valueRanges = { amount : {min:0, max:100}, density : {min:0, max:1.0}, monochrome : {min:false, max:true} }; this.filter = function(input,values){ var width = input.width, height = input.height; var inputData = input.data; if(values === undefined){ values = this.defaultValues; } var amount = (values.amount === undefined) ? this.defaultValues.amount : values.amount; var density = (values.density === undefined) ? this.defaultValues.density : values.density; var monochrome = (values.monochrome === undefined) ? this.defaultValues.monochrome : values.monochrome; for (var y = 0; y &lt; height; y++) { for (var x = 0; x &lt; width; x++) { var pixel = (y*width + x)*4; if(Math.random() &lt;= density){ var n; if(monochrome){ n = parseInt((2*Math.random()-1) * amount,10); inputData[pixel] += n; inputData[pixel+1] += n; inputData[pixel+2] += n; } else { for(var i = 0; i &lt; 3; i++){ n = parseInt((2*Math.random()-1) * amount,10); inputData[pixel+i] += n; } } } } } }; } /** * Produces an oil painting effect on the image. * NOTE: This filter can be very slow, especially at higher ranges. Use with caution. */ function OilFilter(){ this.name = \"Oil Painting\"; this.isDirAnimatable = false; this.defaultValues = { range : 3 }; this.valueRanges = { range : {min:0, max:5} }; this.filter = function(input,values){ var width = input.width, height = input.height; var inputData = input.data; var outputData = []; if(values === undefined){ values = this.defaultValues; } var range = (values.range === undefined) ? this.defaultValues.range : values.range; range = parseInt(range,10); var index = 0; var rHistogram = []; var gHistogram = []; var bHistogram = []; var rTotal = []; var gTotal = []; var bTotal = []; var levels = 256; for (var y = 0; y &lt; height; y++) { for (var x = 0; x &lt; width; x++) { var pixel = (y*width + x)*4; for (var j = 0; j &lt; levels; j++){ rHistogram[j] = gHistogram[j] = bHistogram[j] = rTotal[j] = gTotal[j] = bTotal[j] = 0; } for (var row = -range; row &lt;= range; row++) { var iy = y+row; var ioffset; if (0 &lt;= iy &amp;&amp; iy &lt; height) { ioffset = iy*width; for (var col = -range; col &lt;= range; col++) { var ix = x+col; if (0 &lt;= ix &amp;&amp; ix &lt; width) { var ro = inputData[(ioffset+ix)*4]; var go = inputData[(ioffset+ix)*4+1]; var bo = inputData[(ioffset+ix)*4+2]; var ri = ro*levels/256; var gi = go*levels/256; var bi = bo*levels/256; rTotal[ri] += ro; gTotal[gi] += go; bTotal[bi] += bo; rHistogram[ri]++; gHistogram[gi]++; bHistogram[bi]++; } } } } var r = 0, g = 0, b = 0; for (var i = 1; i &lt; levels; i++) { if (rHistogram[i] &gt; rHistogram[r]){ r = i; } if (gHistogram[i] &gt; gHistogram[g]){ g = i; } if (bHistogram[i] &gt; bHistogram[b]){ b = i; } } r = rTotal[r] / rHistogram[r]; g = gTotal[g] / gHistogram[g]; b = bTotal[b] / bHistogram[b]; outputData[pixel] = r; outputData[pixel+1] = g; outputData[pixel+2] = b; outputData[pixel+3] = inputData[pixel+3]; } } for(var k = 0; k &lt; outputData.length; k++){ inputData[k] = outputData[k]; } }; } /** * Changes the opacity of the image. */ function OpacityFilter(){ this.name = \"Opacity\"; this.isDirAnimatable = true; this.defaultValues = { amount : 1.0 }; this.valueRanges = { amount : {min:0.0, max:1.0} }; this.filter = function(input,values){ var width = input.width, height = input.height; var inputData = input.data; if(values === undefined){ values = this.defaultValues; } var amount = (values.amount === undefined) ? this.defaultValues.amount : values.amount; for (var y = 0; y &lt; height; y++) { for (var x = 0; x &lt; width; x++) { var pixel = (y*width + x)*4; inputData[pixel+3] = 255*amount; } } }; } /** * Pinches and whirls the image toward the center point. CenterX and CenterY specify the * position in terms of ratios of width and height. */ function PinchFilter(){ this.name = \"Pinch/Whirl\"; this.isDirAnimatable = false; this.defaultValues = { amount : 0.5, radius : 100, angle : 0, centerX : 0.5, centerY : 0.5 }; this.valueRanges = { amount : {min: -1.0, max: 1.0}, radius : {min: 1, max: 200}, angle : {min: 0, max: 360}, centerX : {min: 0.0, max:1.0}, centerY : {min: 0.0, max:1.0} }; var filterUtils = new FilterUtils(); this.filter = function (input, values){ var width = input.width, height = input.height; var inputData = input.data; if(values === undefined){ values = this.defaultValues; } var amount = (values.amount === undefined) ? this.defaultValues.amount : values.amount; var angle = (values.angle === undefined) ? this.defaultValues.angle : values.angle; var centerX = (values.centerX === undefined) ? this.defaultValues.centerX : values.centerX; var centerY = (values.centerY === undefined) ? this.defaultValues.centerY : values.centerY; var radius = (values.radius === undefined) ? this.defaultValues.radius : values.radius; var radius2 = radius*radius; angle = angle/180 * Math.PI; var iCenterX = width * centerX; var iCenterY = height * centerY; var transInverse = function(x,y,out){ var dx = x-iCenterX; var dy = y-iCenterY; var distance = dx*dx + dy*dy; if(distance &gt; radius2 || distance === 0){ out[0] = x; out[1] = y; } else { var d = Math.sqrt( distance / radius2 ); var t = Math.pow( Math.sin( Math.PI*0.5 * d ), -amount); dx *= t; dy *= t; var e = 1 - d; var a = angle * e * e; var s = Math.sin(a); var c = Math.cos(a); out[0] = iCenterX + c*dx - s*dy; out[1] = iCenterY + s*dx + c*dy; } }; filterUtils.transformFilter(inputData,transInverse,width,height); }; } /** * Pixelates the image i.e. divides the image into blocks of color. */ function PixelationFilter(){ this.name = \"Pixelation\"; this.isDirAnimatable = false; this.defaultValues = { size : 5 }; this.valueRanges = { size : {min:1, max:50} }; this.filter = function(input,values){ var width = input.width, height = input.height; var inputData = input.data; if(values === undefined){ values = this.defaultValues; } var size = (values.size === undefined) ? this.defaultValues.size : values.size; size = parseInt(size,10); var pixels = []; var by, bx, bPixel; for (var y = 0; y &lt; height; y+=size) { for (var x = 0; x &lt; width; x+=size) { var pixel = (y*width + x)*4; var w = Math.min(size, width-x); var h = Math.min(size, height-y); var t = w*h; var r = 0, g = 0, b = 0; for(by = y; by &lt; y+h; by++){ for(bx = x; bx &lt; x+w; bx++){ bPixel = (by*width + bx)*4; r += inputData[bPixel]; g += inputData[bPixel+1]; b += inputData[bPixel+2]; } } for(by = y; by &lt; y+h; by++){ for(bx = x; bx &lt; x+w; bx++){ bPixel = (by*width + bx)*4; inputData[bPixel] = r/t; inputData[bPixel+1] = g/t; inputData[bPixel+2] = b/t; } } } } }; } /** * Posterizes the image, i.e. restricts the color values to a set amount of levels. */ function PosterizeFilter(){ this.name = \"Posterize\"; this.isDirAnimatable = false; this.defaultValues = { levels : 6 }; this.valueRanges = { levels : {min:2, max:30 } }; var filterUtils = new FilterUtils(); this.filter = function(input,values){ var width = input.width, height = input.height; var inputData = input.data; if(values === undefined){ values = this.defaultValues; } var levels = (values.levels === undefined) ? this.defaultValues.levels : parseInt(values.levels,10); if(levels &lt;= 1){ return; } var table = []; for(var i = 0; i &lt; 256; i++){ table[i] = parseInt(255 * parseInt(i*levels/256,10) / (levels-1),10); } filterUtils.tableFilter(inputData,table,width,height); }; } /** * Adjust the factor of each RGB color value in the image. */ function RGBAdjustFilter(){ this.name = \"RGBAdjust\"; this.isDirAnimatable = true; this.defaultValues = { red: 1.0, green: 1.0, blue: 1.0 }; this.valueRanges = { red: {min: 0.0, max: 2.0}, green: {min: 0.0, max: 2.0}, blue: {min: 0.0, max: 2.0} }; this.filter = function(input,values){ var width = input.width, height = input.height; var inputData = input.data; if(values === undefined){ values = this.defaultValues; } var red = (values.red === undefined) ? this.defaultValues.red : values.red; var green = (values.green === undefined) ? this.defaultValues.green : values.green; var blue = (values.blue === undefined) ? this.defaultValues.blue : values.blue; if(red &lt; 0){ red = 0; } if(green &lt; 0){ green = 0; } if(blue &lt; 0){ blue = 0; } for (var y = 0; y &lt; height; y++) { for (var x = 0; x &lt; width; x++) { var pixel = (y*width + x)*4; inputData[pixel] *= red; inputData[pixel+1] *= green; inputData[pixel+2] *= blue; } } }; } /** * Adjusts the saturation value of the image. Values over 1 increase saturation while values below decrease saturation. * For a true grayscale effect, use the grayscale filter instead. */ function SaturationFilter(){ this.name = \"Saturation\"; this.isDirAnimatable = true; this.defaultValues = { amount : 1.0 }; this.valueRanges = { amount : {min:0.0, max:2.0} }; this.filter = function(input,values){ var width = input.width, height = input.height; var inputData = input.data; if(values === undefined){ values = this.defaultValues; } var amount = (values.amount === undefined) ? this.defaultValues.amount : values.amount; var RW = 0.3; var RG = 0.59; var RB = 0.11; var a = (1 - amount) * RW + amount; var b = (1 - amount) * RW; var c = (1 - amount) * RW; var d = (1 - amount) * RG; var e = (1 - amount) * RG + amount; var f = (1 - amount) * RG; var g = (1 - amount) * RB; var h = (1 - amount) * RB; var i = (1 - amount) * RB + amount; for (var y = 0; y &lt; height; y++) { for (var x = 0; x &lt; width; x++) { var pixel = (y*width + x)*4; var pR = inputData[pixel]; var pG = inputData[pixel+1]; var pB = inputData[pixel+2]; inputData[pixel] = a*pR + d*pG + g*pB; inputData[pixel+1] = b*pR + e*pG + h*pB; inputData[pixel+2] = c*pR + f*pG + i*pB; } } }; } /** * Creates ripples on the image horizontally/vertically in a sawtooth pattern. */ function SawtoothRippleFilter(){ this.name = \"Sawtooth Ripples\"; this.isDirAnimatable = false; this.defaultValues = { xAmplitude : 5, yAmplitude : 5, xWavelength : 16, yWavelength : 16 }; this.valueRanges = { xAmplitude : {min:0, max:30}, yAmplitude : {min:0, max:30}, xWavelength : {min:1, max:50}, yWavelength : {min:1, max:50} }; var filterUtils = new FilterUtils(); this.filter = function (input, values){ var width = input.width, height = input.height; var inputData = input.data; if(values === undefined){ values = this.defaultValues; } var xAmplitude = (values.xAmplitude === undefined) ? this.defaultValues.xAmplitude : values.xAmplitude; var yAmplitude = (values.yAmplitude === undefined) ? this.defaultValues.yAmplitude : values.yAmplitude; var xWavelength = (values.xWavelength === undefined) ? this.defaultValues.xWavelength : values.xWavelength; var yWavelength = (values.yWavelength === undefined) ? this.defaultValues.yWavelength : values.yWavelength; var transInverse = function(x,y,out){ var nx = y/xWavelength; var ny = x/yWavelength; var fx = filterUtils.mod(nx,1); var fy = filterUtils.mod(ny,1); out[0] = x + xAmplitude * fx; out[1] = y + yAmplitude * fy; }; filterUtils.transformFilter(inputData,transInverse,width,height); }; } /** * Creates a sepia effect on the image i.e. gives the image a yellow-brownish tone. */ function SepiaFilter(){ this.name = \"Sepia\"; this.isDirAnimatable = true; this.defaultValues = { amount : 10 }; this.valueRanges = { amount : {min:0, max:30} }; var filterUtils = new FilterUtils(); this.filter = function(input,values){ var width = input.width, height = input.height; var inputData = input.data; if(values === undefined){ values = this.defaultValues; } var amount = (values.amount === undefined) ? this.defaultValues.amount : values.amount; amount *= 255/100; for (var y = 0; y &lt; height; y++) { for (var x = 0; x &lt; width; x++) { var pixel = (y*width + x)*4; var luma = inputData[pixel]*0.3 + inputData[pixel+1]*0.59 + inputData[pixel+2]*0.11; var r,g,b; r = g = b = luma; r += 40; g += 20; b -= amount; inputData[pixel] = r; inputData[pixel+1] = g; inputData[pixel+2] = b; } } }; } /** * Sharpens the image slightly. For increased effect, apply the filter multiple times. */ function SharpenFilter(){ this.name = \"Sharpen\"; this.isDirAnimatable = true; this.defaultValues = { }; this.valueRanges = { }; var filterUtils = new FilterUtils(); this.filter = function(input,values){ var width = input.width, height = input.height; var inputData = input.data; var matrix = [ 0.0,-0.2, 0.0, -0.2, 1.8,-0.2, 0.0, -0.2, 0.0]; filterUtils.convolveFilter(inputData,matrix,width,height); }; } /** * Creates ripples on the image horizontally/vertically in a sine pattern. */ function SineRippleFilter(){ this.name = \"Sine Ripples\"; this.isDirAnimatable = false; this.defaultValues = { xAmplitude : 5, yAmplitude : 5, xWavelength : 16, yWavelength : 16 }; this.valueRanges = { xAmplitude : {min:0, max:30}, yAmplitude : {min:0, max:30}, xWavelength : {min:1, max:50}, yWavelength : {min:1, max:50} }; var filterUtils = new FilterUtils(); this.filter = function (input, values){ var width = input.width, height = input.height; var inputData = input.data; if(values === undefined){ values = this.defaultValues; } var xAmplitude = (values.xAmplitude === undefined) ? this.defaultValues.xAmplitude : values.xAmplitude; var yAmplitude = (values.yAmplitude === undefined) ? this.defaultValues.yAmplitude : values.yAmplitude; var xWavelength = (values.xWavelength === undefined) ? this.defaultValues.xWavelength : values.xWavelength; var yWavelength = (values.yWavelength === undefined) ? this.defaultValues.yWavelength : values.yWavelength; var transInverse = function(x,y,out){ var nx = y/xWavelength; var ny = x/yWavelength; var fx = Math.sin(nx); var fy = Math.sin(ny); out[0] = x + xAmplitude * fx; out[1] = y + yAmplitude * fy; }; filterUtils.transformFilter(inputData,transInverse,width,height); }; } /** * Produces a solarization effect on the image. */ function SolarizeFilter(){ this.name = \"Solarize\"; this.isDirAnimatable = true; this.defaultValues = { }; this.valueRanges = { }; var filterUtils = new FilterUtils(); this.filter = function(input,values){ var width = input.width, height = input.height; var inputData = input.data; var table = []; for(var i = 0; i &lt; 256; i++){ var val = (i/255 &gt; 0.5) ? 2*(i/255-0.5) : 2*(0.5-i/255); table[i] = parseInt(255 * val,10); } filterUtils.tableFilter(inputData, table, width, height); }; } /** * Generates a sparkle/sunburst effect on the image. CenterX and CenterY specify the * position in terms of ratios of width and height. */ function SparkleFilter(){ this.name = \"Sparkle\"; this.isDirAnimatable = false; this.defaultValues = { rays : 50, size : 25, amount : 50, randomness : 25, centerX : 0.5, centerY : 0.5 }; this.valueRanges = { rays : {min:1, max:100}, size : {min:1, max:200}, amount : {min:0, max:100}, randomness : {min:0, max:50}, centerX : {min:0, max:1.0}, centerY : {min:0, max:1.0} }; var filterUtils = new FilterUtils(); this.filter = function(input,values){ var width = input.width, height = input.height; var inputData = input.data; if(values === undefined){ values = this.defaultValues; } var rays = (values.rays === undefined) ? this.defaultValues.rays : values.rays; rays = parseInt(rays, 10); var size = (values.size === undefined) ? this.defaultValues.size : values.size; var amount = (values.amount === undefined) ? this.defaultValues.amount : values.amount; var randomness = (values.randomness === undefined) ? this.defaultValues.randomness : values.randomness; var centerX = (values.centerX === undefined) ? this.defaultValues.centerX : values.centerX; var centerY = (values.centerY === undefined) ? this.defaultValues.centerY : values.centerY; var iCenterX = centerX * width; var iCenterY = centerY * height; var rayLengths = []; for(var j = 0; j &lt; rays; j++){ rayLengths[j]= size + randomness / 100 * size * filterUtils.gaussianRandom(); } for (var y = 0; y &lt; height; y++) { for (var x = 0; x &lt; width; x++) { var pixel = (y*width + x)*4; var dx = x-iCenterX; var dy = y-iCenterY; var distance = dx*dx + dy*dy; var angle = Math.atan2(dy,dx); var d = (angle+Math.PI) / (Math.PI*2) * rays; var i = parseInt(d,10); var f = d - i; if(size !== 0){ var length = filterUtils.linearInterpolate(f, rayLengths[i % rays], rayLengths[(i+1) % rays]); var g = length*length / (distance+0.0001); g = Math.pow(g, (100-amount) / 50); f -= 0.5; f = 1 - f*f; f *= g; } f = filterUtils.clampPixel(f,0,1); var mixedRGB = filterUtils.mixColors(f,[inputData[pixel],inputData[pixel+1],inputData[pixel+2],inputData[pixel+3]],[255,255,255,255]); for(var k = 0; k &lt; 3; k++){ inputData[pixel+k] = mixedRGB[k]; } } } }; } /** * Smears out the image with square shapes to create a painting style effect. * The mix values sets the intensity of the effect. * NOTE: This filter can be very slow, especially at higher densities/sizes. Use with caution. */ function SquareSmearFilter(){ this.name = \"Square Smear\"; this.isDirAnimatable = false; this.defaultValues = { size : 4, density : 0.5, mix : 0.5 }; this.valueRanges = { size : {min:1, max:10}, density : {min:0.0, max:1.0}, mix : {min:0.0, max:1.0} }; var filterUtils = new FilterUtils(); this.filter = function(input,values){ var width = input.width, height = input.height; var inputData = input.data; var outputData = []; var k; for(k = 0; k &lt; inputData.length; k++){ outputData[k] = inputData[k]; } if(values === undefined){ values = this.defaultValues; } var size = (values.size === undefined) ? this.defaultValues.size : values.size; if(size &lt; 1){ size = 1;} size = parseInt(size,10); var density = (values.density === undefined) ? this.defaultValues.density : values.density; var mix = (values.mix === undefined) ? this.defaultValues.mix : values.mix; var radius = size+1; var radius2 = radius*radius; var numShapes = parseInt(2*density/30*width*height / 2,10); for(var i = 0; i &lt; numShapes; i++){ var sx = (Math.random()*Math.pow(2,32) &amp; 0x7fffffff) % width; var sy = (Math.random()*Math.pow(2,32) &amp; 0x7fffffff) % height; var rgb2 = [inputData[(sy*width+sx)*4],inputData[(sy*width+sx)*4+1],inputData[(sy*width+sx)*4+2],inputData[(sy*width+sx)*4+3]]; for(var x = sx - radius; x &lt; sx + radius + 1; x++){ for(var y = sy - radius; y &lt; sy + radius + 1; y++){ if (x &gt;= 0 &amp;&amp; x &lt; width &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; height) { var rgb1 = [outputData[(y*width+x)*4],outputData[(y*width+x)*4+1],outputData[(y*width+x)*4+2],outputData[(y*width+x)*4+3]]; var mixedRGB = filterUtils.mixColors(mix,rgb1,rgb2); for(k = 0; k &lt; 3; k++){ outputData[(y*width+x)*4+k] = mixedRGB[k]; } } } } } for(k = 0; k &lt; outputData.length; k++){ inputData[k] = outputData[k]; } }; } /** * Divides the colors into black and white following the treshold value. Brightnesses above the threshold * sets the color to white while values below the threshold sets the color to black. */ function ThresholdFilter(){ this.name = \"Black &amp; White\"; this.isDirAnimatable = true; this.defaultValues = { threshold : 127 }; this.valueRanges = { threshold : {min:0, max:255} }; this.filter = function(input,values){ var width = input.width, height = input.height; var inputData = input.data; if(values === undefined){ values = this.defaultValues; } var threshold = (values.threshold === undefined) ? this.defaultValues.threshold : values.threshold; for (var y = 0; y &lt; height; y++) { for (var x = 0; x &lt; width; x++) { var pixel = (y*width + x)*4; var brightness = (inputData[pixel] + inputData[pixel+1] + inputData[pixel+2])/3; var colorVal = 0; if(brightness &gt; threshold){ colorVal = 255; } inputData[pixel] = inputData[pixel+1] = inputData[pixel+2] = colorVal; } } }; } /** * Creates ripples on the image horizontally/vertically in a sine pattern. */ function TriangleRippleFilter(){ this.name = \"Triangle Ripples\"; this.isDirAnimatable = false; this.defaultValues = { xAmplitude : 5, yAmplitude : 5, xWavelength : 16, yWavelength : 16 }; this.valueRanges = { xAmplitude : {min:0, max:30}, yAmplitude : {min:0, max:30}, xWavelength : {min:1, max:50}, yWavelength : {min:1, max:50} }; var filterUtils = new FilterUtils(); this.filter = function (input, values){ var width = input.width, height = input.height; var inputData = input.data; if(values === undefined){ values = this.defaultValues; } var xAmplitude = (values.xAmplitude === undefined) ? this.defaultValues.xAmplitude : values.xAmplitude; var yAmplitude = (values.yAmplitude === undefined) ? this.defaultValues.yAmplitude : values.yAmplitude; var xWavelength = (values.xWavelength === undefined) ? this.defaultValues.xWavelength : values.xWavelength; var yWavelength = (values.yWavelength === undefined) ? this.defaultValues.yWavelength : values.yWavelength; var transInverse = function(x,y,out){ var nx = y/xWavelength; var ny = x/yWavelength; var fx = filterUtils.triangle(nx,1); var fy = filterUtils.triangle(ny,1); out[0] = x + xAmplitude * fx; out[1] = y + yAmplitude * fy; }; filterUtils.transformFilter(inputData,transInverse,width,height); }; } /** * Twists the image around a given center point. CenterX and CenterY specify the * position in terms of ratios of width and height. */ function TwirlFilter(){ this.name = \"Twirl\"; this.isDirAnimatable = false; this.defaultValues = { radius : 100, angle : 180, centerX : 0.5, centerY : 0.5 }; this.valueRanges = { radius : {min: 1, max: 200}, angle : {min: 0, max: 360}, centerX : {min: 0.0, max:1.0}, centerY : {min: 0.0, max:1.0} }; var filterUtils = new FilterUtils(); this.filter = function (input, values){ var width = input.width, height = input.height; var inputData = input.data; if(values === undefined){ values = this.defaultValues; } var angle = (values.angle === undefined) ? this.defaultValues.angle : values.angle; var centerX = (values.centerX === undefined) ? this.defaultValues.centerX : values.centerX; var centerY = (values.centerY === undefined) ? this.defaultValues.centerY : values.centerY; var radius = (values.radius === undefined) ? this.defaultValues.radius : values.radius; var radius2 = radius*radius; angle = angle/180 * Math.PI; var iCenterX = width * centerX; var iCenterY = height * centerY; var transInverse = function(x,y,out){ var dx = x-iCenterX; var dy = y-iCenterY; var distance = dx*dx + dy*dy; if(distance &gt; radius2){ out[0] = x; out[1] = y; } else { distance = Math.sqrt(distance); var a = Math.atan2(dy, dx) + angle * (radius-distance) / radius; out[0] = iCenterX + distance*Math.cos(a); out[1] = iCenterY + distance*Math.sin(a); } }; filterUtils.transformFilter(inputData,transInverse,width,height); }; } /** * Creates a classical vignette effect on the image i.e. darkens the corners. */ function VignetteFilter(){ this.name = \"Vignette\"; this.isDirAnimatable = false; this.defaultValues = { amount : 0.3 }; this.valueRanges = { amount : {min:0.0, max:1.0} }; this.filter = function(input,values){ var width = input.width, height = input.height; var inputData = input.data; var outputData = []; if(values === undefined){ values = this.defaultValues; } var amount = (values.amount === undefined) ? this.defaultValues.amount : values.amount; var canvas = document.createElement(\"canvas\"); canvas.width = width; canvas.height = height; var context = canvas.getContext(\"2d\"); var gradient; var radius = Math.sqrt( Math.pow(width/2, 2) + Math.pow(height/2, 2) ); context.putImageData(input,0,0); context.globalCompositeOperation = 'source-over'; gradient = context.createRadialGradient(width/2, height/2, 0, width/2, height/2, radius); gradient.addColorStop(0, 'rgba(0,0,0,0)'); gradient.addColorStop(0.5, 'rgba(0,0,0,0)'); gradient.addColorStop(1, 'rgba(0,0,0,' + amount + ')'); context.fillStyle = gradient; context.fillRect(0, 0, width, height); outputData = context.getImageData(0,0,width,height).data; for(var k = 0; k &lt; outputData.length; k++){ inputData[k] = outputData[k]; } }; } /** * Produces a water ripple/waves on the image. CenterX and CenterY specify the * position in terms of ratios of width and height. */ function WaterRippleFilter(){ this.name = \"Water Ripples\"; this.isDirAnimatable = false; this.defaultValues = { phase : 0, radius : 50, wavelength : 16, amplitude : 10, centerX : 0.5, centerY : 0.5 }; this.valueRanges = { phase : {min: 0, max: 100}, radius : {min: 1, max: 200}, wavelength : {min: 1, max: 100}, amplitude : {min: 1, max: 100}, centerX : {min: 0.0, max:1.0}, centerY : {min: 0.0, max:1.0} }; var filterUtils = new FilterUtils(); this.filter = function (input, values){ var width = input.width, height = input.height; var inputData = input.data; if(values === undefined){ values = this.defaultValues; } var wavelength = (values.wavelength === undefined) ? this.defaultValues.wavelength : values.wavelength; var amplitude = (values.amplitude === undefined) ? this.defaultValues.amplitude : values.amplitude; var phase = (values.phase === undefined) ? this.defaultValues.phase : values.phase; var centerX = (values.centerX === undefined) ? this.defaultValues.centerX : values.centerX; var centerY = (values.centerY === undefined) ? this.defaultValues.centerY : values.centerY; var radius = (values.radius === undefined) ? this.defaultValues.radius : values.radius; var radius2 = radius*radius; var iCenterX = width * centerX; var iCenterY = height * centerY; var transInverse = function(x,y,out){ var dx = x-iCenterX; var dy = y-iCenterY; var distance2 = dx*dx + dy*dy; if(distance2 &gt; radius2){ out[0] = x; out[1] = y; } else { var distance = Math.sqrt(distance2); var amount = amplitude * Math.sin(distance/wavelength * Math.PI * 2 - phase); amount *= (radius-distance)/radius; if(distance !== 0){ amount *= wavelength/distance; } out[0] = x + dx*amount; out[1] = y + dy*amount; } }; filterUtils.transformFilter(inputData,transInverse,width,height); }; } /** * A collection of all the filters. */ var JSManipulate = { blur : new BlurFilter(), brightness : new BrightnessFilter(), bump : new BumpFilter(), circlesmear : new CircleSmearFilter(), contrast : new ContrastFilter(), crosssmear : new CrossSmearFilter(), diffusion : new DiffusionFilter(), dither : new DitherFilter(), edge : new EdgeFilter(), emboss : new EmbossFilter(), exposure : new ExposureFilter(), gain : new GainFilter(), gamma : new GammaFilter(), grayscale : new GrayscaleFilter(), hue : new HueFilter(), invert : new InvertFilter(), kaleidoscope : new KaleidoscopeFilter(), lensdistortion : new LensDistortionFilter(), linesmear : new LineSmearFilter(), maximum : new MaximumFilter(), median : new MedianFilter(), minimum : new MinimumFilter(), noise : new NoiseFilter(), oil : new OilFilter(), opacity : new OpacityFilter(), pinch : new PinchFilter(), pixelate : new PixelationFilter(), posterize : new PosterizeFilter(), rgbadjust : new RGBAdjustFilter(), saturation : new SaturationFilter(), sawtoothripple : new SawtoothRippleFilter(), sepia : new SepiaFilter(), sharpen : new SharpenFilter(), sineripple : new SineRippleFilter(), solarize : new SolarizeFilter(), sparkle : new SparkleFilter(), squaresmear : new SquareSmearFilter(), threshold : new ThresholdFilter(), triangleripple : new TriangleRippleFilter(), twirl : new TwirlFilter(), vignette : new VignetteFilter(), waterripple : new WaterRippleFilter() }; var ImageFilters = JSManipulate; //Attach to Gamestack object Gamestack.ImageFilters = ImageFilters; ;/** * Creates Gamestack.js Canvas: The canvas-renderer for Gamestack games. @description This Canvas library handles the low-level drawing of Gamestack.Animation objects on HTML5Canvas. -Draws Sprites according to their rotation, size, and properties. * @returns {CanvasLib} a CanvasLib object. */ (function() { console.log('CanvasStack class... creating'); class GamestackCanvas { constructor() { this.__levelMaker = false; //draw is synonymous w/ drawSprite this.draw = this.draw_object; } isStopped() { return Gamestack.stopDraw || false; } arc(p1, p2, options = {}) { if (this.isStopped()) return; var ctx = Gamestack.game_windows[0].ctx; ctx.strokeStyle = 'aqua'; ctx.beginPath(); ctx.arc(p1.x, p1.y, p2.x, p2.y, Math.PI * 2, true); ctx.stroke(); } draw_image_frame(image, framePos, frameSize, position, size, rotation, canvasContext, flipX, flipY, origin) { if (this.isStopped()) return; var fx = framePos.x, fy = framePos.y, fw = frameSize.x, fh = frameSize.y, x = position.x, y = position.y, width = size.x, height = size.y; //save canvas state before draw canvasContext.save(); //degrees rotation: var deg = Math.round(rotation); deg = deg % 360; var rad = deg * Math.PI / 180; //Set the origin to the center of the image canvasContext.translate(x, y); canvasContext.rotate(rad); //Rotate the canvas around the origin canvasContext.translate(0, canvasContext.width); if (flipX) { canvasContext.scale(-1, 1); } else { } if (flipY) { canvasContext.scale(1, -1); } else { } origin = origin || new Gamestack.Vector(width / 2, height / 2); //draw the image canvasContext.drawImage(image, fx, fy, fw, fh, origin.x * (-1), origin.y * (-1), width, height); //reset the canvas canvasContext.restore(); } draw_data(x, y, w, h, data, ctx) { if (this.isStopped()) return; ctx.putImageData(data, x, y, 0, 0, w, h); } } Gamestack.Canvas = new GamestackCanvas(); Gamestack.GamestackCanvas = GamestackCanvas; class OffscreenCanvasRendering { constructor(psuedoImage) { I('StashToCanvas():'); this.htmlImage = psuedoImage.domElement || psuedoImage; this.testCanvas = document.createElement(\"CANVAS\"); this.testCtx = this.testCanvas.getContext(\"2d\"); this.testCanvas.width = this.htmlImage.width; this.testCanvas.height = this.htmlImage.height; this.testCanvas.style.zIndex = '9999'; this.testCtx.drawImage(this.htmlImage, 0, 0); return { canvas: this.testCanvas, ctx: this.testCtx } } }; Gamestack.OffscreenCanvasRendering = OffscreenCanvasRendering; })(); ;if (typeof JSON.decycle !== 'function') { JSON.decycle = function decycle(object) { \"use strict\"; var objects = [], // Keep a reference to each unique object or array paths = []; // Keep the path to each unique object or array return (function derez(value, path) { var i, // The loop counter name, // Property name nu; // The new object or array switch (typeof value) { case 'object': if (!value) { return null; } for (i = 0; i &lt; objects.length; i += 1) { if (objects[i] === value) { return {$ref: paths[i]}; } } // Otherwise, accumulate the unique value and its path. objects.push(value); paths.push(path); // If it is an array, replicate the array. if (Object.prototype.toString.apply(value) === '[object Array]') { nu = []; for (i = 0; i &lt; value.length; i += 1) { nu[i] = derez(value[i], path + '[' + i + ']'); } } else { // If it is an object, replicate the object. nu = {}; for (name in value) { if (Object.prototype.hasOwnProperty.call(value, name)) { nu[name] = derez(value[name], path + '[' + JSON.stringify(name) + ']'); } } } return nu; case 'number': case 'string': case 'boolean': return value; } }(object, '$')); }; } if (typeof JSON.retrocycle !== 'function') { JSON.retrocycle = function retrocycle($) { \"use strict\"; var px = /^\\$(?:\\[(?:\\d?|\\\"(?:[^\\\\\\\"\\u0000-\\u001f]|\\\\([\\\\\\\"\\/bfnrt]|u[0-9a-zA-Z]{4}))*\\\")\\])*$/; (function rez(value) { var i, item, name, path; if (value &amp;&amp; typeof value === 'object') { if (Object.prototype.toString.apply(value) === '[object Array]') { for (i = 0; i &lt; value.length; i += 1) { item = value[i]; if (item &amp;&amp; typeof item === 'object') { path = item.$ref; if (typeof path === 'string' &amp;&amp; px.test(path)) { value[i] = eval(path); } else { rez(item); } } } } else { for (name in value) { if (typeof value[name] === 'object') { item = value[name]; if (item) { path = item.$ref; if (typeof path === 'string' &amp;&amp; px.test(path)) { value[name] = eval(path); } else { rez(item); } } } } } } }($)); return $; }; } var json_stringify = JSON.stringify; JSON.stringify = function(object, arg2, arg3) { var clean_object = JSON.decycle(object); return json_stringify(clean_object, arg2, arg3); }; var json_parse = JSON.parse; JSON.parse = function(object, arg2, arg3){ var retro_object = JSON.retrocycle(object); return json_parse(retro_object); }; ;/** * @author mrdoob / http://mrdoob.com/ */ /*************** * * @ignore * * *****************/ var Stats = function () { var mode = 0; var container = document.createElement( 'div' ); container.style.cssText = 'position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000'; container.addEventListener( 'click', function ( event ) { event.preventDefault(); showPanel( ++ mode % container.children.length ); }, false ); // function addPanel( panel ) { container.appendChild( panel.dom ); return panel; } function showPanel( id ) { for ( var i = 0; i &lt; container.children.length; i ++ ) { container.children[ i ].style.display = i === id ? 'block' : 'none'; } mode = id; } // var beginTime = ( performance || Date ).now(), prevTime = beginTime, frames = 0; var fpsPanel = addPanel( new Stats.Panel( 'FPS', '#0ff', '#002' ) ); var msPanel = addPanel( new Stats.Panel( 'MS', '#0f0', '#020' ) ); if ( self.performance &amp;&amp; self.performance.memory ) { var memPanel = addPanel( new Stats.Panel( 'MB', '#f08', '#201' ) ); } showPanel( 0 ); return { REVISION: 16, dom: container, addPanel: addPanel, showPanel: showPanel, begin: function () { beginTime = ( performance || Date ).now(); }, end: function () { frames ++; var time = ( performance || Date ).now(); msPanel.update( time - beginTime, 200 ); if ( time &gt;= prevTime + 1000 ) { fpsPanel.update( ( frames * 1000 ) / ( time - prevTime ), 100 ); prevTime = time; frames = 0; if ( memPanel ) { var memory = performance.memory; memPanel.update( memory.usedJSHeapSize / 1048576, memory.jsHeapSizeLimit / 1048576 ); } } return time; }, update: function () { beginTime = this.end(); }, // Backwards Compatibility domElement: container, setMode: showPanel }; }; Stats.Panel = function ( name, fg, bg ) { var min = Infinity, max = 0, round = Math.round; var PR = round( window.devicePixelRatio || 1 ); var WIDTH = 80 * PR, HEIGHT = 48 * PR, TEXT_X = 3 * PR, TEXT_Y = 2 * PR, GRAPH_X = 3 * PR, GRAPH_Y = 15 * PR, GRAPH_WIDTH = 74 * PR, GRAPH_HEIGHT = 30 * PR; var canvas = document.createElement( 'canvas' ); canvas.width = WIDTH; canvas.height = HEIGHT; canvas.style.cssText = 'width:80px;height:48px'; var context = canvas.getContext( '2d' ); context.font = 'bold ' + ( 9 * PR ) + 'px Helvetica,Arial,sans-serif'; context.textBaseline = 'top'; context.fillStyle = bg; context.fillRect( 0, 0, WIDTH, HEIGHT ); context.fillStyle = fg; context.fillText( name, TEXT_X, TEXT_Y ); context.fillRect( GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT ); context.fillStyle = bg; context.globalAlpha = 0.9; context.fillRect( GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT ); return { dom: canvas, update: function ( value, maxValue ) { min = Math.min( min, value ); max = Math.max( max, value ); context.fillStyle = bg; context.globalAlpha = 1; context.fillRect( 0, 0, WIDTH, GRAPH_Y ); context.fillStyle = fg; context.fillText( round( value ) + ' ' + name + ' (' + round( min ) + '-' + round( max ) + ')', TEXT_X, TEXT_Y ); context.drawImage( canvas, GRAPH_X + PR, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT, GRAPH_X, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT ); context.fillRect( GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, GRAPH_HEIGHT ); context.fillStyle = bg; context.globalAlpha = 0.9; context.fillRect( GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, round( ( 1 - ( value / maxValue ) ) * GRAPH_HEIGHT ) ); } }; }; ;/** * Tween.js - Licensed under the MIT license * https://github.com/tweenjs/tween.js * ---------------------------------------------- * * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors. * Thank you all, you're awesome! */ /* * * @ignore * * */ var TWEEN = TWEEN || (function () { var _tweens = []; return { getAll: function () { return _tweens; }, removeAll: function () { _tweens = []; }, add: function (tween) { _tweens.push(tween); }, remove: function (tween) { var i = _tweens.indexOf(tween); if (i !== -1) { _tweens.splice(i, 1); } }, update: function (time, preserve) { if (_tweens.length === 0) { return false; } var i = 0; time = time !== undefined ? time : TWEEN.now(); while (i &lt; _tweens.length) { if (_tweens[i].update(time) || preserve) { i++; } else { _tweens.splice(i, 1); } } return true; } }; })(); //removed polyfill TWEEN.now = Date.now; TWEEN.Tween = function (object) { var _object = object; var _valuesStart = {}; var _valuesEnd = {}; var _valuesStartRepeat = {}; var _duration = 1000; var _repeat = 0; var _repeatDelayTime; var _yoyo = false; var _isPlaying = false; var _reversed = false; var _delayTime = 0; var _startTime = null; var _easingFunction = TWEEN.Easing.Linear.None; var _interpolationFunction = TWEEN.Interpolation.Linear; var _chainedTweens = []; var _onStartCallback = null; var _onStartCallbackFired = false; var _onUpdateCallback = null; var _onCompleteCallback = null; var _onStopCallback = null; // Set all starting values present on the target object for (var field in object) { _valuesStart[field] = parseFloat(object[field], 10); } this.to = function (properties, duration) { if (duration !== undefined) { _duration = duration; } _valuesEnd = properties; return this; }; this.start = function (time) { TWEEN.add(this); _isPlaying = true; _onStartCallbackFired = false; _startTime = time !== undefined ? time : TWEEN.now(); _startTime += _delayTime; for (var property in _valuesEnd) { // Check if an Array was provided as property value if (_valuesEnd[property] instanceof Array) { if (_valuesEnd[property].length === 0) { continue; } // Create a local copy of the Array with the start value at the front _valuesEnd[property] = [_object[property]].concat(_valuesEnd[property]); } // If `to()` specifies a property that doesn't exist in the source object, // we should not set that property in the object if (_object[property] === undefined) { continue; } _valuesStart[property] = _object[property]; if ((_valuesStart[property] instanceof Array) === false) { _valuesStart[property] *= 1.0; // Ensures we're using numbers, not strings } _valuesStartRepeat[property] = _valuesStart[property] || 0; } return this; }; this.stop = function () { if (!_isPlaying) { return this; } TWEEN.remove(this); _isPlaying = false; if (_onStopCallback !== null) { _onStopCallback.call(_object, _object); } this.stopChainedTweens(); return this; }; this.end = function () { this.update(_startTime + _duration); return this; }; this.stopChainedTweens = function () { for (var i = 0, numChainedTweens = _chainedTweens.length; i &lt; numChainedTweens; i++) { _chainedTweens[i].stop(); } }; this.delay = function (amount) { _delayTime = amount; return this; }; this.repeat = function (times) { _repeat = times; return this; }; this.repeatDelay = function (amount) { _repeatDelayTime = amount; return this; }; this.yoyo = function (yoyo) { _yoyo = yoyo; return this; }; this.easing = function (easing) { _easingFunction = easing; return this; }; this.interpolation = function (interpolation) { _interpolationFunction = interpolation; return this; }; this.chain = function () { _chainedTweens = arguments; return this; }; this.onStart = function (callback) { _onStartCallback = callback; return this; }; this.onUpdate = function (callback) { _onUpdateCallback = callback; return this; }; this.onComplete = function (callback) { _onCompleteCallback = callback; return this; }; this.onStop = function (callback) { _onStopCallback = callback; return this; }; this.update = function (time) { var property; var elapsed; var value; if (time &lt; _startTime) { return true; } if (_onStartCallbackFired === false) { if (_onStartCallback !== null) { _onStartCallback.call(_object, _object); } _onStartCallbackFired = true; } elapsed = (time - _startTime) / _duration; elapsed = elapsed &gt; 1 ? 1 : elapsed; value = _easingFunction(elapsed); for (property in _valuesEnd) { // Don't update properties that do not exist in the source object if (_valuesStart[property] === undefined) { continue; } var start = _valuesStart[property] || 0; var end = _valuesEnd[property]; if (end instanceof Array) { _object[property] = _interpolationFunction(end, value); } else { // Parses relative end values with start as base (e.g.: +10, -3) if (typeof (end) === 'string') { if (end.charAt(0) === '+' || end.charAt(0) === '-') { end = start + parseFloat(end, 10); } else { end = parseFloat(end, 10); } } // Protect against non numeric properties. if (typeof (end) === 'number') { _object[property] = start + (end - start) * value; } } } if (_onUpdateCallback !== null) { _onUpdateCallback.call(_object, value); } if (elapsed === 1) { if (_repeat &gt; 0) { if (isFinite(_repeat)) { _repeat--; } // Reassign starting values, restart by making startTime = now for (property in _valuesStartRepeat) { if (typeof (_valuesEnd[property]) === 'string') { _valuesStartRepeat[property] = _valuesStartRepeat[property] + parseFloat(_valuesEnd[property], 10); } if (_yoyo) { var tmp = _valuesStartRepeat[property]; _valuesStartRepeat[property] = _valuesEnd[property]; _valuesEnd[property] = tmp; } _valuesStart[property] = _valuesStartRepeat[property]; } if (_yoyo) { _reversed = !_reversed; } if (_repeatDelayTime !== undefined) { _startTime = time + _repeatDelayTime; } else { _startTime = time + _delayTime; } return true; } else { if (_onCompleteCallback !== null) { _onCompleteCallback.call(_object, _object); } for (var i = 0, numChainedTweens = _chainedTweens.length; i &lt; numChainedTweens; i++) { // Make the chained tweens start exactly at the time they should, // even if the `update()` method was called way past the duration of the tween _chainedTweens[i].start(_startTime + _duration); } return false; } } return true; }; }; TWEEN.Easing = { Linear: { None: function (k) { return k; } }, Quadratic: { In: function (k) { return k * k; }, Out: function (k) { return k * (2 - k); }, InOut: function (k) { if ((k *= 2) &lt; 1) { return 0.5 * k * k; } return - 0.5 * (--k * (k - 2) - 1); } }, Cubic: { In: function (k) { return k * k * k; }, Out: function (k) { return --k * k * k + 1; }, InOut: function (k) { if ((k *= 2) &lt; 1) { return 0.5 * k * k * k; } return 0.5 * ((k -= 2) * k * k + 2); } }, Quartic: { In: function (k) { return k * k * k * k; }, Out: function (k) { return 1 - (--k * k * k * k); }, InOut: function (k) { if ((k *= 2) &lt; 1) { return 0.5 * k * k * k * k; } return - 0.5 * ((k -= 2) * k * k * k - 2); } }, Quintic: { In: function (k) { return k * k * k * k * k; }, Out: function (k) { return --k * k * k * k * k + 1; }, InOut: function (k) { if ((k *= 2) &lt; 1) { return 0.5 * k * k * k * k * k; } return 0.5 * ((k -= 2) * k * k * k * k + 2); } }, Sinusoidal: { In: function (k) { return 1 - Math.cos(k * Math.PI / 2); }, Out: function (k) { return Math.sin(k * Math.PI / 2); }, InOut: function (k) { return 0.5 * (1 - Math.cos(Math.PI * k)); } }, Exponential: { In: function (k) { return k === 0 ? 0 : Math.pow(1024, k - 1); }, Out: function (k) { return k === 1 ? 1 : 1 - Math.pow(2, - 10 * k); }, InOut: function (k) { if (k === 0) { return 0; } if (k === 1) { return 1; } if ((k *= 2) &lt; 1) { return 0.5 * Math.pow(1024, k - 1); } return 0.5 * (- Math.pow(2, - 10 * (k - 1)) + 2); } }, Circular: { In: function (k) { return 1 - Math.sqrt(1 - k * k); }, Out: function (k) { return Math.sqrt(1 - (--k * k)); }, InOut: function (k) { if ((k *= 2) &lt; 1) { return - 0.5 * (Math.sqrt(1 - k * k) - 1); } return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1); } }, Elastic: { In: function (k) { if (k === 0) { return 0; } if (k === 1) { return 1; } return -Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI); }, Out: function (k) { if (k === 0) { return 0; } if (k === 1) { return 1; } return Math.pow(2, -10 * k) * Math.sin((k - 0.1) * 5 * Math.PI) + 1; }, InOut: function (k) { if (k === 0) { return 0; } if (k === 1) { return 1; } k *= 2; if (k &lt; 1) { return -0.5 * Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI); } return 0.5 * Math.pow(2, -10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI) + 1; } }, Back: { In: function (k) { var s = 1.70158; return k * k * ((s + 1) * k - s); }, Out: function (k) { var s = 1.70158; return --k * k * ((s + 1) * k + s) + 1; }, InOut: function (k) { var s = 1.70158 * 1.525; if ((k *= 2) &lt; 1) { return 0.5 * (k * k * ((s + 1) * k - s)); } return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2); } }, Bounce: { In: function (k) { return 1 - TWEEN.Easing.Bounce.Out(1 - k); }, Out: function (k) { if (k &lt; (1 / 2.75)) { return 7.5625 * k * k; } else if (k &lt; (2 / 2.75)) { return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75; } else if (k &lt; (2.5 / 2.75)) { return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375; } else { return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375; } }, InOut: function (k) { if (k &lt; 0.5) { return TWEEN.Easing.Bounce.In(k * 2) * 0.5; } return TWEEN.Easing.Bounce.Out(k * 2 - 1) * 0.5 + 0.5; } } }; TWEEN.Interpolation = { Linear: function (v, k) { var m = v.length - 1; var f = m * k; var i = Math.floor(f); var fn = TWEEN.Interpolation.Utils.Linear; if (k &lt; 0) { return fn(v[0], v[1], f); } if (k &gt; 1) { return fn(v[m], v[m - 1], m - f); } return fn(v[i], v[i + 1 &gt; m ? m : i + 1], f - i); }, Bezier: function (v, k) { var b = 0; var n = v.length - 1; var pw = Math.pow; var bn = TWEEN.Interpolation.Utils.Bernstein; for (var i = 0; i &lt;= n; i++) { b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i); } return b; }, CatmullRom: function (v, k) { var m = v.length - 1; var f = m * k; var i = Math.floor(f); var fn = TWEEN.Interpolation.Utils.CatmullRom; if (v[0] === v[m]) { if (k &lt; 0) { i = Math.floor(f = m * (1 + k)); } return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i); } else { if (k &lt; 0) { return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]); } if (k &gt; 1) { return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]); } return fn(v[i ? i - 1 : 0], v[i], v[m &lt; i + 1 ? m : i + 1], v[m &lt; i + 2 ? m : i + 2], f - i); } }, Utils: { Linear: function (p0, p1, t) { return (p1 - p0) * t + p0; }, Bernstein: function (n, i) { var fc = TWEEN.Interpolation.Utils.Factorial; return fc(n) / fc(i) / fc(n - i); }, Factorial: (function () { var a = [1]; return function (n) { var s = 1; if (a[n]) { return a[n]; } for (var i = n; i &gt; 1; i--) { s *= i; } a[n] = s; return s; }; })(), CatmullRom: function (p0, p1, p2, p3, t) { var v0 = (p2 - p0) * 0.5; var v1 = (p3 - p1) * 0.5; var t2 = t * t; var t3 = t * t2; return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (- 3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1; } } }; //Attach to the global Gamestack object /*************** * * @memberOf Gamestack * * *****************/ Gamestack.TWEEN = TWEEN; /* // UMD (Universal Module Definition) (function (root) { if (typeof define === 'function' &amp;&amp; define.amd) { // AMD define([], function () { return TWEEN; }); } else if (typeof module !== 'undefined' &amp;&amp; typeof exports === 'object') { // Node.js module.exports = TWEEN; } else if (root !== undefined) { // Global variable root.TWEEN = TWEEN; } })(this); */ ; //Call Gamestack.FeatureInject:: Gamestack.FeatureInject(); // UMD (Universal Module Definition) (function (root) { if (typeof define === 'function' &amp;&amp; define.amd) { // AMD define([], function () { return Gamestack; }); } else if (typeof module !== 'undefined' &amp;&amp; typeof exports === 'object') { // Node.js module.exports = Gamestack; } else if (root !== undefined) { // Global variable root.Gamestack = Gamestack; } })(this);  Search results Close Documentation generated by JSDoc 3.5.5 "},"global.html":{"id":"global.html","title":"Global","body":" Global - Documentation GamestackJs Documentation Examplesspace-gameClassesGameWindowgetCanvascenterGridStyleonUpdateupdateonBeforeDrawonAfterDrawSizeaddBackgroundremoveanimatestartWebGL#getCanvasWebGL#centerWebGL#GridStyleWebGL#onUpdateWebGL#updateWebGL#onBeforeDrawWebGL#onAfterDrawWebGL#SizeWebGL#addWebGL#BackgroundWebGL#removeWebGL#animateWebGL#startCameraSpriteonLoadCloneAddLifeinitaddInitializerget_idcreate_idgetSizeByMaxSingleFrameLifeSpanLifeisDeaddieonScreenupdatedef_updateonUpdatetravelLineOnLoophasPixelCollisionhasBoxCollisionshootsubspriteanimateonAnimationCompleteaccelYaccelXdecelYdecelXacceldecelSmoothMotionSmoothRotatecenteroverlap_xoverlap_ycollide_stop_xcollide_stopcollide_stop_toprestoreFromSpriteArray#onLoadSpritesAnimationFrame#createColorMapinit_singleFrameonRunonCompleteReverseFramesSingleFramegetCurrentPixelMapsetFramerunanimateengageFrameSoundGamepadEventInputEventRenderableRectangleShotProjectileonCompleteKeyboardEventVectorFrameBoundsGameImageVectorsubaddmultabsdivroundfloorceilnegequalstrig_distance_xyrandomizerotationalSpeedPointangleBetweenWebGLBoolEventOnCall Global Members JSManipulate A collection of all the filters. Source: gamestack.js, line 12782 Methods FilterUtils() Contains common filter functions. Source: gamestack.js, line 10534 BlurFilter() Blurs the image with Gaussian blur. Source: gamestack.js, line 10749 BrightnessFilter() Adjusts the brightness of the image by going over to HSV values. Negative values decrease brightness while positive values increase brightness. Source: gamestack.js, line 10855 BumpFilter() Embosses the edges of the image. This filter takes no parameters but can be applied several times for further effect. Source: gamestack.js, line 10893 CircleSmearFilter() Smears out the image with circular shapes to create a painting style effect. The mix values sets the intensity of the effect. NOTE: This filter can be very slow, especially at higher densities/sizes. Use with caution. Source: gamestack.js, line 10915 ContrastFilter() Adjusts the contrast of the image. Source: gamestack.js, line 10971 CrossSmearFilter() Smears out the image with cross shapes to create a painting style effect. The mix values sets the intensity of the effect. Source: gamestack.js, line 11007 DiffusionFilter() Diffuses the image creating a frosted glass effect. Source: gamestack.js, line 11073 DitherFilter() Dithers the image to the specified number of colors. Setting color to false grayscales the image. Source: gamestack.js, line 11111 EdgeFilter() Highlights the edges of the image. Source: gamestack.js, line 11207 EmbossFilter() Embosses the image with a simulated light source. Angle and elevation sets the position of the light. Source: gamestack.js, line 11276 ExposureFilter() Adjust simulated exposure values on the image. Source: gamestack.js, line 11348 GainFilter() Adjusts the gain and bias of the image. Gain alters the contrast while bias biases colors towards lighter or darker. Source: gamestack.js, line 11375 GammaFilter() Adjusts the gamma values of the image. Values over 1 increase the gamma while values over 0 decrease gamma. Source: gamestack.js, line 11411 GrayscaleFilter() Sets the image to grayscale. Source: gamestack.js, line 11445 HueFilter() Adjusts the hue of the image by going over to HSV values. Source: gamestack.js, line 11467 InvertFilter() Inverts the colors of the image. Source: gamestack.js, line 11502 KaleidoscopeFilter() Creates a kaleidoscope effect on the image. CenterX and CenterY specify the position in terms of ratios of width and height. Source: gamestack.js, line 11526 LensDistortionFilter() Applies a fisheye lens distortion effect on the image. CenterX and CenterY specify the position in terms of ratios of width and height. Source: gamestack.js, line 11574 LineSmearFilter() Smears out the image with line shapes to create a painting style effect. Mix specifies the intensity of the effect. Source: gamestack.js, line 11636 MaximumFilter() Replaces every pixel with the maximum RGB value of the neighboring pixels. Each color is considered separately. Source: gamestack.js, line 11764 MedianFilter() Replaces every pixel with the median RGB value of the neighboring pixels. Each color is considered separately. Source: gamestack.js, line 11810 MinimumFilter() Replaces every pixel with the minimum RGB value of the neighboring pixels. Each color is considered separately. Source: gamestack.js, line 11863 NoiseFilter() Creates random noise on the image, with or without color. Source: gamestack.js, line 11908 OilFilter() Produces an oil painting effect on the image. NOTE: This filter can be very slow, especially at higher ranges. Use with caution. Source: gamestack.js, line 11953 OpacityFilter() Changes the opacity of the image. Source: gamestack.js, line 12036 PinchFilter() Pinches and whirls the image toward the center point. CenterX and CenterY specify the position in terms of ratios of width and height. Source: gamestack.js, line 12062 PixelationFilter() Pixelates the image i.e. divides the image into blocks of color. Source: gamestack.js, line 12120 PosterizeFilter() Posterizes the image, i.e. restricts the color values to a set amount of levels. Source: gamestack.js, line 12167 RGBAdjustFilter() Adjust the factor of each RGB color value in the image. Source: gamestack.js, line 12196 SaturationFilter() Adjusts the saturation value of the image. Values over 1 increase saturation while values below decrease saturation. For a true grayscale effect, use the grayscale filter instead. Source: gamestack.js, line 12233 SawtoothRippleFilter() Creates ripples on the image horizontally/vertically in a sawtooth pattern. Source: gamestack.js, line 12275 SepiaFilter() Creates a sepia effect on the image i.e. gives the image a yellow-brownish tone. Source: gamestack.js, line 12315 SharpenFilter() Sharpens the image slightly. For increased effect, apply the filter multiple times. Source: gamestack.js, line 12352 SineRippleFilter() Creates ripples on the image horizontally/vertically in a sine pattern. Source: gamestack.js, line 12373 SolarizeFilter() Produces a solarization effect on the image. Source: gamestack.js, line 12413 SparkleFilter() Generates a sparkle/sunburst effect on the image. CenterX and CenterY specify the position in terms of ratios of width and height. Source: gamestack.js, line 12437 SquareSmearFilter() Smears out the image with square shapes to create a painting style effect. The mix values sets the intensity of the effect. NOTE: This filter can be very slow, especially at higher densities/sizes. Use with caution. Source: gamestack.js, line 12507 ThresholdFilter() Divides the colors into black and white following the treshold value. Brightnesses above the threshold sets the color to white while values below the threshold sets the color to black. Source: gamestack.js, line 12565 TriangleRippleFilter() Creates ripples on the image horizontally/vertically in a sine pattern. Source: gamestack.js, line 12595 TwirlFilter() Twists the image around a given center point. CenterX and CenterY specify the position in terms of ratios of width and height. Source: gamestack.js, line 12636 VignetteFilter() Creates a classical vignette effect on the image i.e. darkens the corners. Source: gamestack.js, line 12685 WaterRippleFilter() Produces a water ripple/waves on the image. CenterX and CenterY specify the position in terms of ratios of width and height. Source: gamestack.js, line 12725  Search results Close Documentation generated by JSDoc 3.5.5 "},"index.html":{"id":"index.html","title":"Home","body":" Home - Documentation GamestackJs Documentation Examplesspace-gameClassesGameWindowgetCanvascenterGridStyleonUpdateupdateonBeforeDrawonAfterDrawSizeaddBackgroundremoveanimatestartWebGL#getCanvasWebGL#centerWebGL#GridStyleWebGL#onUpdateWebGL#updateWebGL#onBeforeDrawWebGL#onAfterDrawWebGL#SizeWebGL#addWebGL#BackgroundWebGL#removeWebGL#animateWebGL#startCameraSpriteonLoadCloneAddLifeinitaddInitializerget_idcreate_idgetSizeByMaxSingleFrameLifeSpanLifeisDeaddieonScreenupdatedef_updateonUpdatetravelLineOnLoophasPixelCollisionhasBoxCollisionshootsubspriteanimateonAnimationCompleteaccelYaccelXdecelYdecelXacceldecelSmoothMotionSmoothRotatecenteroverlap_xoverlap_ycollide_stop_xcollide_stopcollide_stop_toprestoreFromSpriteArray#onLoadSpritesAnimationFrame#createColorMapinit_singleFrameonRunonCompleteReverseFramesSingleFramegetCurrentPixelMapsetFramerunanimateengageFrameSoundGamepadEventInputEventRenderableRectangleShotProjectileonCompleteKeyboardEventVectorFrameBoundsGameImageVectorsubaddmultabsdivroundfloorceilnegequalstrig_distance_xyrandomizerotationalSpeedPointangleBetweenWebGLBoolEventOnCall Gamestack.js is a javascript library for 2D games. Features: js game-objects animations, sounds, gamepad-input events + behaviors framerate + memory tracking html + javascript examples + documentation Examples: Gamestack.js main-page, examples and documentationLicensing: Gamestack.js main-page, examples and documentationGamestack.js currently open-source under the MIT License.  Search results Close Documentation generated by JSDoc 3.5.5 "},"Camera.html":{"id":"Camera.html","title":"Camera","body":" Camera - Documentation GamestackJs Documentation Examplesspace-gameClassesGameWindowgetCanvascenterGridStyleonUpdateupdateonBeforeDrawonAfterDrawSizeaddBackgroundremoveanimatestartWebGL#getCanvasWebGL#centerWebGL#GridStyleWebGL#onUpdateWebGL#updateWebGL#onBeforeDrawWebGL#onAfterDrawWebGL#SizeWebGL#addWebGL#BackgroundWebGL#removeWebGL#animateWebGL#startCameraSpriteonLoadCloneAddLifeinitaddInitializerget_idcreate_idgetSizeByMaxSingleFrameLifeSpanLifeisDeaddieonScreenupdatedef_updateonUpdatetravelLineOnLoophasPixelCollisionhasBoxCollisionshootsubspriteanimateonAnimationCompleteaccelYaccelXdecelYdecelXacceldecelSmoothMotionSmoothRotatecenteroverlap_xoverlap_ycollide_stop_xcollide_stopcollide_stop_toprestoreFromSpriteArray#onLoadSpritesAnimationFrame#createColorMapinit_singleFrameonRunonCompleteReverseFramesSingleFramegetCurrentPixelMapsetFramerunanimateengageFrameSoundGamepadEventInputEventRenderableRectangleShotProjectileonCompleteKeyboardEventVectorFrameBoundsGameImageVectorsubaddmultabsdivroundfloorceilnegequalstrig_distance_xyrandomizerotationalSpeedPointangleBetweenWebGLBoolEventOnCall Camera Camera Creates a new Camera Constructor new Camera(x, y, z)  {Camera} Parameters: Name Type Default Description x number 0 position-x y number 0 position-y z number 0 position-z Source: gamestack.js, line 1899 Members (static) this.position Properties: Name Type Description position Vector the Vector position of Camera, having numeric x, y, and z values Source: gamestack.js, line 1920  Search results Close Documentation generated by JSDoc 3.5.5 "},"GameWindow.html":{"id":"GameWindow.html","title":"GameWindow","body":" GameWindow - Documentation GamestackJs Documentation Examplesspace-gameClassesGameWindowgetCanvascenterGridStyleonUpdateupdateonBeforeDrawonAfterDrawSizeaddBackgroundremoveanimatestartWebGL#getCanvasWebGL#centerWebGL#GridStyleWebGL#onUpdateWebGL#updateWebGL#onBeforeDrawWebGL#onAfterDrawWebGL#SizeWebGL#addWebGL#BackgroundWebGL#removeWebGL#animateWebGL#startCameraSpriteonLoadCloneAddLifeinitaddInitializerget_idcreate_idgetSizeByMaxSingleFrameLifeSpanLifeisDeaddieonScreenupdatedef_updateonUpdatetravelLineOnLoophasPixelCollisionhasBoxCollisionshootsubspriteanimateonAnimationCompleteaccelYaccelXdecelYdecelXacceldecelSmoothMotionSmoothRotatecenteroverlap_xoverlap_ycollide_stop_xcollide_stopcollide_stop_toprestoreFromSpriteArray#onLoadSpritesAnimationFrame#createColorMapinit_singleFrameonRunonCompleteReverseFramesSingleFramegetCurrentPixelMapsetFramerunanimateengageFrameSoundGamepadEventInputEventRenderableRectangleShotProjectileonCompleteKeyboardEventVectorFrameBoundsGameImageVectorsubaddmultabsdivroundfloorceilnegequalstrig_distance_xyrandomizerotationalSpeedPointangleBetweenWebGLBoolEventOnCall GameWindow GameWindow Creates a new GameWindow Constructor new GameWindow(canvas, drawables)  {GameWindow} Parameters: Name Type Default Description canvas Object the canvas element for this gameWindow. --GameWindow's if not supplied, the constructor will create a full-screen canvas, if a canvas. drawables Array [ a list of drawable objects to be drawn. --Drawables can also be added after constructor call. Source: gamestack.js, line 2004 Members (static) this.drawables list of all drawables in the window. Properties: Name Type Description this.drawables Source: gamestack.js, line 2015 (static) this.canvas the html-canvas of the GameWindow. Properties: Name Type Description this.canvas Source: gamestack.js, line 2027 (static) this.camera the camera of the GameWindow. --An instance of Gamestack.Camera Properties: Name Type Description this.camera Source: gamestack.js, line 2052 Methods getCanvas() returns the gameWindow.canvas property, an HTMLCanvasElement Source: gamestack.js, line 2112 center() returns a vector(x, y) showing the center of the GameWindow Source: gamestack.js, line 2125 GridStyle() creates an array of gridUnits Source: gamestack.js, line 2169 onUpdate() adds an update to the GameWindow:: update to be called every 20 milliseconds Source: gamestack.js, line 2227 update() the main update for the GameWindow:: called automatically after call of GameWindow.start() or GameWindow.animate() Source: gamestack.js, line 2240 onBeforeDraw() adds a call before the GameWindow draw() Source: gamestack.js, line 2315 onAfterDraw() adds a call after the GameWindow draw() Source: gamestack.js, line 2339 Size(w, h) sets the size of the GameWindow Parameters: Name Type Description w integer the width of the GameWindow h integer the HEIGHT of the GameWindow Source: gamestack.js, line 2365 add(obj, onBottom) adds an object to the GameWindow Parameters: Name Type Description obj Object the object to be added (Sprite) onBottom Boolean if true, adds to the bottom of layer-stack in GameWindow Source: gamestack.js, line 2406 Background(c) set background-color of GameWindow Parameters: Name Type Description c string the new background-color for GameWindow Source: gamestack.js, line 2465 remove(obj) removes an object from the GameWindow Parameters: Name Type Description obj Object the object to be removed (Sprite) Source: gamestack.js, line 2482 animate(time) begins the animation-loop of GameWindow. Parameters: Name Type Description time number optional time parameter for usage with Tween Source: gamestack.js, line 2516 start() begins the animation-loop of GameWindow, with performance Stats shown on-screen Source: gamestack.js, line 2559 (static) WebGL#getCanvas() returns the gameWindow.canvas property, an HTMLCanvasElement Source: gamestack.js, line 3549 (static) WebGL#center() returns a vector(x, y) showing the center of the GameWindow Source: gamestack.js, line 3562 (static) WebGL#GridStyle() creates an array of gridUnits Source: gamestack.js, line 3576 (static) WebGL#onUpdate() adds an update to the GameWindow:: update to be called every 20 milliseconds Source: gamestack.js, line 3634 (static) WebGL#update() the main update for the GameWindow:: called automatically after call of GameWindow.start() or GameWindow.animate() Source: gamestack.js, line 3647 (static) WebGL#onBeforeDraw() adds a call before the GameWindow draw() Source: gamestack.js, line 3722 (static) WebGL#onAfterDraw() adds a call after the GameWindow draw() Source: gamestack.js, line 3746 (static) WebGL#Size(w, h) sets the size of the GameWindow Parameters: Name Type Description w integer the width of the GameWindow h integer the HEIGHT of the GameWindow Source: gamestack.js, line 3772 (static) WebGL#add(obj, onBottom) adds an object to the GameWindow Parameters: Name Type Description obj Object the object to be added (Sprite) onBottom Boolean if true, adds to the bottom of layer-stack in GameWindow Source: gamestack.js, line 3813 (static) WebGL#Background(c) set background-color of GameWindow Parameters: Name Type Description c string the new background-color for GameWindow Source: gamestack.js, line 3872 (static) WebGL#remove(obj) removes an object from the GameWindow Parameters: Name Type Description obj Object the object to be removed (Sprite) Source: gamestack.js, line 3889 (static) WebGL#animate(time) begins the animation-loop of GameWindow. Parameters: Name Type Description time number optional time parameter for usage with Tween Source: gamestack.js, line 3907 (static) WebGL#start() begins the animation-loop of GameWindow, with performance Stats shown on-screen Source: gamestack.js, line 3951  Search results Close Documentation generated by JSDoc 3.5.5 "},"Rectangle.html":{"id":"Rectangle.html","title":"Rectangle","body":" Rectangle - Documentation GamestackJs Documentation Examplesspace-gameClassesGameWindowgetCanvascenterGridStyleonUpdateupdateonBeforeDrawonAfterDrawSizeaddBackgroundremoveanimatestartWebGL#getCanvasWebGL#centerWebGL#GridStyleWebGL#onUpdateWebGL#updateWebGL#onBeforeDrawWebGL#onAfterDrawWebGL#SizeWebGL#addWebGL#BackgroundWebGL#removeWebGL#animateWebGL#startCameraSpriteonLoadCloneAddLifeinitaddInitializerget_idcreate_idgetSizeByMaxSingleFrameLifeSpanLifeisDeaddieonScreenupdatedef_updateonUpdatetravelLineOnLoophasPixelCollisionhasBoxCollisionshootsubspriteanimateonAnimationCompleteaccelYaccelXdecelYdecelXacceldecelSmoothMotionSmoothRotatecenteroverlap_xoverlap_ycollide_stop_xcollide_stopcollide_stop_toprestoreFromSpriteArray#onLoadSpritesAnimationFrame#createColorMapinit_singleFrameonRunonCompleteReverseFramesSingleFramegetCurrentPixelMapsetFramerunanimateengageFrameSoundGamepadEventInputEventRenderableRectangleShotProjectileonCompleteKeyboardEventVectorFrameBoundsGameImageVectorsubaddmultabsdivroundfloorceilnegequalstrig_distance_xyrandomizerotationalSpeedPointangleBetweenWebGLBoolEventOnCall Rectangle Rectangle Creates an instance of Rectangle. Constructor new Rectangle(min, max)  {Rectangle} Parameters: Name Type Description min Gamestack.Vector the minimum vector point (x,y) max Gamestack.Vector the maximum vector point (x,y) Source: gamestack.js, line 2658  Search results Close Documentation generated by JSDoc 3.5.5 "},"VectorFrameBounds.html":{"id":"VectorFrameBounds.html","title":"VectorFrameBounds","body":" VectorFrameBounds - Documentation GamestackJs Documentation Examplesspace-gameClassesGameWindowgetCanvascenterGridStyleonUpdateupdateonBeforeDrawonAfterDrawSizeaddBackgroundremoveanimatestartWebGL#getCanvasWebGL#centerWebGL#GridStyleWebGL#onUpdateWebGL#updateWebGL#onBeforeDrawWebGL#onAfterDrawWebGL#SizeWebGL#addWebGL#BackgroundWebGL#removeWebGL#animateWebGL#startCameraSpriteonLoadCloneAddLifeinitaddInitializerget_idcreate_idgetSizeByMaxSingleFrameLifeSpanLifeisDeaddieonScreenupdatedef_updateonUpdatetravelLineOnLoophasPixelCollisionhasBoxCollisionshootsubspriteanimateonAnimationCompleteaccelYaccelXdecelYdecelXacceldecelSmoothMotionSmoothRotatecenteroverlap_xoverlap_ycollide_stop_xcollide_stopcollide_stop_toprestoreFromSpriteArray#onLoadSpritesAnimationFrame#createColorMapinit_singleFrameonRunonCompleteReverseFramesSingleFramegetCurrentPixelMapsetFramerunanimateengageFrameSoundGamepadEventInputEventRenderableRectangleShotProjectileonCompleteKeyboardEventVectorFrameBoundsGameImageVectorsubaddmultabsdivroundfloorceilnegequalstrig_distance_xyrandomizerotationalSpeedPointangleBetweenWebGLBoolEventOnCall VectorFrameBounds VectorFrameBounds Takes the min and max vectors plus termPoint ('termination-point'), returns VectorFrameBounds *use this to define the bounds of an Animation object. Constructor new VectorFrameBounds(min, max, termPointopt)  {VectorFrameBounds} Parameters: Name Type Attributes Description min Vector the minimum vector point (x,y) max Vector the maximum vector point (x,y) termPoint Vector &lt;optional&gt; the optional termination vector point (x,y) : defaults to the value of 'max' -While a min and max Gamestack.Vector(x,y) will describe the grid-size of Animation frames, the termPoint will indicate the last frame on-grid for this set of frames --Animation may stop early on the 'grid') Source: gamestack.js, line 2693  Search results Close Documentation generated by JSDoc 3.5.5 "},"Renderable.html":{"id":"Renderable.html","title":"Renderable","body":" Renderable - Documentation GamestackJs Documentation Examplesspace-gameClassesGameWindowgetCanvascenterGridStyleonUpdateupdateonBeforeDrawonAfterDrawSizeaddBackgroundremoveanimatestartWebGL#getCanvasWebGL#centerWebGL#GridStyleWebGL#onUpdateWebGL#updateWebGL#onBeforeDrawWebGL#onAfterDrawWebGL#SizeWebGL#addWebGL#BackgroundWebGL#removeWebGL#animateWebGL#startCameraSpriteonLoadCloneAddLifeinitaddInitializerget_idcreate_idgetSizeByMaxSingleFrameLifeSpanLifeisDeaddieonScreenupdatedef_updateonUpdatetravelLineOnLoophasPixelCollisionhasBoxCollisionshootsubspriteanimateonAnimationCompleteaccelYaccelXdecelYdecelXacceldecelSmoothMotionSmoothRotatecenteroverlap_xoverlap_ycollide_stop_xcollide_stopcollide_stop_toprestoreFromSpriteArray#onLoadSpritesAnimationFrame#createColorMapinit_singleFrameonRunonCompleteReverseFramesSingleFramegetCurrentPixelMapsetFramerunanimateengageFrameSoundGamepadEventInputEventRenderableRectangleShotProjectileonCompleteKeyboardEventVectorFrameBoundsGameImageVectorsubaddmultabsdivroundfloorceilnegequalstrig_distance_xyrandomizerotationalSpeedPointangleBetweenWebGLBoolEventOnCall Renderable Renderable Renderable : consistent base-type for graphic-objects Constructor new Renderable(args)  {Renderable} Parameters: Name Type Description args Object the object of arguments Source: gamestack.js, line 2738  Search results Close Documentation generated by JSDoc 3.5.5 "},"GameImage.html":{"id":"GameImage.html","title":"GameImage","body":" GameImage - Documentation GamestackJs Documentation Examplesspace-gameClassesGameWindowgetCanvascenterGridStyleonUpdateupdateonBeforeDrawonAfterDrawSizeaddBackgroundremoveanimatestartWebGL#getCanvasWebGL#centerWebGL#GridStyleWebGL#onUpdateWebGL#updateWebGL#onBeforeDrawWebGL#onAfterDrawWebGL#SizeWebGL#addWebGL#BackgroundWebGL#removeWebGL#animateWebGL#startCameraSpriteonLoadCloneAddLifeinitaddInitializerget_idcreate_idgetSizeByMaxSingleFrameLifeSpanLifeisDeaddieonScreenupdatedef_updateonUpdatetravelLineOnLoophasPixelCollisionhasBoxCollisionshootsubspriteanimateonAnimationCompleteaccelYaccelXdecelYdecelXacceldecelSmoothMotionSmoothRotatecenteroverlap_xoverlap_ycollide_stop_xcollide_stopcollide_stop_toprestoreFromSpriteArray#onLoadSpritesAnimationFrame#createColorMapinit_singleFrameonRunonCompleteReverseFramesSingleFramegetCurrentPixelMapsetFramerunanimateengageFrameSoundGamepadEventInputEventRenderableRectangleShotProjectileonCompleteKeyboardEventVectorFrameBoundsGameImageVectorsubaddmultabsdivroundfloorceilnegequalstrig_distance_xyrandomizerotationalSpeedPointangleBetweenWebGLBoolEventOnCall GameImage GameImage A game-image object based on HTMLImage element. Creates GameImage, attaches gameImage.domElement --an instance of HTMLImageElement Constructor new GameImage(src)  {GameImage} Parameters: Name Type Description src string the sourcePath of the image-file. Source: gamestack.js, line 2753  Search results Close Documentation generated by JSDoc 3.5.5 "},"Vector.html":{"id":"Vector.html","title":"Vector","body":" Vector - Documentation GamestackJs Documentation Examplesspace-gameClassesGameWindowgetCanvascenterGridStyleonUpdateupdateonBeforeDrawonAfterDrawSizeaddBackgroundremoveanimatestartWebGL#getCanvasWebGL#centerWebGL#GridStyleWebGL#onUpdateWebGL#updateWebGL#onBeforeDrawWebGL#onAfterDrawWebGL#SizeWebGL#addWebGL#BackgroundWebGL#removeWebGL#animateWebGL#startCameraSpriteonLoadCloneAddLifeinitaddInitializerget_idcreate_idgetSizeByMaxSingleFrameLifeSpanLifeisDeaddieonScreenupdatedef_updateonUpdatetravelLineOnLoophasPixelCollisionhasBoxCollisionshootsubspriteanimateonAnimationCompleteaccelYaccelXdecelYdecelXacceldecelSmoothMotionSmoothRotatecenteroverlap_xoverlap_ycollide_stop_xcollide_stopcollide_stop_toprestoreFromSpriteArray#onLoadSpritesAnimationFrame#createColorMapinit_singleFrameonRunonCompleteReverseFramesSingleFramegetCurrentPixelMapsetFramerunanimateengageFrameSoundGamepadEventInputEventRenderableRectangleShotProjectileonCompleteKeyboardEventVectorFrameBoundsGameImageVectorsubaddmultabsdivroundfloorceilnegequalstrig_distance_xyrandomizerotationalSpeedPointangleBetweenWebGLBoolEventOnCall Vector Vector Creates a Vector object with x, y, and --optional z. Constructor new Vector(x, y, z, r)  {Vector} Parameters: Name Type Description x number the x coordinate y number the y coordinate z number the optional z coordinate r number the optional r value Source: gamestack.js, line 3088 Methods sub(v) Subtracts another Vector from this vector and returns a vector for the resulting difference. Parameters: Name Type Description v Vector the vector to be subtracted from this vector Source: gamestack.js, line 3144 add(v) Adds another Vector to this vector and returns a vector for the resulting sum. Parameters: Name Type Description v Vector the vector to be added to this vector Source: gamestack.js, line 3165 mult(v) Multiplies another Vector by this vector and returns a vector for the resulting product. Parameters: Name Type Description v Vector the vector that this vector will by muliplied by Source: gamestack.js, line 3186 abs(v) Gets vector of absolute values. Parameters: Name Type Description v Vector the absolute vector Source: gamestack.js, line 3207 div(v) Divides another Vector by this vector and returns a vector for the resulting quotient. Parameters: Name Type Description v Vector the vector for this vector to be divided by Source: gamestack.js, line 3221 round()  {Vector} Rounds this vector to the nearest set of whole numbers and returns the result. Source: gamestack.js, line 3241 floor()  {Vector} Floors this vector to the nearest set of whole numbers and returns the result (subtractive-only, an x of 1.7 becomes 1) Source: gamestack.js, line 3254 ceil()  {Vector} Ceils this vector to the nearest set of whole numbers and returns the result (additive-only, an x of 1.2 becomes 2) Source: gamestack.js, line 3267 neg()  {Vector} Creates new vector, with the negated x,y,z values (-x-y-z), returns the resulting vector Source: gamestack.js, line 3280 equals()  {boolean} An equals-test for vectors. Returns true OR false. Source: gamestack.js, line 3292 trig_distance_xy()  {number} Gets the specific distance between this and the argument-vector. --applies to x and y of two vectors. Returns a single number. Source: gamestack.js, line 3305 randomize()  {Vector} Returns a vector-multiple: the original-size, multiplied by a random between the minFloat and maxFloat arguments. Source: gamestack.js, line 3332 rotationalSpeedPoint(rotation, speed)  {Vector} Returns a speed vector, based on rotation. Parameters: Name Type Description rotation number in degrees, 0-360 speed number the level of speed to apply, default being 1 Source: gamestack.js, line 3350 angleBetween(p1, p2)  {number} Returns the right-handed angle of degrees between two two position-vectors. Parameters: Name Type Description p1 Vector the 1st vector-argument p2 Vector the 2nd vector-argument Source: gamestack.js, line 3375  Search results Close Documentation generated by JSDoc 3.5.5 "},"WebGL.html":{"id":"WebGL.html","title":"WebGL","body":" WebGL - Documentation GamestackJs Documentation Examplesspace-gameClassesGameWindowgetCanvascenterGridStyleonUpdateupdateonBeforeDrawonAfterDrawSizeaddBackgroundremoveanimatestartWebGL#getCanvasWebGL#centerWebGL#GridStyleWebGL#onUpdateWebGL#updateWebGL#onBeforeDrawWebGL#onAfterDrawWebGL#SizeWebGL#addWebGL#BackgroundWebGL#removeWebGL#animateWebGL#startCameraSpriteonLoadCloneAddLifeinitaddInitializerget_idcreate_idgetSizeByMaxSingleFrameLifeSpanLifeisDeaddieonScreenupdatedef_updateonUpdatetravelLineOnLoophasPixelCollisionhasBoxCollisionshootsubspriteanimateonAnimationCompleteaccelYaccelXdecelYdecelXacceldecelSmoothMotionSmoothRotatecenteroverlap_xoverlap_ycollide_stop_xcollide_stopcollide_stop_toprestoreFromSpriteArray#onLoadSpritesAnimationFrame#createColorMapinit_singleFrameonRunonCompleteReverseFramesSingleFramegetCurrentPixelMapsetFramerunanimateengageFrameSoundGamepadEventInputEventRenderableRectangleShotProjectileonCompleteKeyboardEventVectorFrameBoundsGameImageVectorsubaddmultabsdivroundfloorceilnegequalstrig_distance_xyrandomizerotationalSpeedPointangleBetweenWebGLBoolEventOnCall WebGL WebGL Creates a GameWindow object. Constructor new WebGL(canvas, drawables)  {GameWindow} Parameters: Name Type Description canvas Object the canvas element for this gameWindow. --GameWindow's if not supplied, the constructor will create a full-screen canvas, if a canvas. drawables Object the drawable objects to be drawn. --Drawables can also be added after constructor call. Source: gamestack.js, line 3464  Search results Close Documentation generated by JSDoc 3.5.5 "},"InputEvent.html":{"id":"InputEvent.html","title":"InputEvent","body":" InputEvent - Documentation GamestackJs Documentation Examplesspace-gameClassesGameWindowgetCanvascenterGridStyleonUpdateupdateonBeforeDrawonAfterDrawSizeaddBackgroundremoveanimatestartWebGL#getCanvasWebGL#centerWebGL#GridStyleWebGL#onUpdateWebGL#updateWebGL#onBeforeDrawWebGL#onAfterDrawWebGL#SizeWebGL#addWebGL#BackgroundWebGL#removeWebGL#animateWebGL#startCameraSpriteonLoadCloneAddLifeinitaddInitializerget_idcreate_idgetSizeByMaxSingleFrameLifeSpanLifeisDeaddieonScreenupdatedef_updateonUpdatetravelLineOnLoophasPixelCollisionhasBoxCollisionshootsubspriteanimateonAnimationCompleteaccelYaccelXdecelYdecelXacceldecelSmoothMotionSmoothRotatecenteroverlap_xoverlap_ycollide_stop_xcollide_stopcollide_stop_toprestoreFromSpriteArray#onLoadSpritesAnimationFrame#createColorMapinit_singleFrameonRunonCompleteReverseFramesSingleFramegetCurrentPixelMapsetFramerunanimateengageFrameSoundGamepadEventInputEventRenderableRectangleShotProjectileonCompleteKeyboardEventVectorFrameBoundsGameImageVectorsubaddmultabsdivroundfloorceilnegequalstrig_distance_xyrandomizerotationalSpeedPointangleBetweenWebGLBoolEventOnCall InputEvent InputEvent Creates an instance of InputEvent Gamestack.InputEvent runs a callback function when a specified input is triggered Instead of calling Constructor new InputEvent(args)  {Gamestack.InputEvent} Parameters: Name Type Description args Object object of arguments Properties Name Type Description btnix number the index of controller-button to be applied gpix number the index of pc-gamepad --the 1st gamepad will have index 0 stickix number the controller-stick-index to be applied keys Array array of strings for keys to be applied callback function the function to call when InputEvent is triggered Source: gamestack.js, line 4388  Search results Close Documentation generated by JSDoc 3.5.5 "},"KeyboardEvent.html":{"id":"KeyboardEvent.html","title":"KeyboardEvent","body":" KeyboardEvent - Documentation GamestackJs Documentation Examplesspace-gameClassesGameWindowgetCanvascenterGridStyleonUpdateupdateonBeforeDrawonAfterDrawSizeaddBackgroundremoveanimatestartWebGL#getCanvasWebGL#centerWebGL#GridStyleWebGL#onUpdateWebGL#updateWebGL#onBeforeDrawWebGL#onAfterDrawWebGL#SizeWebGL#addWebGL#BackgroundWebGL#removeWebGL#animateWebGL#startCameraSpriteonLoadCloneAddLifeinitaddInitializerget_idcreate_idgetSizeByMaxSingleFrameLifeSpanLifeisDeaddieonScreenupdatedef_updateonUpdatetravelLineOnLoophasPixelCollisionhasBoxCollisionshootsubspriteanimateonAnimationCompleteaccelYaccelXdecelYdecelXacceldecelSmoothMotionSmoothRotatecenteroverlap_xoverlap_ycollide_stop_xcollide_stopcollide_stop_toprestoreFromSpriteArray#onLoadSpritesAnimationFrame#createColorMapinit_singleFrameonRunonCompleteReverseFramesSingleFramegetCurrentPixelMapsetFramerunanimateengageFrameSoundGamepadEventInputEventRenderableRectangleShotProjectileonCompleteKeyboardEventVectorFrameBoundsGameImageVectorsubaddmultabsdivroundfloorceilnegequalstrig_distance_xyrandomizerotationalSpeedPointangleBetweenWebGLBoolEventOnCall KeyboardEvent KeyboardEvent new KeyboardEvent(keys, callback)  {Gamestack.KeyboardEvent} Parameters: Name Type Description keys Array | string the Array of keys or single string-key for this event callback function the callback-function to be called when this event is triggered Source: gamestack.js, line 4447 Extends InputEvent  Search results Close Documentation generated by JSDoc 3.5.5 "},"GamepadEvent.html":{"id":"GamepadEvent.html","title":"GamepadEvent","body":" GamepadEvent - Documentation GamestackJs Documentation Examplesspace-gameClassesGameWindowgetCanvascenterGridStyleonUpdateupdateonBeforeDrawonAfterDrawSizeaddBackgroundremoveanimatestartWebGL#getCanvasWebGL#centerWebGL#GridStyleWebGL#onUpdateWebGL#updateWebGL#onBeforeDrawWebGL#onAfterDrawWebGL#SizeWebGL#addWebGL#BackgroundWebGL#removeWebGL#animateWebGL#startCameraSpriteonLoadCloneAddLifeinitaddInitializerget_idcreate_idgetSizeByMaxSingleFrameLifeSpanLifeisDeaddieonScreenupdatedef_updateonUpdatetravelLineOnLoophasPixelCollisionhasBoxCollisionshootsubspriteanimateonAnimationCompleteaccelYaccelXdecelYdecelXacceldecelSmoothMotionSmoothRotatecenteroverlap_xoverlap_ycollide_stop_xcollide_stopcollide_stop_toprestoreFromSpriteArray#onLoadSpritesAnimationFrame#createColorMapinit_singleFrameonRunonCompleteReverseFramesSingleFramegetCurrentPixelMapsetFramerunanimateengageFrameSoundGamepadEventInputEventRenderableRectangleShotProjectileonCompleteKeyboardEventVectorFrameBoundsGameImageVectorsubaddmultabsdivroundfloorceilnegequalstrig_distance_xyrandomizerotationalSpeedPointangleBetweenWebGLBoolEventOnCall GamepadEvent GamepadEvent new GamepadEvent(gamepadKeys, callback)  {Gamestack.GamepadEvent} Parameters: Name Type Description gamepadKeys Array | string the Array of gamepadKeys or single string-key, representing gamepad-buttons or gamepad-sticks for this event callback function the callback-function to be called when this event is triggered Source: gamestack.js, line 4504 Extends InputEvent  Search results Close Documentation generated by JSDoc 3.5.5 "},"BoolEvent.html":{"id":"BoolEvent.html","title":"BoolEvent","body":" BoolEvent - Documentation GamestackJs Documentation Examplesspace-gameClassesGameWindowgetCanvascenterGridStyleonUpdateupdateonBeforeDrawonAfterDrawSizeaddBackgroundremoveanimatestartWebGL#getCanvasWebGL#centerWebGL#GridStyleWebGL#onUpdateWebGL#updateWebGL#onBeforeDrawWebGL#onAfterDrawWebGL#SizeWebGL#addWebGL#BackgroundWebGL#removeWebGL#animateWebGL#startCameraSpriteonLoadCloneAddLifeinitaddInitializerget_idcreate_idgetSizeByMaxSingleFrameLifeSpanLifeisDeaddieonScreenupdatedef_updateonUpdatetravelLineOnLoophasPixelCollisionhasBoxCollisionshootsubspriteanimateonAnimationCompleteaccelYaccelXdecelYdecelXacceldecelSmoothMotionSmoothRotatecenteroverlap_xoverlap_ycollide_stop_xcollide_stopcollide_stop_toprestoreFromSpriteArray#onLoadSpritesAnimationFrame#createColorMapinit_singleFrameonRunonCompleteReverseFramesSingleFramegetCurrentPixelMapsetFramerunanimateengageFrameSoundGamepadEventInputEventRenderableRectangleShotProjectileonCompleteKeyboardEventVectorFrameBoundsGameImageVectorsubaddmultabsdivroundfloorceilnegequalstrig_distance_xyrandomizerotationalSpeedPointangleBetweenWebGLBoolEventOnCall BoolEvent BoolEvent returns BoolEvent --allows code to run whenever a conditional-function returns true Constructor new BoolEvent(onBool, call)  {BoolEvent} Parameters: Name Type Description onBool onBool the function to be tested each update call call the function to be called when onBool returns true; Source: gamestack.js, line 4618 Methods On(boolFunction)  {BoolEvent} applies a boolFunction to be tested for true each update Parameters: Name Type Description boolFunction boolFunction the function to be tested each update --replaces the value of boolEvent.onBool Source: gamestack.js, line 4643 Call(callbackFunction)  {BoolEvent} applies a callback to be called whenever the onBool function returns true Parameters: Name Type Description callbackFunction callbackFunction the function to be called --replaces the value of boolEvent.callback Source: gamestack.js, line 4660  Search results Close Documentation generated by JSDoc 3.5.5 "},"Frame.html":{"id":"Frame.html","title":"Frame","body":" Frame - Documentation GamestackJs Documentation Examplesspace-gameClassesGameWindowgetCanvascenterGridStyleonUpdateupdateonBeforeDrawonAfterDrawSizeaddBackgroundremoveanimatestartWebGL#getCanvasWebGL#centerWebGL#GridStyleWebGL#onUpdateWebGL#updateWebGL#onBeforeDrawWebGL#onAfterDrawWebGL#SizeWebGL#addWebGL#BackgroundWebGL#removeWebGL#animateWebGL#startCameraSpriteonLoadCloneAddLifeinitaddInitializerget_idcreate_idgetSizeByMaxSingleFrameLifeSpanLifeisDeaddieonScreenupdatedef_updateonUpdatetravelLineOnLoophasPixelCollisionhasBoxCollisionshootsubspriteanimateonAnimationCompleteaccelYaccelXdecelYdecelXacceldecelSmoothMotionSmoothRotatecenteroverlap_xoverlap_ycollide_stop_xcollide_stopcollide_stop_toprestoreFromSpriteArray#onLoadSpritesAnimationFrame#createColorMapinit_singleFrameonRunonCompleteReverseFramesSingleFramegetCurrentPixelMapsetFramerunanimateengageFrameSoundGamepadEventInputEventRenderableRectangleShotProjectileonCompleteKeyboardEventVectorFrameBoundsGameImageVectorsubaddmultabsdivroundfloorceilnegequalstrig_distance_xyrandomizerotationalSpeedPointangleBetweenWebGLBoolEventOnCall Frame Frame Creates an instance of Frame Gamestack.Frame is called automatically by Gamestack.Sprite and Gamestack.Animation. Gamestack.Frame does not take arguments. It is instantiated, then initilized with chainable function-calls. Constructor new Frame()  {Frame} Source: gamestack.js, line 4706 Example var selected_frame = new Gamestack.Frame().Image(gameImage).Size(frameSizeVector);  Search results Close Documentation generated by JSDoc 3.5.5 "},"Animation.html":{"id":"Animation.html","title":"Animation","body":" Animation - Documentation GamestackJs Documentation Examplesspace-gameClassesGameWindowgetCanvascenterGridStyleonUpdateupdateonBeforeDrawonAfterDrawSizeaddBackgroundremoveanimatestartWebGL#getCanvasWebGL#centerWebGL#GridStyleWebGL#onUpdateWebGL#updateWebGL#onBeforeDrawWebGL#onAfterDrawWebGL#SizeWebGL#addWebGL#BackgroundWebGL#removeWebGL#animateWebGL#startCameraSpriteonLoadCloneAddLifeinitaddInitializerget_idcreate_idgetSizeByMaxSingleFrameLifeSpanLifeisDeaddieonScreenupdatedef_updateonUpdatetravelLineOnLoophasPixelCollisionhasBoxCollisionshootsubspriteanimateonAnimationCompleteaccelYaccelXdecelYdecelXacceldecelSmoothMotionSmoothRotatecenteroverlap_xoverlap_ycollide_stop_xcollide_stopcollide_stop_toprestoreFromSpriteArray#onLoadSpritesAnimationFrame#createColorMapinit_singleFrameonRunonCompleteReverseFramesSingleFramegetCurrentPixelMapsetFramerunanimateengageFrameSoundGamepadEventInputEventRenderableRectangleShotProjectileonCompleteKeyboardEventVectorFrameBoundsGameImageVectorsubaddmultabsdivroundfloorceilnegequalstrig_distance_xyrandomizerotationalSpeedPointangleBetweenWebGLBoolEventOnCall Animation Animation Creates an instance of Animation with one or more Frames. Constructor new Animation(srcopt)  {Animation} Parameters: Name Type Attributes Description src string &lt;optional&gt; the src-image-path for this Animation Source: gamestack.js, line 5713 Examples //constructor call: Creates a single-frame Animation from src var singleFrameAnime = new Animation('directory/myFile.png'); //constructor call with chainable function-calls: Creates multi-frame Animation from src, then sets properties with chainable-function-calls. var multiFrameAnime = new Gamestack.Animation('../images/characters/full/spaceman1.png') //constructor is called .FrameSize(130, 130) .FrameBounds(new Gamestack.Vector(9, 0), new Gamestack.Vector(23, 0), new Gamestack.Vector(23, 0)) .Seesaw() //The Animation will play back-and-forth repeatedly (cycle through frames forwards, then backwards and so on. .Duration(900); //Animation lasts 900 millis OR just under 1 second Members (static) this.frameSize Properties: Name Type Description frameSize Vector the frameSize of the Animation Source: gamestack.js, line 5755 (static) this.frameBounds Properties: Name Type Description frameBounds VectorFrameBounds the frameBounds of the Animation, has three Vectors Source: gamestack.js, line 5766 (static) this.selected_frame Properties: Name Type Description selected_frame Frame the selected_frame of the Animation, a Gamestack.Frame Source: gamestack.js, line 5788 Methods (static) Frame#createColorMap(unitDimen) Creates and returns a ColorMap for this animation, allowing opacity-based pixel-collision. Parameters: Name Type Description unitDimen number a Colormap grid-unit-size --A larger unitDimen decreases accuracy, and results in faster-processing. Source: gamestack.js, line 4847 init_singleFrame() sets this Animation to a single-frame-animation, from existing image Source: gamestack.js, line 5871 onRun() Provides a function to be called whenever this Animation starts. Function should run every time the Animation reaches frame-index 0 Source: gamestack.js, line 5904 onComplete() Provides a function to be called whenever this Animation completes. Function should run every time the Animation reaches it's last frame-index. Source: gamestack.js, line 5920 ReverseFrames() Reverses all frames of the animation. Frames are then expected to run backwards. Source: gamestack.js, line 6001 SingleFrame(frameSize) Declares the animation a a single frame / full-image. Parameters: Name Type Description frameSize Vector optional size param Source: gamestack.js, line 6015 getCurrentPixelMap() Returns the existing ColorMap for this animation. Source: gamestack.js, line 6179 setFrame(ix) Sets the frame to a specific array-index. Parameters: Name Type Description ix number the frame-index to apply. Source: gamestack.js, line 6217 run() Applies a continuous animation. Use this in parent-sprite's update if continuous animation is required. Also works as a single call at any time during game-update. Source: gamestack.js, line 6247 animate() animate():: same as run() Source: gamestack.js, line 6274 engage(duration) Engages, or updates the animation for a one full frame-cycle. Parameters: Name Type Description duration number the number of milliseconds the animation should take. Source: gamestack.js, line 6302  Search results Close Documentation generated by JSDoc 3.5.5 "},"Sound.html":{"id":"Sound.html","title":"Sound","body":" Sound - Documentation GamestackJs Documentation Examplesspace-gameClassesGameWindowgetCanvascenterGridStyleonUpdateupdateonBeforeDrawonAfterDrawSizeaddBackgroundremoveanimatestartWebGL#getCanvasWebGL#centerWebGL#GridStyleWebGL#onUpdateWebGL#updateWebGL#onBeforeDrawWebGL#onAfterDrawWebGL#SizeWebGL#addWebGL#BackgroundWebGL#removeWebGL#animateWebGL#startCameraSpriteonLoadCloneAddLifeinitaddInitializerget_idcreate_idgetSizeByMaxSingleFrameLifeSpanLifeisDeaddieonScreenupdatedef_updateonUpdatetravelLineOnLoophasPixelCollisionhasBoxCollisionshootsubspriteanimateonAnimationCompleteaccelYaccelXdecelYdecelXacceldecelSmoothMotionSmoothRotatecenteroverlap_xoverlap_ycollide_stop_xcollide_stopcollide_stop_toprestoreFromSpriteArray#onLoadSpritesAnimationFrame#createColorMapinit_singleFrameonRunonCompleteReverseFramesSingleFramegetCurrentPixelMapsetFramerunanimateengageFrameSoundGamepadEventInputEventRenderableRectangleShotProjectileonCompleteKeyboardEventVectorFrameBoundsGameImageVectorsubaddmultabsdivroundfloorceilnegequalstrig_distance_xyrandomizerotationalSpeedPointangleBetweenWebGLBoolEventOnCall Sound Sound Creates a Sound instance. Implements HTML5-Audio object --DevTODO : complete docs for the Sound class Constructor new Sound(src)  {Sound} Parameters: Name Type Description src string the source-path of the targeted sound-file Source: gamestack.js, line 5323  Search results Close Documentation generated by JSDoc 3.5.5 "},"Sprite.html":{"id":"Sprite.html","title":"Sprite","body":" Sprite - Documentation GamestackJs Documentation Examplesspace-gameClassesGameWindowgetCanvascenterGridStyleonUpdateupdateonBeforeDrawonAfterDrawSizeaddBackgroundremoveanimatestartWebGL#getCanvasWebGL#centerWebGL#GridStyleWebGL#onUpdateWebGL#updateWebGL#onBeforeDrawWebGL#onAfterDrawWebGL#SizeWebGL#addWebGL#BackgroundWebGL#removeWebGL#animateWebGL#startCameraSpriteonLoadCloneAddLifeinitaddInitializerget_idcreate_idgetSizeByMaxSingleFrameLifeSpanLifeisDeaddieonScreenupdatedef_updateonUpdatetravelLineOnLoophasPixelCollisionhasBoxCollisionshootsubspriteanimateonAnimationCompleteaccelYaccelXdecelYdecelXacceldecelSmoothMotionSmoothRotatecenteroverlap_xoverlap_ycollide_stop_xcollide_stopcollide_stop_toprestoreFromSpriteArray#onLoadSpritesAnimationFrame#createColorMapinit_singleFrameonRunonCompleteReverseFramesSingleFramegetCurrentPixelMapsetFramerunanimateengageFrameSoundGamepadEventInputEventRenderableRectangleShotProjectileonCompleteKeyboardEventVectorFrameBoundsGameImageVectorsubaddmultabsdivroundfloorceilnegequalstrig_distance_xyrandomizerotationalSpeedPointangleBetweenWebGLBoolEventOnCall Sprite Sprite Creates a new Sprite. Gamestack.Sprite is a container for 2D Animations. -apply Sprite class to create a 2D game-object. Sprites hold reference to their-own Animations and Sounds. Constructor new Sprite(src, scale)  {Sprite} Parameters: Name Type Default Description src string the srcPath for the image of the Sprite scale number 1.0 the scale to be applied to size of each animation-frame Source: gamestack.js, line 6398 Members (static) this.id Properties: Name Type Description id String the unique identifier of the Sprite --called automatically on constructor. Source: gamestack.js, line 6522 (static) this.animations Properties: Name Type Description animations Array the array of animations attached to the Sprite Source: gamestack.js, line 6530 (static) this.scripts Properties: Name Type Description scripts Array the array of scripts attached to the Sprite Source: gamestack.js, line 6537 (static) this.speed Properties: Name Type Description speed Vector the speed of the Sprite Source: gamestack.js, line 6565 (static) this.size Properties: Name Type Description size Vector the vector-size of the Sprite Source: gamestack.js, line 6572 (static) this.position Properties: Name Type Description position Vector the position of the Sprite Source: gamestack.js, line 6581 (static) this.rotation Properties: Name Type Description rotation Vector the rotation of the Sprite Source: gamestack.js, line 6593 (static) this.scale Properties: Name Type Description scale number the scale of the Sprite, controls draw-size Source: gamestack.js, line 6601 Methods onLoad(f) runs a function for the onload event of this sprite's image Parameters: Name Type Description f function the function to be called on load Source: gamestack.js, line 6463 Clone(object) Clones a sprite from existing data Parameters: Name Type Description object Object the data to be cloned Source: gamestack.js, line 6673 Add(object) adds an animation to the sprites Parameters: Name Type Description object Object the animation to be added Source: gamestack.js, line 6807 Life(v)  {Sprite} pass argument v to the sprite.life property. Parameters: Name Type Description v number number of render-updates that this Sprite will last. --update occurs 60+ times per second, or less, depending on performance Source: gamestack.js, line 6902 init() initializes sprites. triggers all functions previously passed to the addInitializer function. Use this function when a sprite, instantiated from json-data, carries initializers. --This feature is built for the purpose of data-persistence. --sprites from json-file may carry behaviors onto the scene. Source: gamestack.js, line 6920 addInitializer(fun) extends the init function. Parameters: Name Type Description fun function the function to be passed into the init function of the sprite Source: gamestack.js, line 6932 get_id()  {string} returns the 'id' property of the sprite Source: gamestack.js, line 6954 create_id()  {string} creates a unique string id property for the sprite. Source: gamestack.js, line 6983 getSizeByMax(mx, my)  {Vector} returns a maximum scaled size, according to max dimensions of width and height Parameters: Name Type Description mx number the maximum size.x for the returned size my number the maximum size.y for the returned size Source: gamestack.js, line 6998 SingleFrame() set the 'selected_animation' property to a single-frame-animation Source: gamestack.js, line 7045 LifeSpan() set the 'life' property to a specified integer Source: gamestack.js, line 7088 Life() set the 'life' property to a specified integer Source: gamestack.js, line 7098 isDead() tells if sprite has been taken out of game Source: gamestack.js, line 7109 die() sets life to 0, then ending the sprite Source: gamestack.js, line 7122 onScreen(w, h)  {boolean} indicates if any portion of the sprite is within screen bounds --uses Gamestack.WIDTH, Gamestack.HEIGHT OR any w,h arguments passed to this method Parameters: Name Type Description w number optional screen-width argument, defaults to Gamestack.WIDTH h number optional screen-height argument, defaults to Gamestack.HEIGHT Source: gamestack.js, line 7139 update() the main update for the sprite --applied recursively by GameWindow after gameWindow.start is called Source: gamestack.js, line 7197 def_update() Automatically updates various speed and rotational properties for the Sprite() Source: gamestack.js, line 7223 Examples // applies a constant speed property --speed is Vector(x, y) mySprite.rot_speed = new Gamestack.Vector(3); //def_update() will run automatically with the gamestack update. The above sprite will rotate at a constant speed of 3. // how to reset to nothing:: if automatic speed updates are undesired, replace the def_update() function with a 'do nothing' function. mySprite.def_update = function() { //do nothing }; onUpdate(fun) extends the update of this sprite with a new function to be called during the update --repeated calls will extend, (not replace) the update --Allows multiple extensions of the update Parameters: Name Type Description fun function the function to be appended to sprite.update @example // extend the behavior of your sprite mySprite.onUpdate(function(spr) console.log('extended update'); //runs automatically whenever sprite.update runs }); Source: gamestack.js, line 7326 travelLineOnLoop() the sprite travels one line in a looping motion --useful for traveling Square, Circle, or other enclosed Lines. #Dev-todo:MORE ON THIS Source: gamestack.js, line 7424 hasPixelCollision(spr)  {boolean} returns a true || false value for immediate color-collision --non-transparent-pixels --between colored-pixels of this sprite and the sprite argument Parameters: Name Type Description spr Sprite the sprite object to be collided Source: gamestack.js, line 7484 hasBoxCollision(sprite)  {boolean} returns a true || false value for immediate box-collision --between this sprite and the sprite argument Parameters: Name Type Description sprite Sprite the alternate Sprite for collision detection Source: gamestack.js, line 7600 shoot(options, animation, speed, position, size, rot_offset) fire a Shot, or bullet-Sprite from the Sprite Parameters: Name Type Description options Object an object of arguments animation Gamestack.Animation the animation to fire from the Sprite speed number the speed of the shot that is projected position Gamestack.Vector the initial position of the shot: defaults to current Sprite position size Gamestack.Vector the Vector size of the shot rot_offset Gamestack.Vector the rotational offset to apply: controls direction of the shot Source: gamestack.js, line 7637 subsprite(options, animation, speed, position, size, offset)  {Sprite} create a sub-sprite belonging to the current sprite Parameters: Name Type Description options Object an object of arguments animation Animation the animation to fire from the Sprite speed number the speed of the shot that is projected position Vector the initial position of the shot: defaults to current Sprite position size Vector the Vector size of the shot offset Vector the positional offset to apply Source: gamestack.js, line 7747 animate(animation) switch to the next frame on sprite.selected_animation Parameters: Name Type Description animation Animation the optional animation to switch to before animate is called, defaults to the existing sprite.selected_animation Source: gamestack.js, line 7803 onAnimationComplete(fun) run a function when the sprite.selected_animation is complete Parameters: Name Type Description fun function the function to call when the animation is complete Source: gamestack.js, line 7826 accelY(accel, max) accelerate speed on the y-axis Parameters: Name Type Description accel number the increment of acceleration max number the maximum for speed Source: gamestack.js, line 7848 accelX(accel, max) accelerate speed on the x-Axis Parameters: Name Type Description accel number the increment of acceleration max number the maximum for speed Source: gamestack.js, line 7893 decelY(amt) decelerate speed on the x-Axis, toward zero Parameters: Name Type Description amt number the increment of deceleration, negatives ignored Source: gamestack.js, line 7935 decelX(amt) decelerate speed on the x-Axis, toward zero Parameters: Name Type Description amt number the increment of deceleration, negatives ignored Source: gamestack.js, line 7967 accel(prop, key, accel, max) accelerate toward a max value on any object-property Parameters: Name Type Description prop Object The object to control key string the target property-key for object argument accel number the additive increase to the property on each call max number the max value to accelerate towards Source: gamestack.js, line 7999 decel(prop, key, decel, max) decelerate toward a max value on any object-property Parameters: Name Type Description prop Object the object to control key string the property-key for targeted property of prop argument decel number the increment of deceleration max number the max value to decelerate towards Source: gamestack.js, line 8050 SmoothMotion(x, y, duration) A generic 'smooth motion', adds to position.x and position.y with smooth acceleration and deceleration --uses quadratic-easing of the TWEEN.js library Parameters: Name Type Description x number The x to be added to Sprite().positon.x over the course of the SmoothMotion --use negative for subtractive motion y number The y to be added to Sprite().positon.y over the course of the SmoothMotion- -use negative for subtractive motion duration number the amount of time taken to complete this motion Source: gamestack.js, line 8112 SmoothRotate(r, duration) A generic 'smooth rotate', adds to rotation.x with smooth acceleration and deceleration --uses quadratic-easing of the TWEEN.js library Parameters: Name Type Description r number The numeric value to be added to Sprite().rotation.x over the course of the SmoothRotate --use negative for subtractive rotation duration number the amount of time taken to complete this rotation Source: gamestack.js, line 8156 center() get the vector-position at the center of the sprite, based on its current position and size Source: gamestack.js, line 8192 overlap_x(item, padding)  {boolean} determine if sprite overlaps on x-axis with another sprite Parameters: Name Type Description item Sprite the Sprite to compare with padding number the 0-1.0 float value of padding to use on self when testing overlap Source: gamestack.js, line 8258 overlap_y(item, padding)  {boolean} determine if sprite overlaps on y-axis with another sprite Parameters: Name Type Description item Sprite the Sprite to compare with padding number the 0-1.0 float value of padding to use on self when testing overlap Source: gamestack.js, line 8293 collide_stop_x(item) stop collision on x-axis with another sprite Parameters: Name Type Description item Sprite the Sprite with which to collide-stop on the x-axis Source: gamestack.js, line 8325 collide_stop(item) Trigger a fourway collision-stop between this and another Sprite :: objects will behave clastically and resist passing through one-another Parameters: Name Type Description item Sprite the Sprite to collide with Source: gamestack.js, line 8376 collide_stop_top(item) collide-stop only from the top (of the sprite passed as argument) :: Parameters: Name Type Description item Sprite the Sprite to collide with Source: gamestack.js, line 8454 restoreFrom() restore a sprite from existing json-data --applies to data-persistence Source: gamestack.js, line 8489 (static) SpriteArray#onLoadSprites() runs a function when the sprite's image has loaded Source: gamestack.js, line 9659  Search results Close Documentation generated by JSDoc 3.5.5 "},"Shot.html":{"id":"Shot.html","title":"Shot","body":" Shot - Documentation GamestackJs Documentation Examplesspace-gameClassesGameWindowgetCanvascenterGridStyleonUpdateupdateonBeforeDrawonAfterDrawSizeaddBackgroundremoveanimatestartWebGL#getCanvasWebGL#centerWebGL#GridStyleWebGL#onUpdateWebGL#updateWebGL#onBeforeDrawWebGL#onAfterDrawWebGL#SizeWebGL#addWebGL#BackgroundWebGL#removeWebGL#animateWebGL#startCameraSpriteonLoadCloneAddLifeinitaddInitializerget_idcreate_idgetSizeByMaxSingleFrameLifeSpanLifeisDeaddieonScreenupdatedef_updateonUpdatetravelLineOnLoophasPixelCollisionhasBoxCollisionshootsubspriteanimateonAnimationCompleteaccelYaccelXdecelYdecelXacceldecelSmoothMotionSmoothRotatecenteroverlap_xoverlap_ycollide_stop_xcollide_stopcollide_stop_toprestoreFromSpriteArray#onLoadSpritesAnimationFrame#createColorMapinit_singleFrameonRunonCompleteReverseFramesSingleFramegetCurrentPixelMapsetFramerunanimateengageFrameSoundGamepadEventInputEventRenderableRectangleShotProjectileonCompleteKeyboardEventVectorFrameBoundsGameImageVectorsubaddmultabsdivroundfloorceilnegequalstrig_distance_xyrandomizerotationalSpeedPointangleBetweenWebGLBoolEventOnCall Shot Shot Creates an instance of Shot. Shot object fires a moving-animation from a sprite Constructor new Shot(name, imageOrAnimation)  {Shot} Parameters: Name Type Description name string the name of this Shot imageOrAnimation GameImage | Animation the GameImage or Animation to apply for this Shot Source: gamestack.js, line 8771  Search results Close Documentation generated by JSDoc 3.5.5 "},"Projectile.html":{"id":"Projectile.html","title":"Projectile","body":" Projectile - Documentation GamestackJs Documentation Examplesspace-gameClassesGameWindowgetCanvascenterGridStyleonUpdateupdateonBeforeDrawonAfterDrawSizeaddBackgroundremoveanimatestartWebGL#getCanvasWebGL#centerWebGL#GridStyleWebGL#onUpdateWebGL#updateWebGL#onBeforeDrawWebGL#onAfterDrawWebGL#SizeWebGL#addWebGL#BackgroundWebGL#removeWebGL#animateWebGL#startCameraSpriteonLoadCloneAddLifeinitaddInitializerget_idcreate_idgetSizeByMaxSingleFrameLifeSpanLifeisDeaddieonScreenupdatedef_updateonUpdatetravelLineOnLoophasPixelCollisionhasBoxCollisionshootsubspriteanimateonAnimationCompleteaccelYaccelXdecelYdecelXacceldecelSmoothMotionSmoothRotatecenteroverlap_xoverlap_ycollide_stop_xcollide_stopcollide_stop_toprestoreFromSpriteArray#onLoadSpritesAnimationFrame#createColorMapinit_singleFrameonRunonCompleteReverseFramesSingleFramegetCurrentPixelMapsetFramerunanimateengageFrameSoundGamepadEventInputEventRenderableRectangleShotProjectileonCompleteKeyboardEventVectorFrameBoundsGameImageVectorsubaddmultabsdivroundfloorceilnegequalstrig_distance_xyrandomizerotationalSpeedPointangleBetweenWebGLBoolEventOnCall Projectile Projectile Takes an object of arguments and returns Projectile() object. Projectile fires a shot from the parent sprite, with specified offset, rotation, motion_curve, line_curve Constructor new Projectile(args)  {Projectile} Parameters: Name Type Description args Object object of arguments Properties Name Type Description name string optional description string optional distance string the distance before dissappearance motion_curve TWEEN.Easing.'objectGroup'.'objectMember' the TWEEN.Easing function to be applied for motion/speed (Example: TWEEN.Easing.Quadratic.InOut) @param {TWEEN.Easing.'objectGroup'.'objectMember'} args.line_curve the TWEEN.Easing function to be applied for line (Example: TWEEN.Easing.Quadratic.InOut) Source: gamestack.js, line 9302 Methods onComplete(fun) specify a function to be called when Motion is complete Parameters: Name Type Description fun function the function to be called when complete Source: gamestack.js, line 9373  Search results Close Documentation generated by JSDoc 3.5.5 "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
