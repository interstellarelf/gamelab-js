<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Rectangle Block-Terrain Generator</title>
    <script src="../dist/gamelab/gamelab.js"></script>
    <script src="./../res/libraries/dat.gui.js"></script>
    <script src="./dat.gui.ext.js"></script>
    <link rel="stylesheet" href="../assets/javascript/dat.gui/dat.gui.css">
    <script src="./../res/libraries/jsmanipulate.js"></script>
    <script src="./res/html/gui-helpers.js"></script>
    <!-- spritebox-example.css style -->
    <link rel="stylesheet" href="../res/styles/gamelab-example.css">

    <style>

      body {
        overflow: scroll;
        height: 100%;
        overflow-y: hidden;
      }
      * {
        user-select: none;
      }
      span.dgc-title {
        position: absolute;
        z-index: 9999;
        width: 241px;
        height: 20px;
        font-size: 12px;
        top: 0;
        overflow: visible;
        background: #111;
        color: lightgrey;
        padding-left: 4px;
        border-bottom: 1px solid #444;
      }
      canvas.game-window,
      canvas.gameWindow,
      canvas.gamewindow {
        margin-top: -20px;
      }
      label.hidden-file {
        position: fixed;
        z-index: 9999;
        top: 12px;
        left: 140px;
        padding: 4px;
        border-radius: 4px;
        border: 1px solid lightgrey;
        background: #222;
        color: lightgrey;
        font-size: 14px;
      }
      label.hidden-file.two {
        left: 280px;
      }
      input[type=text] {
        font-family: surfaceFont;
      }
      #hidden-file {
        display: none;
      }
    </style>

  </head>
  <body>
    <header>
      <img src="../res/images/gamelab-logo.png" alt="" id="logo">
      <span class="title">Rectangle Block-Terrain Generator</span>
    </header>

    <img id="spritesheet-preview" src="" alt="" class="preview">

    <script>
      var sprite = new Gamelab.Sprite('./res/images/shapes/black-rect.png').Scale(1.0),
        args = false;
      var V = Gamelab.Vector;

      function BorderSetting() {
        return {
          lineWidth: 2,
          color: '#555555',
          opacity: 0.5,
          lineCap: 'round',
          applyGui: function (gui) {
            gui.add(this, 'lineWidth').min(0).max(10).step(1.0);
            gui.addColor(this, 'color');
            gui.add(this, 'opacity').min(0).max(1.0).step(0.1);
            gui.add(this, 'lineCap', ['butt', 'round', 'square']);
          }
        }
      };

      let SpriteBuilderProgram = {
        sources: [],
        overlays: [],
        surfaceFont: undefined,
        surfaceFontValue: '',
        surfaceImageFile: undefined,
        totalY: 0,
        buildIx: 0,
        config: {},
        blocks: [],
        backgroundImage1: undefined,
        surfaceImage1: undefined,
        surfaceImage2: undefined,
        topTrimming: undefined,
        borders1: {
          top: BorderSetting(),
          left: BorderSetting(),
          bottom: BorderSetting(),
          right: BorderSetting()
        },

        borders2: {
          top: BorderSetting(),
          left: BorderSetting(),
          bottom: BorderSetting(),
          right: BorderSetting()
        },

        useBorder: true,

        sizes: [
          new V(32, 32),
          new V(48, 48),
          new V(64, 64),
          new V(80, 80)
        ],

        framedOffset: {
          x: 0,
          y: 0
        },

        pushBlocks: function (blockArray) {
          if (!(blockArray instanceof Array)) {
            blockArray = [blockArray];
          }
          this.blocks = this.blocks.concat(blockArray);
        },
        ready: function () {

          let configModule = new Gamelab.Module().load('./res/configs/square-terrain-builder.config.js', (construct) => {
            SpriteBuilderProgram.config = new construct();
            var gui = new dat.GUI();

            var framedOffset1Folder = gui.addFolder('framedOffset');

            framedOffset1Folder.add(SpriteBuilderProgram.framedOffset, 'x');
            framedOffset1Folder.add(SpriteBuilderProgram.framedOffset, 'y');

            gui.add(SpriteBuilderProgram, 'useBorder');

            var leftBorder1Gui = gui.addFolder('leftBorder1'),
              topBorder1Gui = gui.addFolder('topBorder1'),
              bottomBorder1Gui = gui.addFolder('bottomBorder1'),
              rightBorder1Gui = gui.addFolder('rightBorder1');

            var leftBorder2Gui = gui.addFolder('leftBorder2'),
              topBorder2Gui = gui.addFolder('topBorder2'),
              bottomBorder2Gui = gui.addFolder('bottomBorder2'),
              rightBorder2Gui = gui.addFolder('rightBorder2');

            SpriteBuilderProgram.borders1.left.applyGui(leftBorder1Gui);
            SpriteBuilderProgram.borders1.top.applyGui(topBorder1Gui);
            SpriteBuilderProgram.borders1.bottom.applyGui(bottomBorder1Gui);
            SpriteBuilderProgram.borders1.right.applyGui(rightBorder1Gui);

            SpriteBuilderProgram.borders2.left.applyGui(leftBorder2Gui);
            SpriteBuilderProgram.borders2.top.applyGui(topBorder2Gui);
            SpriteBuilderProgram.borders2.bottom.applyGui(bottomBorder2Gui);
            SpriteBuilderProgram.borders2.right.applyGui(rightBorder2Gui);

            gui.addFileInput('Background Image', function (evt) {
              var file = evt.target.files[0];
              var $reader = new FileReader();
              $reader.addEventListener("load", function () {
                SpriteBuilderProgram.backgroundImage1 = this.result;
              });
              $reader.readAsDataURL(file);
            });

            gui.addFileInput('Surface Image 01', function (evt) {
              var file = evt.target.files[0];
              var $reader = new FileReader();
              $reader.addEventListener("load", function () {
                SpriteBuilderProgram.surfaceImage1 = this.result;
              });
              $reader.readAsDataURL(file);
            });

            gui.addFileInput('Top Trimming Image', function (evt) {
              var file = evt.target.files[0];
              var $reader = new FileReader();
              $reader.addEventListener("load", function () {
                SpriteBuilderProgram.topTrimming = this.result;
              });
              $reader.readAsDataURL(file);
            });

            gui.addButton('Render', function () {
              var blockList;
              SpriteBuilderProgram.sources.push(SpriteBuilderProgram.backgroundImage1);
              SpriteBuilderProgram.pushBlocks(SpriteBuilderProgram.getBrickSampleSprites(SpriteBuilderProgram.backgroundImage1));
            });

          });

        },

        getBrickSampleSprites: function (src, options = {}) {

          this.totalY = 0;
          this.buildIx = 0;

          gameWindow.drawables.forEach(function (item) {
            gameWindow.remove(item);
          });

          SpriteBuilderProgram.blocks = [];

          console.log('getBrickSampleSprites():');
          let sprites = [];

          var sizes = SpriteBuilderProgram.sizes;

          let ix = 0;

          let $app = this;

          //alert('new');

          sizes.forEach(function ($size) {

            SpriteBuilderProgram.buildIx += 1;

            var $sprite = new Gamelab.Sprite(src),
              $spriteLong = new Gamelab.Sprite(src),
              $spriteTall = new Gamelab.Sprite(src);

            $sprite.Position(50, SpriteBuilderProgram.totalY + 90 + (SpriteBuilderProgram.buildIx * 10));
            $spriteLong.Position(50 + 10 + $size.x, SpriteBuilderProgram.totalY + 90 + (SpriteBuilderProgram.buildIx * 10));
            $spriteTall.Position(50 + 10 + 10 + $size.x * 2.0, SpriteBuilderProgram.totalY + 90 + (SpriteBuilderProgram.buildIx * 10));

            $sprite.sx = $size.x;
            $sprite.sy = $size.y;

            $spriteLong.sx = $size.x;
            $spriteLong.sy = $size.y / 2.0;

            $spriteTall.sx = $size.x / 2.0;
            $spriteTall.sy = $size.y;

            $sprite.scale = 1.0;
            $spriteTall.scale = 1.0;
            $spriteLong.scale = 1.0;

            SpriteBuilderProgram.totalY += $size.y;

            var $spriteTrimming,
              $spriteLongTrimming,
              $spriteTallTrimming;

            if (SpriteBuilderProgram.topTrimming) {

              $spriteTrimming = new Gamelab.Sprite(SpriteBuilderProgram.topTrimming);

              $spriteTrimming.Pos($sprite.position);

              $spriteLongTrimming = new Gamelab.Sprite(SpriteBuilderProgram.topTrimming);

              $spriteLongTrimming.Pos($spriteLong.position);
              $spriteTallTrimming = new Gamelab.Sprite(SpriteBuilderProgram.topTrimming);

              $spriteTallTrimming.Pos($spriteTall.position);
            }

            var frameValue = {};

            if (ix == 0) {
              frameValue = SpriteBuilderProgram.framedOffset;
            }

            ix += 1;

            $sprite.onLoad(function () {
              this.anime.FrameSize(this.sx, this.sy).FrameOffset(frameValue.x, frameValue.y);
              this.Size(this.sx, this.sy);

              this.anime.run();
              this.borderSize = this.anime.frameSize;
              gameWindow.add(this);

              if ($spriteTrimming) {
                $spriteTrimming.Size(this.size);
                $spriteTrimming.anime.Size(this.size);
                console.info('trim', $spriteTrimming);
                gameWindow.add($spriteTrimming);
              }
              SpriteBuilderProgram.pushBlocks(this);
            });

            $spriteLong.onLoad(function () {
              this.anime.FrameSize(this.sx, this.sy).FrameOffset(frameValue.x, frameValue.y);
              this.Size(this.sx, this.sy);

              this.anime.run();
              this.borderSize = this.anime.frameSize;
              gameWindow.add(this);

              if ($spriteLongTrimming) {
                $spriteLongTrimming.Size(this.size);
                $spriteLongTrimming.anime.Size(this.size);
                console.info('trim', $spriteLongTrimming);
                gameWindow.add($spriteLongTrimming);
              }
              SpriteBuilderProgram.pushBlocks(this);
            });

            $spriteTall.onLoad(function () {
              this.anime.FrameSize(this.sx, this.sy).FrameOffset(frameValue.x, frameValue.y);
              this.Size(this.sx, this.sy);

              this.anime.run();
              this.borderSize = this.anime.frameSize;
              gameWindow.add(this);

              if ($spriteTallTrimming) {
                $spriteTallTrimming.Size(this.size);
                $spriteTallTrimming.anime.Size(this.size);
                console.info('trim', $spriteTallTrimming);
                gameWindow.add($spriteTallTrimming);
              }

              SpriteBuilderProgram.pushBlocks(this);
            });

            //  alert('adding sprite');

            sprites.push($sprite);
            sprites.push($spriteLong);
            sprites.push($spriteTall);

          });

          gameWindow.drawRectBorder = function (border, ctx, B) {

            if (!SpriteBuilderProgram.useBorder) {
              return;
            }

            //draw top border::
            var borderTop = border.top;
            ctx.lineWidth = borderTop.lineWidth;
            ctx.strokeStyle = borderTop.color;
            ctx.lineCap = borderTop.lineCap;
            ctx.beginPath();
            ctx.moveTo(B.position.x, B.position.y);
            ctx.lineTo(B.position.x + B.size.x, B.position.y);
            ctx.stroke();

            //draw right border::
            var borderLeft = border.left;
            ctx.lineWidth = borderLeft.lineWidth;
            ctx.strokeStyle = borderLeft.color;
            ctx.lineCap = borderLeft.lineCap;
            ctx.beginPath();
            ctx.moveTo(B.position.x, B.position.y);
            ctx.lineTo(B.position.x, B.position.y + B.size.y);
            ctx.stroke();

            //draw bottom border::
            var borderBottom = border.bottom;
            ctx.lineWidth = borderBottom.lineWidth;
            ctx.strokeStyle = borderBottom.color;
            ctx.lineCap = borderBottom.lineCap;
            ctx.beginPath();
            ctx.moveTo(B.position.x, B.position.y + B.size.y);
            ctx.lineTo(B.position.x + B.size.x, B.position.y + B.size.y);
            ctx.stroke();

            //draw left border::
            var borderRight = border.right;
            ctx.lineWidth = borderRight.lineWidth;
            ctx.strokeStyle = borderRight.color;
            ctx.lineCap = borderRight.lineCap;
            ctx.beginPath();
            ctx.moveTo(B.position.x + B.size.x, B.position.y);
            ctx.lineTo(B.position.x + B.size.x, B.position.y + B.size.y);
            ctx.stroke();

          };

          gameWindow.onAfterDraw(function () {

            $app.blocks.forEach(function (B) {
              let ctx = gameWindow.ctx;
              gameWindow.drawRectBorder(SpriteBuilderProgram.borders1, ctx, B);
              gameWindow.drawRectBorder(SpriteBuilderProgram.borders2, ctx, B);
            });
          });

          return sprites;
        },

        /*********************
        *
        * add-overlay :: the overlay is drawn directly over the sprite
        *
        *********************/

        addOverlayToSprites: function (sprites, overlay) {

          for (var x = 0; x < sprites.length; x++) {
            console.log('Do something w/ sprites');
          }
        }

      };

      //Create the game-window
      let gameWindow = new Gamelab.GameWindow().Background('black');
      var BEGIN = false;

      Gamelab.ready(function () {

        //start gameWindow
        if (!BEGIN) {

          BEGIN = true;
        }

        setInterval(function () {

          gameWindow.ctx.clearRect(0, 0, 3000, 3000);
          gameWindow.draw();

        }, 250);

        gameWindow.Size(2000, 1000);

        SpriteBuilderProgram.ready();

      });
    </script>

  </body>
</html>
